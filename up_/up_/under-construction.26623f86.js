// function f(f,v,e,s){Object.defineProperty(f,v,{get:e,set:s,enumerable:!0,configurable:!0})}function v(f){return f&&f.__esModule?f.default:f}var e=globalThis,s={},t={},i=e.parcelRequire94c2;null==i&&((i=function(f){if(f in s)return s[f].exports;if(f in t){var v=t[f];delete t[f];var e={id:f,exports:{}};return s[f]=e,v.call(e.exports,e,e.exports),e.exports}var i=Error("Cannot find module '"+f+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(f,v){t[f]=v},e.parcelRequire94c2=i);var n=i.register;n("27Lyk",function(v,e){f(v.exports,"register",()=>s,f=>s=f);var s,t=new Map;s=function(f,v){for(var e=0;e<v.length-1;e+=2)t.set(v[e],{baseUrl:f,path:v[e+1]})}}),n("n9UMu",function(f,v){let e;var s=i("9E8r7"),t=i("abnf3"),n=i("foJoU");!async function(){let f=window.location.href;if(f.includes("main")){let f=new s.CityScape3DRendering;await f.render()}else f.includes("new")&&new t.Chatbot().init()}();let r=document.getElementById("wordContainer");document.getElementById("caret"),document.querySelector(".we_exist");let o=["Raise the potential of the human race","Inspire life without limits","Build the future","Disrespect the impossible"],a=["We exist to","We believe in"],l=0,c=0;async function h(f){let v=o[f],s=a[f<4?0:1],t=v.substring(0,l+1)+"<span>|</span>";r&&(r.innerHTML=`<div>${t}</div>`),s.substring(0,c+1),l=Math.min(l+1,v.length),c=Math.min(c+1,s.length),l==v.length&&c==s.length&&(clearInterval(e),l=0,c=0,await (console.log("Sleeping for 2000"),new Promise(f=>setTimeout(f,2e3))),e=setInterval(()=>{let v=f+1;v==o.length&&(v=0),h(v)},150))}e=setInterval(()=>{h(0)},150);let u=f=>document.getElementById(f);(0,n.default).init();let d=document.getElementById("hamburger-btn"),p=u("mobile-menu"),m=u("close-btn"),g=()=>{p.classList.add("translate-x-0"),p.classList.remove("translate-x-full")},y=()=>{p.classList.add("translate-x-full"),p.classList.remove("translate-x-0")},x=()=>p.classList.contains("translate-x-0");d&&(d.addEventListener("click",()=>{x()?y():g()}),m&&m.addEventListener("click",()=>{y()}))}),n("9E8r7",function(v,e){f(v.exports,"CityScape3DRendering",()=>a);var s=i("ilwiq"),t=i("8YxfO"),n=i("9IBGu"),r=i("5Rd1x"),o=i("hI4z7");class a{constructor(){this.camera=null,this.scene=null,this.renderer=null,this.object=null}async render(){console.log("initializing 3d space"),await this.initialize3DSpace(),this.addWindowListeners(),this.animate()}animate(){console.log("animating"),this.object&&(this.object.rotation.y+=8e-5),requestAnimationFrame(()=>this.animate()),this.renderer.render(this.scene,this.camera)}addWindowListeners(){window.addEventListener("resize",()=>this.onWindowResize()),window.addEventListener("keydown",f=>{if(f.shiftKey){if(32===f.keyCode){console.log("position: ",this.camera.position);return}}else if(32===f.keyCode){console.log("rotation: ",camera.rotation);return}})}async initialize3DSpace(){this.camera=new s.PerspectiveCamera(45,window.innerWidth/window.innerHeight,.25,2e3),this.scene=new s.Scene,this.scene.fog=new s.Fog(0,0,45);let f=new s.HemisphereLight(0xfffff0,1052704,1.25);f.position.set(.75,1,.25),this.scene.add(f);try{this.object=await this.loadObject(o.modelString)}catch(e){let f=new s.BoxGeometry(1,1,1),v=new s.MeshBasicMaterial({color:65280});this.object=new s.Mesh(f,v)}var v=new s.LineBasicMaterial({color:0xffffff,linewidth:1});this.object.traverse(function(f){if(f.isMesh){f.material.length?f.material.forEach(f=>{f.opacity=.7,f.transparent=!0,f.color=new s.Color(13987)}):(f.material.opacity=.7,f.material.transparent=!0,f.material.color=new s.Color(13987));var e=new s.WireframeGeometry(f.geometry),t=new s.LineSegments(e,v);f.add(t)}});let e=new s.Box3().setFromObject(this.object),t=new s.Vector3;e.getCenter(t),this.object.position.set(-t.x,-t.y,-t.z),this.camera.position.y=7,this.camera.rotation.set(-.33266448095965767,-.8929000584948701,-.2628834797765133),this.scene.add(this.object),this.renderer=new s.WebGLRenderer({antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setClearColor(131092),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.toneMapping=s.ACESFilmicToneMapping,this.renderer.toneMappingExposure=1,this.renderer.outputEncoding=s.sRGBEncoding;let i=document.querySelector(".title");document.body.insertBefore(this.renderer.domElement,i),new s.PMREMGenerator(this.renderer).compileEquirectangularShader();let n=new r.OrbitControls(this.camera,this.renderer.domElement);n.minDistance=15,n.maxDistance=20,n.minPolarAngle=1.2,n.maxPolarAngle=1.9,n.target.set(4,4,10),n.update(),window.controls=n}onWindowResize(){this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,window.innerHeight)}async loadObject(f,v){let e=new t.OBJLoader;return v&&(e.setMaterials(v),console.log(v)),new Promise((v,s)=>{f?v(e.parse(f)):s("Invalid string!")})}async loadMaterial(f){let v=new n.MTLLoader;return v.setPath("3d/"),new Promise((e,s)=>{v.load(f,function(f){f.preload(),e(f)},function(f){console.log(f.loaded/f.total*100+"% loaded")},function(f){console.log("An error happened",f),s(f)})})}addLights(){let f=new s.AmbientLight(4210752,100);this.scene.add(f);let v=new s.DirectionalLight(0xffffff,100);v.position.set(0,1,0),v.castShadow=!0,this.scene.add(v);let e=new s.PointLight(0xc4c4c4,10);e.position.set(0,300,500),this.scene.add(e);let t=new s.PointLight(0xc4c4c4,10);t.position.set(500,100,0),this.scene.add(t);let i=new s.PointLight(0xc4c4c4,10);i.position.set(0,100,-500),this.scene.add(i);let n=new s.PointLight(0xc4c4c4,10);n.position.set(-500,300,500),this.scene.add(n)}}}),n("ilwiq",function(v,e){let s,t,i;f(v.exports,"MOUSE",()=>n),f(v.exports,"TOUCH",()=>r),f(v.exports,"FrontSide",()=>o),f(v.exports,"ACESFilmicToneMapping",()=>a),f(v.exports,"RepeatWrapping",()=>l),f(v.exports,"sRGBEncoding",()=>c),f(v.exports,"EventDispatcher",()=>u),f(v.exports,"Vector2",()=>g),f(v.exports,"Quaternion",()=>E),f(v.exports,"Vector3",()=>T),f(v.exports,"Box3",()=>R),f(v.exports,"Color",()=>fX),f(v.exports,"Material",()=>fJ),f(v.exports,"MeshBasicMaterial",()=>f$),f(v.exports,"Float32BufferAttribute",()=>f9),f(v.exports,"BufferGeometry",()=>vc),f(v.exports,"Mesh",()=>vR),f(v.exports,"PerspectiveCamera",()=>vH),f(v.exports,"Group",()=>sS),f(v.exports,"WebGLRenderer",()=>sA),f(v.exports,"Fog",()=>sC),f(v.exports,"Scene",()=>sP),f(v.exports,"LineBasicMaterial",()=>tt),f(v.exports,"LineSegments",()=>tu),f(v.exports,"PointsMaterial",()=>tp),f(v.exports,"Points",()=>tb),f(v.exports,"WireframeGeometry",()=>tZ),f(v.exports,"MeshPhongMaterial",()=>t1),f(v.exports,"DefaultLoadingManager",()=>id),f(v.exports,"Loader",()=>ip),f(v.exports,"FileLoader",()=>ig),f(v.exports,"TextureLoader",()=>iM),f(v.exports,"HemisphereLight",()=>iY),f(v.exports,"PointLight",()=>iK),f(v.exports,"DirectionalLight",()=>i3),f(v.exports,"AmbientLight",()=>i4),f(v.exports,"LoaderUtils",()=>i8),f(v.exports,"Spherical",()=>nC),f(v.exports,"PMREMGenerator",()=>nK),f(v.exports,"BoxGeometry",()=>vP);let n={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},r={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},o=0,a=4,l=1e3,c=3001,h="300 es";function u(){}Object.assign(u.prototype,{addEventListener:function(f,v){void 0===this._listeners&&(this._listeners={});let e=this._listeners;void 0===e[f]&&(e[f]=[]),-1===e[f].indexOf(v)&&e[f].push(v)},hasEventListener:function(f,v){if(void 0===this._listeners)return!1;let e=this._listeners;return void 0!==e[f]&&-1!==e[f].indexOf(v)},removeEventListener:function(f,v){if(void 0===this._listeners)return;let e=this._listeners[f];if(void 0!==e){let f=e.indexOf(v);-1!==f&&e.splice(f,1)}},dispatchEvent:function(f){if(void 0===this._listeners)return;let v=this._listeners[f.type];if(void 0!==v){f.target=this;let e=v.slice(0);for(let v=0,s=e.length;v<s;v++)e[v].call(this,f)}}});let d=[];for(let f=0;f<256;f++)d[f]=(f<16?"0":"")+f.toString(16);let p=1234567,m={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){let f=0xffffffff*Math.random()|0,v=0xffffffff*Math.random()|0,e=0xffffffff*Math.random()|0,s=0xffffffff*Math.random()|0;return(d[255&f]+d[f>>8&255]+d[f>>16&255]+d[f>>24&255]+"-"+d[255&v]+d[v>>8&255]+"-"+d[v>>16&15|64]+d[v>>24&255]+"-"+d[63&e|128]+d[e>>8&255]+"-"+d[e>>16&255]+d[e>>24&255]+d[255&s]+d[s>>8&255]+d[s>>16&255]+d[s>>24&255]).toUpperCase()},clamp:function(f,v,e){return Math.max(v,Math.min(e,f))},euclideanModulo:function(f,v){return(f%v+v)%v},mapLinear:function(f,v,e,s,t){return s+(f-v)*(t-s)/(e-v)},lerp:function(f,v,e){return(1-e)*f+e*v},damp:function(f,v,e,s){return m.lerp(f,v,1-Math.exp(-e*s))},pingpong:function(f,v=1){return v-Math.abs(m.euclideanModulo(f,2*v)-v)},smoothstep:function(f,v,e){return f<=v?0:f>=e?1:(f=(f-v)/(e-v))*f*(3-2*f)},smootherstep:function(f,v,e){return f<=v?0:f>=e?1:(f=(f-v)/(e-v))*f*f*(f*(6*f-15)+10)},randInt:function(f,v){return f+Math.floor(Math.random()*(v-f+1))},randFloat:function(f,v){return f+Math.random()*(v-f)},randFloatSpread:function(f){return f*(.5-Math.random())},seededRandom:function(f){return void 0!==f&&(p=f%0x7fffffff),((p=16807*p%0x7fffffff)-1)/0x7ffffffe},degToRad:function(f){return f*m.DEG2RAD},radToDeg:function(f){return f*m.RAD2DEG},isPowerOfTwo:function(f){return(f&f-1)==0&&0!==f},ceilPowerOfTwo:function(f){return Math.pow(2,Math.ceil(Math.log(f)/Math.LN2))},floorPowerOfTwo:function(f){return Math.pow(2,Math.floor(Math.log(f)/Math.LN2))},setQuaternionFromProperEuler:function(f,v,e,s,t){let i=Math.cos,n=Math.sin,r=i(e/2),o=n(e/2),a=i((v+s)/2),l=n((v+s)/2),c=i((v-s)/2),h=n((v-s)/2),u=i((s-v)/2),d=n((s-v)/2);switch(t){case"XYX":f.set(r*l,o*c,o*h,r*a);break;case"YZY":f.set(o*h,r*l,o*c,r*a);break;case"ZXZ":f.set(o*c,o*h,r*l,r*a);break;case"XZX":f.set(r*l,o*d,o*u,r*a);break;case"YXY":f.set(o*u,r*l,o*d,r*a);break;case"ZYZ":f.set(o*d,o*u,r*l,r*a);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+t)}}};class g{constructor(f=0,v=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=f,this.y=v}get width(){return this.x}set width(f){this.x=f}get height(){return this.y}set height(f){this.y=f}set(f,v){return this.x=f,this.y=v,this}setScalar(f){return this.x=f,this.y=f,this}setX(f){return this.x=f,this}setY(f){return this.y=f,this}setComponent(f,v){switch(f){case 0:this.x=v;break;case 1:this.y=v;break;default:throw Error("index is out of range: "+f)}return this}getComponent(f){switch(f){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+f)}}clone(){return new this.constructor(this.x,this.y)}copy(f){return this.x=f.x,this.y=f.y,this}add(f,v){return void 0!==v?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(f,v)):(this.x+=f.x,this.y+=f.y,this)}addScalar(f){return this.x+=f,this.y+=f,this}addVectors(f,v){return this.x=f.x+v.x,this.y=f.y+v.y,this}addScaledVector(f,v){return this.x+=f.x*v,this.y+=f.y*v,this}sub(f,v){return void 0!==v?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(f,v)):(this.x-=f.x,this.y-=f.y,this)}subScalar(f){return this.x-=f,this.y-=f,this}subVectors(f,v){return this.x=f.x-v.x,this.y=f.y-v.y,this}multiply(f){return this.x*=f.x,this.y*=f.y,this}multiplyScalar(f){return this.x*=f,this.y*=f,this}divide(f){return this.x/=f.x,this.y/=f.y,this}divideScalar(f){return this.multiplyScalar(1/f)}applyMatrix3(f){let v=this.x,e=this.y,s=f.elements;return this.x=s[0]*v+s[3]*e+s[6],this.y=s[1]*v+s[4]*e+s[7],this}min(f){return this.x=Math.min(this.x,f.x),this.y=Math.min(this.y,f.y),this}max(f){return this.x=Math.max(this.x,f.x),this.y=Math.max(this.y,f.y),this}clamp(f,v){return this.x=Math.max(f.x,Math.min(v.x,this.x)),this.y=Math.max(f.y,Math.min(v.y,this.y)),this}clampScalar(f,v){return this.x=Math.max(f,Math.min(v,this.x)),this.y=Math.max(f,Math.min(v,this.y)),this}clampLength(f,v){let e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(f,Math.min(v,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(f){return this.x*f.x+this.y*f.y}cross(f){return this.x*f.y-this.y*f.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(f){return Math.sqrt(this.distanceToSquared(f))}distanceToSquared(f){let v=this.x-f.x,e=this.y-f.y;return v*v+e*e}manhattanDistanceTo(f){return Math.abs(this.x-f.x)+Math.abs(this.y-f.y)}setLength(f){return this.normalize().multiplyScalar(f)}lerp(f,v){return this.x+=(f.x-this.x)*v,this.y+=(f.y-this.y)*v,this}lerpVectors(f,v,e){return this.x=f.x+(v.x-f.x)*e,this.y=f.y+(v.y-f.y)*e,this}equals(f){return f.x===this.x&&f.y===this.y}fromArray(f,v=0){return this.x=f[v],this.y=f[v+1],this}toArray(f=[],v=0){return f[v]=this.x,f[v+1]=this.y,f}fromBufferAttribute(f,v,e){return void 0!==e&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=f.getX(v),this.y=f.getY(v),this}rotateAround(f,v){let e=Math.cos(v),s=Math.sin(v),t=this.x-f.x,i=this.y-f.y;return this.x=t*e-i*s+f.x,this.y=t*s+i*e+f.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class y{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(f,v,e,s,t,i,n,r,o){let a=this.elements;return a[0]=f,a[1]=s,a[2]=n,a[3]=v,a[4]=t,a[5]=r,a[6]=e,a[7]=i,a[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(f){let v=this.elements,e=f.elements;return v[0]=e[0],v[1]=e[1],v[2]=e[2],v[3]=e[3],v[4]=e[4],v[5]=e[5],v[6]=e[6],v[7]=e[7],v[8]=e[8],this}extractBasis(f,v,e){return f.setFromMatrix3Column(this,0),v.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(f){let v=f.elements;return this.set(v[0],v[4],v[8],v[1],v[5],v[9],v[2],v[6],v[10]),this}multiply(f){return this.multiplyMatrices(this,f)}premultiply(f){return this.multiplyMatrices(f,this)}multiplyMatrices(f,v){let e=f.elements,s=v.elements,t=this.elements,i=e[0],n=e[3],r=e[6],o=e[1],a=e[4],l=e[7],c=e[2],h=e[5],u=e[8],d=s[0],p=s[3],m=s[6],g=s[1],y=s[4],x=s[7],b=s[2],_=s[5],w=s[8];return t[0]=i*d+n*g+r*b,t[3]=i*p+n*y+r*_,t[6]=i*m+n*x+r*w,t[1]=o*d+a*g+l*b,t[4]=o*p+a*y+l*_,t[7]=o*m+a*x+l*w,t[2]=c*d+h*g+u*b,t[5]=c*p+h*y+u*_,t[8]=c*m+h*x+u*w,this}multiplyScalar(f){let v=this.elements;return v[0]*=f,v[3]*=f,v[6]*=f,v[1]*=f,v[4]*=f,v[7]*=f,v[2]*=f,v[5]*=f,v[8]*=f,this}determinant(){let f=this.elements,v=f[0],e=f[1],s=f[2],t=f[3],i=f[4],n=f[5],r=f[6],o=f[7],a=f[8];return v*i*a-v*n*o-e*t*a+e*n*r+s*t*o-s*i*r}invert(){let f=this.elements,v=f[0],e=f[1],s=f[2],t=f[3],i=f[4],n=f[5],r=f[6],o=f[7],a=f[8],l=a*i-n*o,c=n*r-a*t,h=o*t-i*r,u=v*l+e*c+s*h;if(0===u)return this.set(0,0,0,0,0,0,0,0,0);let d=1/u;return f[0]=l*d,f[1]=(s*o-a*e)*d,f[2]=(n*e-s*i)*d,f[3]=c*d,f[4]=(a*v-s*r)*d,f[5]=(s*t-n*v)*d,f[6]=h*d,f[7]=(e*r-o*v)*d,f[8]=(i*v-e*t)*d,this}transpose(){let f;let v=this.elements;return f=v[1],v[1]=v[3],v[3]=f,f=v[2],v[2]=v[6],v[6]=f,f=v[5],v[5]=v[7],v[7]=f,this}getNormalMatrix(f){return this.setFromMatrix4(f).copy(this).invert().transpose()}transposeIntoArray(f){let v=this.elements;return f[0]=v[0],f[1]=v[3],f[2]=v[6],f[3]=v[1],f[4]=v[4],f[5]=v[7],f[6]=v[2],f[7]=v[5],f[8]=v[8],this}setUvTransform(f,v,e,s,t,i,n){let r=Math.cos(t),o=Math.sin(t);return this.set(e*r,e*o,-e*(r*i+o*n)+i+f,-s*o,s*r,-s*(-o*i+r*n)+n+v,0,0,1),this}scale(f,v){let e=this.elements;return e[0]*=f,e[3]*=f,e[6]*=f,e[1]*=v,e[4]*=v,e[7]*=v,this}rotate(f){let v=Math.cos(f),e=Math.sin(f),s=this.elements,t=s[0],i=s[3],n=s[6],r=s[1],o=s[4],a=s[7];return s[0]=v*t+e*r,s[3]=v*i+e*o,s[6]=v*n+e*a,s[1]=-e*t+v*r,s[4]=-e*i+v*o,s[7]=-e*n+v*a,this}translate(f,v){let e=this.elements;return e[0]+=f*e[2],e[3]+=f*e[5],e[6]+=f*e[8],e[1]+=v*e[2],e[4]+=v*e[5],e[7]+=v*e[8],this}equals(f){let v=this.elements,e=f.elements;for(let f=0;f<9;f++)if(v[f]!==e[f])return!1;return!0}fromArray(f,v=0){for(let e=0;e<9;e++)this.elements[e]=f[e+v];return this}toArray(f=[],v=0){let e=this.elements;return f[v]=e[0],f[v+1]=e[1],f[v+2]=e[2],f[v+3]=e[3],f[v+4]=e[4],f[v+5]=e[5],f[v+6]=e[6],f[v+7]=e[7],f[v+8]=e[8],f}}let x={getDataURL:function(f){let v;if(/^data:/i.test(f.src)||"undefined"==typeof HTMLCanvasElement)return f.src;if(f instanceof HTMLCanvasElement)v=f;else{void 0===s&&(s=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),s.width=f.width,s.height=f.height;let e=s.getContext("2d");f instanceof ImageData?e.putImageData(f,0,0):e.drawImage(f,0,0,f.width,f.height),v=s}return v.width>2048||v.height>2048?v.toDataURL("image/jpeg",.6):v.toDataURL("image/png")}},b=0;function _(f=_.DEFAULT_IMAGE,v=_.DEFAULT_MAPPING,e=1001,s=1001,t=1006,i=1008,n=1023,r=1009,o=1,a=3e3){Object.defineProperty(this,"id",{value:b++}),this.uuid=m.generateUUID(),this.name="",this.image=f,this.mipmaps=[],this.mapping=v,this.wrapS=e,this.wrapT=s,this.magFilter=t,this.minFilter=i,this.anisotropy=o,this.format=n,this.internalFormat=null,this.type=r,this.offset=new g(0,0),this.repeat=new g(1,1),this.center=new g(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new y,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=a,this.version=0,this.onUpdate=null}function w(f){return"undefined"!=typeof HTMLImageElement&&f instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&f instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&f instanceof ImageBitmap?x.getDataURL(f):f.data?{data:Array.prototype.slice.call(f.data),width:f.width,height:f.height,type:f.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}_.DEFAULT_IMAGE=void 0,_.DEFAULT_MAPPING=300,_.prototype=Object.assign(Object.create(u.prototype),{constructor:_,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(f){return this.name=f.name,this.image=f.image,this.mipmaps=f.mipmaps.slice(0),this.mapping=f.mapping,this.wrapS=f.wrapS,this.wrapT=f.wrapT,this.magFilter=f.magFilter,this.minFilter=f.minFilter,this.anisotropy=f.anisotropy,this.format=f.format,this.internalFormat=f.internalFormat,this.type=f.type,this.offset.copy(f.offset),this.repeat.copy(f.repeat),this.center.copy(f.center),this.rotation=f.rotation,this.matrixAutoUpdate=f.matrixAutoUpdate,this.matrix.copy(f.matrix),this.generateMipmaps=f.generateMipmaps,this.premultiplyAlpha=f.premultiplyAlpha,this.flipY=f.flipY,this.unpackAlignment=f.unpackAlignment,this.encoding=f.encoding,this},toJSON:function(f){let v=void 0===f||"string"==typeof f;if(!v&&void 0!==f.textures[this.uuid])return f.textures[this.uuid];let e={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){let s=this.image;if(void 0===s.uuid&&(s.uuid=m.generateUUID()),!v&&void 0===f.images[s.uuid]){let v;if(Array.isArray(s)){v=[];for(let f=0,e=s.length;f<e;f++)s[f].isDataTexture?v.push(w(s[f].image)):v.push(w(s[f]))}else v=w(s);f.images[s.uuid]={uuid:s.uuid,url:v}}e.image=s.uuid}return v||(f.textures[this.uuid]=e),e},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(f){if(300!==this.mapping)return f;if(f.applyMatrix3(this.matrix),f.x<0||f.x>1)switch(this.wrapS){case l:f.x=f.x-Math.floor(f.x);break;case 1001:f.x=f.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(f.x)%2)?f.x=Math.ceil(f.x)-f.x:f.x=f.x-Math.floor(f.x)}if(f.y<0||f.y>1)switch(this.wrapT){case l:f.y=f.y-Math.floor(f.y);break;case 1001:f.y=f.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(f.y)%2)?f.y=Math.ceil(f.y)-f.y:f.y=f.y-Math.floor(f.y)}return this.flipY&&(f.y=1-f.y),f}}),Object.defineProperty(_.prototype,"needsUpdate",{set:function(f){!0===f&&this.version++}});class M{constructor(f=0,v=0,e=0,s=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=f,this.y=v,this.z=e,this.w=s}get width(){return this.z}set width(f){this.z=f}get height(){return this.w}set height(f){this.w=f}set(f,v,e,s){return this.x=f,this.y=v,this.z=e,this.w=s,this}setScalar(f){return this.x=f,this.y=f,this.z=f,this.w=f,this}setX(f){return this.x=f,this}setY(f){return this.y=f,this}setZ(f){return this.z=f,this}setW(f){return this.w=f,this}setComponent(f,v){switch(f){case 0:this.x=v;break;case 1:this.y=v;break;case 2:this.z=v;break;case 3:this.w=v;break;default:throw Error("index is out of range: "+f)}return this}getComponent(f){switch(f){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+f)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(f){return this.x=f.x,this.y=f.y,this.z=f.z,this.w=void 0!==f.w?f.w:1,this}add(f,v){return void 0!==v?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(f,v)):(this.x+=f.x,this.y+=f.y,this.z+=f.z,this.w+=f.w,this)}addScalar(f){return this.x+=f,this.y+=f,this.z+=f,this.w+=f,this}addVectors(f,v){return this.x=f.x+v.x,this.y=f.y+v.y,this.z=f.z+v.z,this.w=f.w+v.w,this}addScaledVector(f,v){return this.x+=f.x*v,this.y+=f.y*v,this.z+=f.z*v,this.w+=f.w*v,this}sub(f,v){return void 0!==v?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(f,v)):(this.x-=f.x,this.y-=f.y,this.z-=f.z,this.w-=f.w,this)}subScalar(f){return this.x-=f,this.y-=f,this.z-=f,this.w-=f,this}subVectors(f,v){return this.x=f.x-v.x,this.y=f.y-v.y,this.z=f.z-v.z,this.w=f.w-v.w,this}multiply(f){return this.x*=f.x,this.y*=f.y,this.z*=f.z,this.w*=f.w,this}multiplyScalar(f){return this.x*=f,this.y*=f,this.z*=f,this.w*=f,this}applyMatrix4(f){let v=this.x,e=this.y,s=this.z,t=this.w,i=f.elements;return this.x=i[0]*v+i[4]*e+i[8]*s+i[12]*t,this.y=i[1]*v+i[5]*e+i[9]*s+i[13]*t,this.z=i[2]*v+i[6]*e+i[10]*s+i[14]*t,this.w=i[3]*v+i[7]*e+i[11]*s+i[15]*t,this}divideScalar(f){return this.multiplyScalar(1/f)}setAxisAngleFromQuaternion(f){this.w=2*Math.acos(f.w);let v=Math.sqrt(1-f.w*f.w);return v<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=f.x/v,this.y=f.y/v,this.z=f.z/v),this}setAxisAngleFromRotationMatrix(f){let v,e,s,t;let i=f.elements,n=i[0],r=i[4],o=i[8],a=i[1],l=i[5],c=i[9],h=i[2],u=i[6],d=i[10];if(.01>Math.abs(r-a)&&.01>Math.abs(o-h)&&.01>Math.abs(c-u)){if(.1>Math.abs(r+a)&&.1>Math.abs(o+h)&&.1>Math.abs(c+u)&&.1>Math.abs(n+l+d-3))return this.set(1,0,0,0),this;v=Math.PI;let f=(n+1)/2,i=(l+1)/2,p=(d+1)/2,m=(r+a)/4,g=(o+h)/4,y=(c+u)/4;return f>i&&f>p?f<.01?(e=0,s=.707106781,t=.707106781):(s=m/(e=Math.sqrt(f)),t=g/e):i>p?i<.01?(e=.707106781,s=0,t=.707106781):(e=m/(s=Math.sqrt(i)),t=y/s):p<.01?(e=.707106781,s=.707106781,t=0):(e=g/(t=Math.sqrt(p)),s=y/t),this.set(e,s,t,v),this}let p=Math.sqrt((u-c)*(u-c)+(o-h)*(o-h)+(a-r)*(a-r));return .001>Math.abs(p)&&(p=1),this.x=(u-c)/p,this.y=(o-h)/p,this.z=(a-r)/p,this.w=Math.acos((n+l+d-1)/2),this}min(f){return this.x=Math.min(this.x,f.x),this.y=Math.min(this.y,f.y),this.z=Math.min(this.z,f.z),this.w=Math.min(this.w,f.w),this}max(f){return this.x=Math.max(this.x,f.x),this.y=Math.max(this.y,f.y),this.z=Math.max(this.z,f.z),this.w=Math.max(this.w,f.w),this}clamp(f,v){return this.x=Math.max(f.x,Math.min(v.x,this.x)),this.y=Math.max(f.y,Math.min(v.y,this.y)),this.z=Math.max(f.z,Math.min(v.z,this.z)),this.w=Math.max(f.w,Math.min(v.w,this.w)),this}clampScalar(f,v){return this.x=Math.max(f,Math.min(v,this.x)),this.y=Math.max(f,Math.min(v,this.y)),this.z=Math.max(f,Math.min(v,this.z)),this.w=Math.max(f,Math.min(v,this.w)),this}clampLength(f,v){let e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(f,Math.min(v,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(f){return this.x*f.x+this.y*f.y+this.z*f.z+this.w*f.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(f){return this.normalize().multiplyScalar(f)}lerp(f,v){return this.x+=(f.x-this.x)*v,this.y+=(f.y-this.y)*v,this.z+=(f.z-this.z)*v,this.w+=(f.w-this.w)*v,this}lerpVectors(f,v,e){return this.x=f.x+(v.x-f.x)*e,this.y=f.y+(v.y-f.y)*e,this.z=f.z+(v.z-f.z)*e,this.w=f.w+(v.w-f.w)*e,this}equals(f){return f.x===this.x&&f.y===this.y&&f.z===this.z&&f.w===this.w}fromArray(f,v=0){return this.x=f[v],this.y=f[v+1],this.z=f[v+2],this.w=f[v+3],this}toArray(f=[],v=0){return f[v]=this.x,f[v+1]=this.y,f[v+2]=this.z,f[v+3]=this.w,f}fromBufferAttribute(f,v,e){return void 0!==e&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=f.getX(v),this.y=f.getY(v),this.z=f.getZ(v),this.w=f.getW(v),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class S extends u{constructor(f,v,e){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=f,this.height=v,this.scissor=new M(0,0,f,v),this.scissorTest=!1,this.viewport=new M(0,0,f,v),e=e||{},this.texture=new _(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.image={},this.texture.image.width=f,this.texture.image.height=v,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:1006,this.depthBuffer=void 0===e.depthBuffer||e.depthBuffer,this.stencilBuffer=void 0!==e.stencilBuffer&&e.stencilBuffer,this.depthTexture=void 0!==e.depthTexture?e.depthTexture:null}setSize(f,v){(this.width!==f||this.height!==v)&&(this.width=f,this.height=v,this.texture.image.width=f,this.texture.image.height=v,this.dispose()),this.viewport.set(0,0,f,v),this.scissor.set(0,0,f,v)}clone(){return new this.constructor().copy(this)}copy(f){return this.width=f.width,this.height=f.height,this.viewport.copy(f.viewport),this.texture=f.texture.clone(),this.depthBuffer=f.depthBuffer,this.stencilBuffer=f.stencilBuffer,this.depthTexture=f.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class E{constructor(f=0,v=0,e=0,s=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=f,this._y=v,this._z=e,this._w=s}static slerp(f,v,e,s){return e.copy(f).slerp(v,s)}static slerpFlat(f,v,e,s,t,i,n){let r=e[s+0],o=e[s+1],a=e[s+2],l=e[s+3],c=t[i+0],h=t[i+1],u=t[i+2],d=t[i+3];if(l!==d||r!==c||o!==h||a!==u){let f=1-n,v=r*c+o*h+a*u+l*d,e=v>=0?1:-1,s=1-v*v;if(s>Number.EPSILON){let t=Math.sqrt(s),i=Math.atan2(t,v*e);f=Math.sin(f*i)/t,n=Math.sin(n*i)/t}let t=n*e;if(r=r*f+c*t,o=o*f+h*t,a=a*f+u*t,l=l*f+d*t,f===1-n){let f=1/Math.sqrt(r*r+o*o+a*a+l*l);r*=f,o*=f,a*=f,l*=f}}f[v]=r,f[v+1]=o,f[v+2]=a,f[v+3]=l}static multiplyQuaternionsFlat(f,v,e,s,t,i){let n=e[s],r=e[s+1],o=e[s+2],a=e[s+3],l=t[i],c=t[i+1],h=t[i+2],u=t[i+3];return f[v]=n*u+a*l+r*h-o*c,f[v+1]=r*u+a*c+o*l-n*h,f[v+2]=o*u+a*h+n*c-r*l,f[v+3]=a*u-n*l-r*c-o*h,f}get x(){return this._x}set x(f){this._x=f,this._onChangeCallback()}get y(){return this._y}set y(f){this._y=f,this._onChangeCallback()}get z(){return this._z}set z(f){this._z=f,this._onChangeCallback()}get w(){return this._w}set w(f){this._w=f,this._onChangeCallback()}set(f,v,e,s){return this._x=f,this._y=v,this._z=e,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(f){return this._x=f.x,this._y=f.y,this._z=f.z,this._w=f.w,this._onChangeCallback(),this}setFromEuler(f,v){if(!(f&&f.isEuler))throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");let e=f._x,s=f._y,t=f._z,i=f._order,n=Math.cos,r=Math.sin,o=n(e/2),a=n(s/2),l=n(t/2),c=r(e/2),h=r(s/2),u=r(t/2);switch(i){case"XYZ":this._x=c*a*l+o*h*u,this._y=o*h*l-c*a*u,this._z=o*a*u+c*h*l,this._w=o*a*l-c*h*u;break;case"YXZ":this._x=c*a*l+o*h*u,this._y=o*h*l-c*a*u,this._z=o*a*u-c*h*l,this._w=o*a*l+c*h*u;break;case"ZXY":this._x=c*a*l-o*h*u,this._y=o*h*l+c*a*u,this._z=o*a*u+c*h*l,this._w=o*a*l-c*h*u;break;case"ZYX":this._x=c*a*l-o*h*u,this._y=o*h*l+c*a*u,this._z=o*a*u-c*h*l,this._w=o*a*l+c*h*u;break;case"YZX":this._x=c*a*l+o*h*u,this._y=o*h*l+c*a*u,this._z=o*a*u-c*h*l,this._w=o*a*l-c*h*u;break;case"XZY":this._x=c*a*l-o*h*u,this._y=o*h*l-c*a*u,this._z=o*a*u+c*h*l,this._w=o*a*l+c*h*u;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+i)}return!1!==v&&this._onChangeCallback(),this}setFromAxisAngle(f,v){let e=v/2,s=Math.sin(e);return this._x=f.x*s,this._y=f.y*s,this._z=f.z*s,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(f){let v=f.elements,e=v[0],s=v[4],t=v[8],i=v[1],n=v[5],r=v[9],o=v[2],a=v[6],l=v[10],c=e+n+l;if(c>0){let f=.5/Math.sqrt(c+1);this._w=.25/f,this._x=(a-r)*f,this._y=(t-o)*f,this._z=(i-s)*f}else if(e>n&&e>l){let f=2*Math.sqrt(1+e-n-l);this._w=(a-r)/f,this._x=.25*f,this._y=(s+i)/f,this._z=(t+o)/f}else if(n>l){let f=2*Math.sqrt(1+n-e-l);this._w=(t-o)/f,this._x=(s+i)/f,this._y=.25*f,this._z=(r+a)/f}else{let f=2*Math.sqrt(1+l-e-n);this._w=(i-s)/f,this._x=(t+o)/f,this._y=(r+a)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(f,v){let e=f.dot(v)+1;return e<1e-6?(e=0,Math.abs(f.x)>Math.abs(f.z)?(this._x=-f.y,this._y=f.x,this._z=0):(this._x=0,this._y=-f.z,this._z=f.y)):(this._x=f.y*v.z-f.z*v.y,this._y=f.z*v.x-f.x*v.z,this._z=f.x*v.y-f.y*v.x),this._w=e,this.normalize()}angleTo(f){return 2*Math.acos(Math.abs(m.clamp(this.dot(f),-1,1)))}rotateTowards(f,v){let e=this.angleTo(f);if(0===e)return this;let s=Math.min(1,v/e);return this.slerp(f,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(f){return this._x*f._x+this._y*f._y+this._z*f._z+this._w*f._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let f=this.length();return 0===f?(this._x=0,this._y=0,this._z=0,this._w=1):(f=1/f,this._x=this._x*f,this._y=this._y*f,this._z=this._z*f,this._w=this._w*f),this._onChangeCallback(),this}multiply(f,v){return void 0!==v?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(f,v)):this.multiplyQuaternions(this,f)}premultiply(f){return this.multiplyQuaternions(f,this)}multiplyQuaternions(f,v){let e=f._x,s=f._y,t=f._z,i=f._w,n=v._x,r=v._y,o=v._z,a=v._w;return this._x=e*a+i*n+s*o-t*r,this._y=s*a+i*r+t*n-e*o,this._z=t*a+i*o+e*r-s*n,this._w=i*a-e*n-s*r-t*o,this._onChangeCallback(),this}slerp(f,v){if(0===v)return this;if(1===v)return this.copy(f);let e=this._x,s=this._y,t=this._z,i=this._w,n=i*f._w+e*f._x+s*f._y+t*f._z;if(n<0?(this._w=-f._w,this._x=-f._x,this._y=-f._y,this._z=-f._z,n=-n):this.copy(f),n>=1)return this._w=i,this._x=e,this._y=s,this._z=t,this;let r=1-n*n;if(r<=Number.EPSILON){let f=1-v;return this._w=f*i+v*this._w,this._x=f*e+v*this._x,this._y=f*s+v*this._y,this._z=f*t+v*this._z,this.normalize(),this._onChangeCallback(),this}let o=Math.sqrt(r),a=Math.atan2(o,n),l=Math.sin((1-v)*a)/o,c=Math.sin(v*a)/o;return this._w=i*l+this._w*c,this._x=e*l+this._x*c,this._y=s*l+this._y*c,this._z=t*l+this._z*c,this._onChangeCallback(),this}equals(f){return f._x===this._x&&f._y===this._y&&f._z===this._z&&f._w===this._w}fromArray(f,v=0){return this._x=f[v],this._y=f[v+1],this._z=f[v+2],this._w=f[v+3],this._onChangeCallback(),this}toArray(f=[],v=0){return f[v]=this._x,f[v+1]=this._y,f[v+2]=this._z,f[v+3]=this._w,f}fromBufferAttribute(f,v){return this._x=f.getX(v),this._y=f.getY(v),this._z=f.getZ(v),this._w=f.getW(v),this}_onChange(f){return this._onChangeCallback=f,this}_onChangeCallback(){}}class T{constructor(f=0,v=0,e=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=f,this.y=v,this.z=e}set(f,v,e){return void 0===e&&(e=this.z),this.x=f,this.y=v,this.z=e,this}setScalar(f){return this.x=f,this.y=f,this.z=f,this}setX(f){return this.x=f,this}setY(f){return this.y=f,this}setZ(f){return this.z=f,this}setComponent(f,v){switch(f){case 0:this.x=v;break;case 1:this.y=v;break;case 2:this.z=v;break;default:throw Error("index is out of range: "+f)}return this}getComponent(f){switch(f){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+f)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(f){return this.x=f.x,this.y=f.y,this.z=f.z,this}add(f,v){return void 0!==v?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(f,v)):(this.x+=f.x,this.y+=f.y,this.z+=f.z,this)}addScalar(f){return this.x+=f,this.y+=f,this.z+=f,this}addVectors(f,v){return this.x=f.x+v.x,this.y=f.y+v.y,this.z=f.z+v.z,this}addScaledVector(f,v){return this.x+=f.x*v,this.y+=f.y*v,this.z+=f.z*v,this}sub(f,v){return void 0!==v?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(f,v)):(this.x-=f.x,this.y-=f.y,this.z-=f.z,this)}subScalar(f){return this.x-=f,this.y-=f,this.z-=f,this}subVectors(f,v){return this.x=f.x-v.x,this.y=f.y-v.y,this.z=f.z-v.z,this}multiply(f,v){return void 0!==v?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(f,v)):(this.x*=f.x,this.y*=f.y,this.z*=f.z,this)}multiplyScalar(f){return this.x*=f,this.y*=f,this.z*=f,this}multiplyVectors(f,v){return this.x=f.x*v.x,this.y=f.y*v.y,this.z=f.z*v.z,this}applyEuler(f){return f&&f.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(A.setFromEuler(f))}applyAxisAngle(f,v){return this.applyQuaternion(A.setFromAxisAngle(f,v))}applyMatrix3(f){let v=this.x,e=this.y,s=this.z,t=f.elements;return this.x=t[0]*v+t[3]*e+t[6]*s,this.y=t[1]*v+t[4]*e+t[7]*s,this.z=t[2]*v+t[5]*e+t[8]*s,this}applyNormalMatrix(f){return this.applyMatrix3(f).normalize()}applyMatrix4(f){let v=this.x,e=this.y,s=this.z,t=f.elements,i=1/(t[3]*v+t[7]*e+t[11]*s+t[15]);return this.x=(t[0]*v+t[4]*e+t[8]*s+t[12])*i,this.y=(t[1]*v+t[5]*e+t[9]*s+t[13])*i,this.z=(t[2]*v+t[6]*e+t[10]*s+t[14])*i,this}applyQuaternion(f){let v=this.x,e=this.y,s=this.z,t=f.x,i=f.y,n=f.z,r=f.w,o=r*v+i*s-n*e,a=r*e+n*v-t*s,l=r*s+t*e-i*v,c=-t*v-i*e-n*s;return this.x=o*r+-(c*t)+-(a*n)- -(l*i),this.y=a*r+-(c*i)+-(l*t)- -(o*n),this.z=l*r+-(c*n)+-(o*i)- -(a*t),this}project(f){return this.applyMatrix4(f.matrixWorldInverse).applyMatrix4(f.projectionMatrix)}unproject(f){return this.applyMatrix4(f.projectionMatrixInverse).applyMatrix4(f.matrixWorld)}transformDirection(f){let v=this.x,e=this.y,s=this.z,t=f.elements;return this.x=t[0]*v+t[4]*e+t[8]*s,this.y=t[1]*v+t[5]*e+t[9]*s,this.z=t[2]*v+t[6]*e+t[10]*s,this.normalize()}divide(f){return this.x/=f.x,this.y/=f.y,this.z/=f.z,this}divideScalar(f){return this.multiplyScalar(1/f)}min(f){return this.x=Math.min(this.x,f.x),this.y=Math.min(this.y,f.y),this.z=Math.min(this.z,f.z),this}max(f){return this.x=Math.max(this.x,f.x),this.y=Math.max(this.y,f.y),this.z=Math.max(this.z,f.z),this}clamp(f,v){return this.x=Math.max(f.x,Math.min(v.x,this.x)),this.y=Math.max(f.y,Math.min(v.y,this.y)),this.z=Math.max(f.z,Math.min(v.z,this.z)),this}clampScalar(f,v){return this.x=Math.max(f,Math.min(v,this.x)),this.y=Math.max(f,Math.min(v,this.y)),this.z=Math.max(f,Math.min(v,this.z)),this}clampLength(f,v){let e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(f,Math.min(v,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(f){return this.x*f.x+this.y*f.y+this.z*f.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(f){return this.normalize().multiplyScalar(f)}lerp(f,v){return this.x+=(f.x-this.x)*v,this.y+=(f.y-this.y)*v,this.z+=(f.z-this.z)*v,this}lerpVectors(f,v,e){return this.x=f.x+(v.x-f.x)*e,this.y=f.y+(v.y-f.y)*e,this.z=f.z+(v.z-f.z)*e,this}cross(f,v){return void 0!==v?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(f,v)):this.crossVectors(this,f)}crossVectors(f,v){let e=f.x,s=f.y,t=f.z,i=v.x,n=v.y,r=v.z;return this.x=s*r-t*n,this.y=t*i-e*r,this.z=e*n-s*i,this}projectOnVector(f){let v=f.lengthSq();if(0===v)return this.set(0,0,0);let e=f.dot(this)/v;return this.copy(f).multiplyScalar(e)}projectOnPlane(f){return L.copy(this).projectOnVector(f),this.sub(L)}reflect(f){return this.sub(L.copy(f).multiplyScalar(2*this.dot(f)))}angleTo(f){let v=Math.sqrt(this.lengthSq()*f.lengthSq());if(0===v)return Math.PI/2;let e=this.dot(f)/v;return Math.acos(m.clamp(e,-1,1))}distanceTo(f){return Math.sqrt(this.distanceToSquared(f))}distanceToSquared(f){let v=this.x-f.x,e=this.y-f.y,s=this.z-f.z;return v*v+e*e+s*s}manhattanDistanceTo(f){return Math.abs(this.x-f.x)+Math.abs(this.y-f.y)+Math.abs(this.z-f.z)}setFromSpherical(f){return this.setFromSphericalCoords(f.radius,f.phi,f.theta)}setFromSphericalCoords(f,v,e){let s=Math.sin(v)*f;return this.x=s*Math.sin(e),this.y=Math.cos(v)*f,this.z=s*Math.cos(e),this}setFromCylindrical(f){return this.setFromCylindricalCoords(f.radius,f.theta,f.y)}setFromCylindricalCoords(f,v,e){return this.x=f*Math.sin(v),this.y=e,this.z=f*Math.cos(v),this}setFromMatrixPosition(f){let v=f.elements;return this.x=v[12],this.y=v[13],this.z=v[14],this}setFromMatrixScale(f){let v=this.setFromMatrixColumn(f,0).length(),e=this.setFromMatrixColumn(f,1).length(),s=this.setFromMatrixColumn(f,2).length();return this.x=v,this.y=e,this.z=s,this}setFromMatrixColumn(f,v){return this.fromArray(f.elements,4*v)}setFromMatrix3Column(f,v){return this.fromArray(f.elements,3*v)}equals(f){return f.x===this.x&&f.y===this.y&&f.z===this.z}fromArray(f,v=0){return this.x=f[v],this.y=f[v+1],this.z=f[v+2],this}toArray(f=[],v=0){return f[v]=this.x,f[v+1]=this.y,f[v+2]=this.z,f}fromBufferAttribute(f,v,e){return void 0!==e&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=f.getX(v),this.y=f.getY(v),this.z=f.getZ(v),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}let L=/*@__PURE__*/new T,A=/*@__PURE__*/new E;class R{constructor(f,v){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==f?f:new T(1/0,1/0,1/0),this.max=void 0!==v?v:new T(-1/0,-1/0,-1/0)}set(f,v){return this.min.copy(f),this.max.copy(v),this}setFromArray(f){let v=1/0,e=1/0,s=1/0,t=-1/0,i=-1/0,n=-1/0;for(let r=0,o=f.length;r<o;r+=3){let o=f[r],a=f[r+1],l=f[r+2];o<v&&(v=o),a<e&&(e=a),l<s&&(s=l),o>t&&(t=o),a>i&&(i=a),l>n&&(n=l)}return this.min.set(v,e,s),this.max.set(t,i,n),this}setFromBufferAttribute(f){let v=1/0,e=1/0,s=1/0,t=-1/0,i=-1/0,n=-1/0;for(let r=0,o=f.count;r<o;r++){let o=f.getX(r),a=f.getY(r),l=f.getZ(r);o<v&&(v=o),a<e&&(e=a),l<s&&(s=l),o>t&&(t=o),a>i&&(i=a),l>n&&(n=l)}return this.min.set(v,e,s),this.max.set(t,i,n),this}setFromPoints(f){this.makeEmpty();for(let v=0,e=f.length;v<e;v++)this.expandByPoint(f[v]);return this}setFromCenterAndSize(f,v){let e=O.copy(v).multiplyScalar(.5);return this.min.copy(f).sub(e),this.max.copy(f).add(e),this}setFromObject(f){return this.makeEmpty(),this.expandByObject(f)}clone(){return new this.constructor().copy(this)}copy(f){return this.min.copy(f.min),this.max.copy(f.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(f){return void 0===f&&(console.warn("THREE.Box3: .getCenter() target is now required"),f=new T),this.isEmpty()?f.set(0,0,0):f.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(f){return void 0===f&&(console.warn("THREE.Box3: .getSize() target is now required"),f=new T),this.isEmpty()?f.set(0,0,0):f.subVectors(this.max,this.min)}expandByPoint(f){return this.min.min(f),this.max.max(f),this}expandByVector(f){return this.min.sub(f),this.max.add(f),this}expandByScalar(f){return this.min.addScalar(-f),this.max.addScalar(f),this}expandByObject(f){f.updateWorldMatrix(!1,!1);let v=f.geometry;void 0!==v&&(null===v.boundingBox&&v.computeBoundingBox(),D.copy(v.boundingBox),D.applyMatrix4(f.matrixWorld),this.union(D));let e=f.children;for(let f=0,v=e.length;f<v;f++)this.expandByObject(e[f]);return this}containsPoint(f){return!(f.x<this.min.x)&&!(f.x>this.max.x)&&!(f.y<this.min.y)&&!(f.y>this.max.y)&&!(f.z<this.min.z)&&!(f.z>this.max.z)}containsBox(f){return this.min.x<=f.min.x&&f.max.x<=this.max.x&&this.min.y<=f.min.y&&f.max.y<=this.max.y&&this.min.z<=f.min.z&&f.max.z<=this.max.z}getParameter(f,v){return void 0===v&&(console.warn("THREE.Box3: .getParameter() target is now required"),v=new T),v.set((f.x-this.min.x)/(this.max.x-this.min.x),(f.y-this.min.y)/(this.max.y-this.min.y),(f.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(f){return!(f.max.x<this.min.x)&&!(f.min.x>this.max.x)&&!(f.max.y<this.min.y)&&!(f.min.y>this.max.y)&&!(f.max.z<this.min.z)&&!(f.min.z>this.max.z)}intersectsSphere(f){return this.clampPoint(f.center,O),O.distanceToSquared(f.center)<=f.radius*f.radius}intersectsPlane(f){let v,e;return f.normal.x>0?(v=f.normal.x*this.min.x,e=f.normal.x*this.max.x):(v=f.normal.x*this.max.x,e=f.normal.x*this.min.x),f.normal.y>0?(v+=f.normal.y*this.min.y,e+=f.normal.y*this.max.y):(v+=f.normal.y*this.max.y,e+=f.normal.y*this.min.y),f.normal.z>0?(v+=f.normal.z*this.min.z,e+=f.normal.z*this.max.z):(v+=f.normal.z*this.max.z,e+=f.normal.z*this.min.z),v<=-f.constant&&e>=-f.constant}intersectsTriangle(f){if(this.isEmpty())return!1;this.getCenter(U),k.subVectors(this.max,U),I.subVectors(f.a,U),N.subVectors(f.b,U),z.subVectors(f.c,U),H.subVectors(N,I),F.subVectors(z,N),B.subVectors(I,z);let v=[0,-H.z,H.y,0,-F.z,F.y,0,-B.z,B.y,H.z,0,-H.x,F.z,0,-F.x,B.z,0,-B.x,-H.y,H.x,0,-F.y,F.x,0,-B.y,B.x,0];return!!(C(v,I,N,z,k)&&C(v=[1,0,0,0,1,0,0,0,1],I,N,z,k))&&(G.crossVectors(H,F),C(v=[G.x,G.y,G.z],I,N,z,k))}clampPoint(f,v){return void 0===v&&(console.warn("THREE.Box3: .clampPoint() target is now required"),v=new T),v.copy(f).clamp(this.min,this.max)}distanceToPoint(f){return O.copy(f).clamp(this.min,this.max).sub(f).length()}getBoundingSphere(f){return void 0===f&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(f.center),f.radius=.5*this.getSize(O).length(),f}intersect(f){return this.min.max(f.min),this.max.min(f.max),this.isEmpty()&&this.makeEmpty(),this}union(f){return this.min.min(f.min),this.max.max(f.max),this}applyMatrix4(f){return this.isEmpty()||(P[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(f),P[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(f),P[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(f),P[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(f),P[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(f),P[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(f),P[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(f),P[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(f),this.setFromPoints(P)),this}translate(f){return this.min.add(f),this.max.add(f),this}equals(f){return f.min.equals(this.min)&&f.max.equals(this.max)}}function C(f,v,e,s,t){for(let i=0,n=f.length-3;i<=n;i+=3){j.fromArray(f,i);let n=t.x*Math.abs(j.x)+t.y*Math.abs(j.y)+t.z*Math.abs(j.z),r=v.dot(j),o=e.dot(j),a=s.dot(j);if(Math.max(-Math.max(r,o,a),Math.min(r,o,a))>n)return!1}return!0}let P=[/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T,/*@__PURE__*/new T],O=/*@__PURE__*/new T,D=/*@__PURE__*/new R,I=/*@__PURE__*/new T,N=/*@__PURE__*/new T,z=/*@__PURE__*/new T,H=/*@__PURE__*/new T,F=/*@__PURE__*/new T,B=/*@__PURE__*/new T,U=/*@__PURE__*/new T,k=/*@__PURE__*/new T,G=/*@__PURE__*/new T,j=/*@__PURE__*/new T,V=/*@__PURE__*/new R;class W{constructor(f,v){this.center=void 0!==f?f:new T,this.radius=void 0!==v?v:-1}set(f,v){return this.center.copy(f),this.radius=v,this}setFromPoints(f,v){let e=this.center;void 0!==v?e.copy(v):V.setFromPoints(f).getCenter(e);let s=0;for(let v=0,t=f.length;v<t;v++)s=Math.max(s,e.distanceToSquared(f[v]));return this.radius=Math.sqrt(s),this}clone(){return new this.constructor().copy(this)}copy(f){return this.center.copy(f.center),this.radius=f.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(f){return f.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(f){return f.distanceTo(this.center)-this.radius}intersectsSphere(f){let v=this.radius+f.radius;return f.center.distanceToSquared(this.center)<=v*v}intersectsBox(f){return f.intersectsSphere(this)}intersectsPlane(f){return Math.abs(f.distanceToPoint(this.center))<=this.radius}clampPoint(f,v){let e=this.center.distanceToSquared(f);return void 0===v&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),v=new T),v.copy(f),e>this.radius*this.radius&&(v.sub(this.center).normalize(),v.multiplyScalar(this.radius).add(this.center)),v}getBoundingBox(f){return(void 0===f&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),f=new R),this.isEmpty())?f.makeEmpty():(f.set(this.center,this.center),f.expandByScalar(this.radius)),f}applyMatrix4(f){return this.center.applyMatrix4(f),this.radius=this.radius*f.getMaxScaleOnAxis(),this}translate(f){return this.center.add(f),this}equals(f){return f.center.equals(this.center)&&f.radius===this.radius}}let q=/*@__PURE__*/new T,X=/*@__PURE__*/new T,Y=/*@__PURE__*/new T,Z=/*@__PURE__*/new T,J=/*@__PURE__*/new T,$=/*@__PURE__*/new T,Q=/*@__PURE__*/new T;class K{constructor(f,v){this.origin=void 0!==f?f:new T,this.direction=void 0!==v?v:new T(0,0,-1)}set(f,v){return this.origin.copy(f),this.direction.copy(v),this}clone(){return new this.constructor().copy(this)}copy(f){return this.origin.copy(f.origin),this.direction.copy(f.direction),this}at(f,v){return void 0===v&&(console.warn("THREE.Ray: .at() target is now required"),v=new T),v.copy(this.direction).multiplyScalar(f).add(this.origin)}lookAt(f){return this.direction.copy(f).sub(this.origin).normalize(),this}recast(f){return this.origin.copy(this.at(f,q)),this}closestPointToPoint(f,v){void 0===v&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),v=new T),v.subVectors(f,this.origin);let e=v.dot(this.direction);return e<0?v.copy(this.origin):v.copy(this.direction).multiplyScalar(e).add(this.origin)}distanceToPoint(f){return Math.sqrt(this.distanceSqToPoint(f))}distanceSqToPoint(f){let v=q.subVectors(f,this.origin).dot(this.direction);return v<0?this.origin.distanceToSquared(f):(q.copy(this.direction).multiplyScalar(v).add(this.origin),q.distanceToSquared(f))}distanceSqToSegment(f,v,e,s){let t,i,n,r;X.copy(f).add(v).multiplyScalar(.5),Y.copy(v).sub(f).normalize(),Z.copy(this.origin).sub(X);let o=.5*f.distanceTo(v),a=-this.direction.dot(Y),l=Z.dot(this.direction),c=-Z.dot(Y),h=Z.lengthSq(),u=Math.abs(1-a*a);if(u>0){if(t=a*c-l,i=a*l-c,r=o*u,t>=0){if(i>=-r){if(i<=r){let f=1/u;t*=f,i*=f,n=t*(t+a*i+2*l)+i*(a*t+i+2*c)+h}else n=-(t=Math.max(0,-(a*(i=o)+l)))*t+i*(i+2*c)+h}else n=-(t=Math.max(0,-(a*(i=-o)+l)))*t+i*(i+2*c)+h}else i<=-r?(i=(t=Math.max(0,-(-a*o+l)))>0?-o:Math.min(Math.max(-o,-c),o),n=-t*t+i*(i+2*c)+h):i<=r?(t=0,n=(i=Math.min(Math.max(-o,-c),o))*(i+2*c)+h):(i=(t=Math.max(0,-(a*o+l)))>0?o:Math.min(Math.max(-o,-c),o),n=-t*t+i*(i+2*c)+h)}else i=a>0?-o:o,n=-(t=Math.max(0,-(a*i+l)))*t+i*(i+2*c)+h;return e&&e.copy(this.direction).multiplyScalar(t).add(this.origin),s&&s.copy(Y).multiplyScalar(i).add(X),n}intersectSphere(f,v){q.subVectors(f.center,this.origin);let e=q.dot(this.direction),s=q.dot(q)-e*e,t=f.radius*f.radius;if(s>t)return null;let i=Math.sqrt(t-s),n=e-i,r=e+i;return n<0&&r<0?null:n<0?this.at(r,v):this.at(n,v)}intersectsSphere(f){return this.distanceSqToPoint(f.center)<=f.radius*f.radius}distanceToPlane(f){let v=f.normal.dot(this.direction);if(0===v)return 0===f.distanceToPoint(this.origin)?0:null;let e=-(this.origin.dot(f.normal)+f.constant)/v;return e>=0?e:null}intersectPlane(f,v){let e=this.distanceToPlane(f);return null===e?null:this.at(e,v)}intersectsPlane(f){let v=f.distanceToPoint(this.origin);return!!(0===v||f.normal.dot(this.direction)*v<0)}intersectBox(f,v){let e,s,t,i,n,r;let o=1/this.direction.x,a=1/this.direction.y,l=1/this.direction.z,c=this.origin;return(o>=0?(e=(f.min.x-c.x)*o,s=(f.max.x-c.x)*o):(e=(f.max.x-c.x)*o,s=(f.min.x-c.x)*o),a>=0?(t=(f.min.y-c.y)*a,i=(f.max.y-c.y)*a):(t=(f.max.y-c.y)*a,i=(f.min.y-c.y)*a),e>i||t>s)?null:((t>e||e!=e)&&(e=t),(i<s||s!=s)&&(s=i),l>=0?(n=(f.min.z-c.z)*l,r=(f.max.z-c.z)*l):(n=(f.max.z-c.z)*l,r=(f.min.z-c.z)*l),e>r||n>s)?null:((n>e||e!=e)&&(e=n),(r<s||s!=s)&&(s=r),s<0)?null:this.at(e>=0?e:s,v)}intersectsBox(f){return null!==this.intersectBox(f,q)}intersectTriangle(f,v,e,s,t){let i;J.subVectors(v,f),$.subVectors(e,f),Q.crossVectors(J,$);let n=this.direction.dot(Q);if(n>0){if(s)return null;i=1}else{if(!(n<0))return null;i=-1,n=-n}Z.subVectors(this.origin,f);let r=i*this.direction.dot($.crossVectors(Z,$));if(r<0)return null;let o=i*this.direction.dot(J.cross(Z));if(o<0||r+o>n)return null;let a=-i*Z.dot(Q);return a<0?null:this.at(a/n,t)}applyMatrix4(f){return this.origin.applyMatrix4(f),this.direction.transformDirection(f),this}equals(f){return f.origin.equals(this.origin)&&f.direction.equals(this.direction)}}class ff{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(f,v,e,s,t,i,n,r,o,a,l,c,h,u,d,p){let m=this.elements;return m[0]=f,m[4]=v,m[8]=e,m[12]=s,m[1]=t,m[5]=i,m[9]=n,m[13]=r,m[2]=o,m[6]=a,m[10]=l,m[14]=c,m[3]=h,m[7]=u,m[11]=d,m[15]=p,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ff().fromArray(this.elements)}copy(f){let v=this.elements,e=f.elements;return v[0]=e[0],v[1]=e[1],v[2]=e[2],v[3]=e[3],v[4]=e[4],v[5]=e[5],v[6]=e[6],v[7]=e[7],v[8]=e[8],v[9]=e[9],v[10]=e[10],v[11]=e[11],v[12]=e[12],v[13]=e[13],v[14]=e[14],v[15]=e[15],this}copyPosition(f){let v=this.elements,e=f.elements;return v[12]=e[12],v[13]=e[13],v[14]=e[14],this}setFromMatrix3(f){let v=f.elements;return this.set(v[0],v[3],v[6],0,v[1],v[4],v[7],0,v[2],v[5],v[8],0,0,0,0,1),this}extractBasis(f,v,e){return f.setFromMatrixColumn(this,0),v.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(f,v,e){return this.set(f.x,v.x,e.x,0,f.y,v.y,e.y,0,f.z,v.z,e.z,0,0,0,0,1),this}extractRotation(f){let v=this.elements,e=f.elements,s=1/fv.setFromMatrixColumn(f,0).length(),t=1/fv.setFromMatrixColumn(f,1).length(),i=1/fv.setFromMatrixColumn(f,2).length();return v[0]=e[0]*s,v[1]=e[1]*s,v[2]=e[2]*s,v[3]=0,v[4]=e[4]*t,v[5]=e[5]*t,v[6]=e[6]*t,v[7]=0,v[8]=e[8]*i,v[9]=e[9]*i,v[10]=e[10]*i,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,this}makeRotationFromEuler(f){f&&f.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");let v=this.elements,e=f.x,s=f.y,t=f.z,i=Math.cos(e),n=Math.sin(e),r=Math.cos(s),o=Math.sin(s),a=Math.cos(t),l=Math.sin(t);if("XYZ"===f.order){let f=i*a,e=i*l,s=n*a,t=n*l;v[0]=r*a,v[4]=-r*l,v[8]=o,v[1]=e+s*o,v[5]=f-t*o,v[9]=-n*r,v[2]=t-f*o,v[6]=s+e*o,v[10]=i*r}else if("YXZ"===f.order){let f=r*a,e=r*l,s=o*a,t=o*l;v[0]=f+t*n,v[4]=s*n-e,v[8]=i*o,v[1]=i*l,v[5]=i*a,v[9]=-n,v[2]=e*n-s,v[6]=t+f*n,v[10]=i*r}else if("ZXY"===f.order){let f=r*a,e=r*l,s=o*a,t=o*l;v[0]=f-t*n,v[4]=-i*l,v[8]=s+e*n,v[1]=e+s*n,v[5]=i*a,v[9]=t-f*n,v[2]=-i*o,v[6]=n,v[10]=i*r}else if("ZYX"===f.order){let f=i*a,e=i*l,s=n*a,t=n*l;v[0]=r*a,v[4]=s*o-e,v[8]=f*o+t,v[1]=r*l,v[5]=t*o+f,v[9]=e*o-s,v[2]=-o,v[6]=n*r,v[10]=i*r}else if("YZX"===f.order){let f=i*r,e=i*o,s=n*r,t=n*o;v[0]=r*a,v[4]=t-f*l,v[8]=s*l+e,v[1]=l,v[5]=i*a,v[9]=-n*a,v[2]=-o*a,v[6]=e*l+s,v[10]=f-t*l}else if("XZY"===f.order){let f=i*r,e=i*o,s=n*r,t=n*o;v[0]=r*a,v[4]=-l,v[8]=o*a,v[1]=f*l+t,v[5]=i*a,v[9]=e*l-s,v[2]=s*l-e,v[6]=n*a,v[10]=t*l+f}return v[3]=0,v[7]=0,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,this}makeRotationFromQuaternion(f){return this.compose(fs,f,ft)}lookAt(f,v,e){let s=this.elements;return fr.subVectors(f,v),0===fr.lengthSq()&&(fr.z=1),fr.normalize(),fi.crossVectors(e,fr),0===fi.lengthSq()&&(1===Math.abs(e.z)?fr.x+=1e-4:fr.z+=1e-4,fr.normalize(),fi.crossVectors(e,fr)),fi.normalize(),fn.crossVectors(fr,fi),s[0]=fi.x,s[4]=fn.x,s[8]=fr.x,s[1]=fi.y,s[5]=fn.y,s[9]=fr.y,s[2]=fi.z,s[6]=fn.z,s[10]=fr.z,this}multiply(f,v){return void 0!==v?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(f,v)):this.multiplyMatrices(this,f)}premultiply(f){return this.multiplyMatrices(f,this)}multiplyMatrices(f,v){let e=f.elements,s=v.elements,t=this.elements,i=e[0],n=e[4],r=e[8],o=e[12],a=e[1],l=e[5],c=e[9],h=e[13],u=e[2],d=e[6],p=e[10],m=e[14],g=e[3],y=e[7],x=e[11],b=e[15],_=s[0],w=s[4],M=s[8],S=s[12],E=s[1],T=s[5],L=s[9],A=s[13],R=s[2],C=s[6],P=s[10],O=s[14],D=s[3],I=s[7],N=s[11],z=s[15];return t[0]=i*_+n*E+r*R+o*D,t[4]=i*w+n*T+r*C+o*I,t[8]=i*M+n*L+r*P+o*N,t[12]=i*S+n*A+r*O+o*z,t[1]=a*_+l*E+c*R+h*D,t[5]=a*w+l*T+c*C+h*I,t[9]=a*M+l*L+c*P+h*N,t[13]=a*S+l*A+c*O+h*z,t[2]=u*_+d*E+p*R+m*D,t[6]=u*w+d*T+p*C+m*I,t[10]=u*M+d*L+p*P+m*N,t[14]=u*S+d*A+p*O+m*z,t[3]=g*_+y*E+x*R+b*D,t[7]=g*w+y*T+x*C+b*I,t[11]=g*M+y*L+x*P+b*N,t[15]=g*S+y*A+x*O+b*z,this}multiplyScalar(f){let v=this.elements;return v[0]*=f,v[4]*=f,v[8]*=f,v[12]*=f,v[1]*=f,v[5]*=f,v[9]*=f,v[13]*=f,v[2]*=f,v[6]*=f,v[10]*=f,v[14]*=f,v[3]*=f,v[7]*=f,v[11]*=f,v[15]*=f,this}determinant(){let f=this.elements,v=f[0],e=f[4],s=f[8],t=f[12],i=f[1],n=f[5],r=f[9],o=f[13],a=f[2],l=f[6],c=f[10],h=f[14],u=f[3];return u*(+t*r*l-s*o*l-t*n*c+e*o*c+s*n*h-e*r*h)+f[7]*(+v*r*h-v*o*c+t*i*c-s*i*h+s*o*a-t*r*a)+f[11]*(+v*o*l-v*n*h-t*i*l+e*i*h+t*n*a-e*o*a)+f[15]*(-s*n*a-v*r*l+v*n*c+s*i*l-e*i*c+e*r*a)}transpose(){let f;let v=this.elements;return f=v[1],v[1]=v[4],v[4]=f,f=v[2],v[2]=v[8],v[8]=f,f=v[6],v[6]=v[9],v[9]=f,f=v[3],v[3]=v[12],v[12]=f,f=v[7],v[7]=v[13],v[13]=f,f=v[11],v[11]=v[14],v[14]=f,this}setPosition(f,v,e){let s=this.elements;return f.isVector3?(s[12]=f.x,s[13]=f.y,s[14]=f.z):(s[12]=f,s[13]=v,s[14]=e),this}invert(){let f=this.elements,v=f[0],e=f[1],s=f[2],t=f[3],i=f[4],n=f[5],r=f[6],o=f[7],a=f[8],l=f[9],c=f[10],h=f[11],u=f[12],d=f[13],p=f[14],m=f[15],g=l*p*o-d*c*o+d*r*h-n*p*h-l*r*m+n*c*m,y=u*c*o-a*p*o-u*r*h+i*p*h+a*r*m-i*c*m,x=a*d*o-u*l*o+u*n*h-i*d*h-a*n*m+i*l*m,b=u*l*r-a*d*r-u*n*c+i*d*c+a*n*p-i*l*p,_=v*g+e*y+s*x+t*b;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let w=1/_;return f[0]=g*w,f[1]=(d*c*t-l*p*t-d*s*h+e*p*h+l*s*m-e*c*m)*w,f[2]=(n*p*t-d*r*t+d*s*o-e*p*o-n*s*m+e*r*m)*w,f[3]=(l*r*t-n*c*t-l*s*o+e*c*o+n*s*h-e*r*h)*w,f[4]=y*w,f[5]=(a*p*t-u*c*t+u*s*h-v*p*h-a*s*m+v*c*m)*w,f[6]=(u*r*t-i*p*t-u*s*o+v*p*o+i*s*m-v*r*m)*w,f[7]=(i*c*t-a*r*t+a*s*o-v*c*o-i*s*h+v*r*h)*w,f[8]=x*w,f[9]=(u*l*t-a*d*t-u*e*h+v*d*h+a*e*m-v*l*m)*w,f[10]=(i*d*t-u*n*t+u*e*o-v*d*o-i*e*m+v*n*m)*w,f[11]=(a*n*t-i*l*t-a*e*o+v*l*o+i*e*h-v*n*h)*w,f[12]=b*w,f[13]=(a*d*s-u*l*s+u*e*c-v*d*c-a*e*p+v*l*p)*w,f[14]=(u*n*s-i*d*s-u*e*r+v*d*r+i*e*p-v*n*p)*w,f[15]=(i*l*s-a*n*s+a*e*r-v*l*r-i*e*c+v*n*c)*w,this}scale(f){let v=this.elements,e=f.x,s=f.y,t=f.z;return v[0]*=e,v[4]*=s,v[8]*=t,v[1]*=e,v[5]*=s,v[9]*=t,v[2]*=e,v[6]*=s,v[10]*=t,v[3]*=e,v[7]*=s,v[11]*=t,this}getMaxScaleOnAxis(){let f=this.elements;return Math.sqrt(Math.max(f[0]*f[0]+f[1]*f[1]+f[2]*f[2],f[4]*f[4]+f[5]*f[5]+f[6]*f[6],f[8]*f[8]+f[9]*f[9]+f[10]*f[10]))}makeTranslation(f,v,e){return this.set(1,0,0,f,0,1,0,v,0,0,1,e,0,0,0,1),this}makeRotationX(f){let v=Math.cos(f),e=Math.sin(f);return this.set(1,0,0,0,0,v,-e,0,0,e,v,0,0,0,0,1),this}makeRotationY(f){let v=Math.cos(f),e=Math.sin(f);return this.set(v,0,e,0,0,1,0,0,-e,0,v,0,0,0,0,1),this}makeRotationZ(f){let v=Math.cos(f),e=Math.sin(f);return this.set(v,-e,0,0,e,v,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(f,v){let e=Math.cos(v),s=Math.sin(v),t=1-e,i=f.x,n=f.y,r=f.z,o=t*i,a=t*n;return this.set(o*i+e,o*n-s*r,o*r+s*n,0,o*n+s*r,a*n+e,a*r-s*i,0,o*r-s*n,a*r+s*i,t*r*r+e,0,0,0,0,1),this}makeScale(f,v,e){return this.set(f,0,0,0,0,v,0,0,0,0,e,0,0,0,0,1),this}makeShear(f,v,e){return this.set(1,v,e,0,f,1,e,0,f,v,1,0,0,0,0,1),this}compose(f,v,e){let s=this.elements,t=v._x,i=v._y,n=v._z,r=v._w,o=t+t,a=i+i,l=n+n,c=t*o,h=t*a,u=t*l,d=i*a,p=i*l,m=n*l,g=r*o,y=r*a,x=r*l,b=e.x,_=e.y,w=e.z;return s[0]=(1-(d+m))*b,s[1]=(h+x)*b,s[2]=(u-y)*b,s[3]=0,s[4]=(h-x)*_,s[5]=(1-(c+m))*_,s[6]=(p+g)*_,s[7]=0,s[8]=(u+y)*w,s[9]=(p-g)*w,s[10]=(1-(c+d))*w,s[11]=0,s[12]=f.x,s[13]=f.y,s[14]=f.z,s[15]=1,this}decompose(f,v,e){let s=this.elements,t=fv.set(s[0],s[1],s[2]).length(),i=fv.set(s[4],s[5],s[6]).length(),n=fv.set(s[8],s[9],s[10]).length();0>this.determinant()&&(t=-t),f.x=s[12],f.y=s[13],f.z=s[14],fe.copy(this);let r=1/t,o=1/i,a=1/n;return fe.elements[0]*=r,fe.elements[1]*=r,fe.elements[2]*=r,fe.elements[4]*=o,fe.elements[5]*=o,fe.elements[6]*=o,fe.elements[8]*=a,fe.elements[9]*=a,fe.elements[10]*=a,v.setFromRotationMatrix(fe),e.x=t,e.y=i,e.z=n,this}makePerspective(f,v,e,s,t,i){void 0===i&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");let n=this.elements;return n[0]=2*t/(v-f),n[4]=0,n[8]=(v+f)/(v-f),n[12]=0,n[1]=0,n[5]=2*t/(e-s),n[9]=(e+s)/(e-s),n[13]=0,n[2]=0,n[6]=0,n[10]=-(i+t)/(i-t),n[14]=-2*i*t/(i-t),n[3]=0,n[7]=0,n[11]=-1,n[15]=0,this}makeOrthographic(f,v,e,s,t,i){let n=this.elements,r=1/(v-f),o=1/(e-s),a=1/(i-t);return n[0]=2*r,n[4]=0,n[8]=0,n[12]=-((v+f)*r),n[1]=0,n[5]=2*o,n[9]=0,n[13]=-((e+s)*o),n[2]=0,n[6]=0,n[10]=-2*a,n[14]=-((i+t)*a),n[3]=0,n[7]=0,n[11]=0,n[15]=1,this}equals(f){let v=this.elements,e=f.elements;for(let f=0;f<16;f++)if(v[f]!==e[f])return!1;return!0}fromArray(f,v=0){for(let e=0;e<16;e++)this.elements[e]=f[e+v];return this}toArray(f=[],v=0){let e=this.elements;return f[v]=e[0],f[v+1]=e[1],f[v+2]=e[2],f[v+3]=e[3],f[v+4]=e[4],f[v+5]=e[5],f[v+6]=e[6],f[v+7]=e[7],f[v+8]=e[8],f[v+9]=e[9],f[v+10]=e[10],f[v+11]=e[11],f[v+12]=e[12],f[v+13]=e[13],f[v+14]=e[14],f[v+15]=e[15],f}}let fv=/*@__PURE__*/new T,fe=/*@__PURE__*/new ff,fs=/*@__PURE__*/new T(0,0,0),ft=/*@__PURE__*/new T(1,1,1),fi=/*@__PURE__*/new T,fn=/*@__PURE__*/new T,fr=/*@__PURE__*/new T;class fo{constructor(f=0,v=0,e=0,s=fo.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=f,this._y=v,this._z=e,this._order=s}get x(){return this._x}set x(f){this._x=f,this._onChangeCallback()}get y(){return this._y}set y(f){this._y=f,this._onChangeCallback()}get z(){return this._z}set z(f){this._z=f,this._onChangeCallback()}get order(){return this._order}set order(f){this._order=f,this._onChangeCallback()}set(f,v,e,s){return this._x=f,this._y=v,this._z=e,this._order=s||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(f){return this._x=f._x,this._y=f._y,this._z=f._z,this._order=f._order,this._onChangeCallback(),this}setFromRotationMatrix(f,v,e){let s=m.clamp,t=f.elements,i=t[0],n=t[4],r=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],u=t[10];switch(v=v||this._order){case"XYZ":this._y=Math.asin(s(r,-1,1)),.9999999>Math.abs(r)?(this._x=Math.atan2(-l,u),this._z=Math.atan2(-n,i)):(this._x=Math.atan2(h,a),this._z=0);break;case"YXZ":this._x=Math.asin(-s(l,-1,1)),.9999999>Math.abs(l)?(this._y=Math.atan2(r,u),this._z=Math.atan2(o,a)):(this._y=Math.atan2(-c,i),this._z=0);break;case"ZXY":this._x=Math.asin(s(h,-1,1)),.9999999>Math.abs(h)?(this._y=Math.atan2(-c,u),this._z=Math.atan2(-n,a)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-s(c,-1,1)),.9999999>Math.abs(c)?(this._x=Math.atan2(h,u),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-n,a));break;case"YZX":this._z=Math.asin(s(o,-1,1)),.9999999>Math.abs(o)?(this._x=Math.atan2(-l,a),this._y=Math.atan2(-c,i)):(this._x=0,this._y=Math.atan2(r,u));break;case"XZY":this._z=Math.asin(-s(n,-1,1)),.9999999>Math.abs(n)?(this._x=Math.atan2(h,a),this._y=Math.atan2(r,i)):(this._x=Math.atan2(-l,u),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+v)}return this._order=v,!1!==e&&this._onChangeCallback(),this}setFromQuaternion(f,v,e){return fa.makeRotationFromQuaternion(f),this.setFromRotationMatrix(fa,v,e)}setFromVector3(f,v){return this.set(f.x,f.y,f.z,v||this._order)}reorder(f){return fl.setFromEuler(this),this.setFromQuaternion(fl,f)}equals(f){return f._x===this._x&&f._y===this._y&&f._z===this._z&&f._order===this._order}fromArray(f){return this._x=f[0],this._y=f[1],this._z=f[2],void 0!==f[3]&&(this._order=f[3]),this._onChangeCallback(),this}toArray(f=[],v=0){return f[v]=this._x,f[v+1]=this._y,f[v+2]=this._z,f[v+3]=this._order,f}toVector3(f){return f?f.set(this._x,this._y,this._z):new T(this._x,this._y,this._z)}_onChange(f){return this._onChangeCallback=f,this}_onChangeCallback(){}}fo.DefaultOrder="XYZ",fo.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];let fa=/*@__PURE__*/new ff,fl=/*@__PURE__*/new E;class fc{constructor(){this.mask=1}set(f){this.mask=1<<f|0}enable(f){this.mask|=1<<f|0}enableAll(){this.mask=-1}toggle(f){this.mask^=1<<f|0}disable(f){this.mask&=~(1<<f|0)}disableAll(){this.mask=0}test(f){return(this.mask&f.mask)!=0}}let fh=0,fu=new T,fd=new E,fp=new ff,fm=new T,fg=new T,fy=new T,fx=new E,fb=new T(1,0,0),f_=new T(0,1,0),fw=new T(0,0,1),fM={type:"added"},fS={type:"removed"};function fE(){Object.defineProperty(this,"id",{value:fh++}),this.uuid=m.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=fE.DefaultUp.clone();let f=new T,v=new fo,e=new E,s=new T(1,1,1);v._onChange(function(){e.setFromEuler(v,!1)}),e._onChange(function(){v.setFromQuaternion(e,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:f},rotation:{configurable:!0,enumerable:!0,value:v},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new ff},normalMatrix:{value:new y}}),this.matrix=new ff,this.matrixWorld=new ff,this.matrixAutoUpdate=fE.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new fc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}fE.DefaultUp=new T(0,1,0),fE.DefaultMatrixAutoUpdate=!0,fE.prototype=Object.assign(Object.create(u.prototype),{constructor:fE,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(f){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(f),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(f){return this.quaternion.premultiply(f),this},setRotationFromAxisAngle:function(f,v){this.quaternion.setFromAxisAngle(f,v)},setRotationFromEuler:function(f){this.quaternion.setFromEuler(f,!0)},setRotationFromMatrix:function(f){this.quaternion.setFromRotationMatrix(f)},setRotationFromQuaternion:function(f){this.quaternion.copy(f)},rotateOnAxis:function(f,v){return fd.setFromAxisAngle(f,v),this.quaternion.multiply(fd),this},rotateOnWorldAxis:function(f,v){return fd.setFromAxisAngle(f,v),this.quaternion.premultiply(fd),this},rotateX:function(f){return this.rotateOnAxis(fb,f)},rotateY:function(f){return this.rotateOnAxis(f_,f)},rotateZ:function(f){return this.rotateOnAxis(fw,f)},translateOnAxis:function(f,v){return fu.copy(f).applyQuaternion(this.quaternion),this.position.add(fu.multiplyScalar(v)),this},translateX:function(f){return this.translateOnAxis(fb,f)},translateY:function(f){return this.translateOnAxis(f_,f)},translateZ:function(f){return this.translateOnAxis(fw,f)},localToWorld:function(f){return f.applyMatrix4(this.matrixWorld)},worldToLocal:function(f){return f.applyMatrix4(fp.copy(this.matrixWorld).invert())},lookAt:function(f,v,e){f.isVector3?fm.copy(f):fm.set(f,v,e);let s=this.parent;this.updateWorldMatrix(!0,!1),fg.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?fp.lookAt(fg,fm,this.up):fp.lookAt(fm,fg,this.up),this.quaternion.setFromRotationMatrix(fp),s&&(fp.extractRotation(s.matrixWorld),fd.setFromRotationMatrix(fp),this.quaternion.premultiply(fd.invert()))},add:function(f){if(arguments.length>1){for(let f=0;f<arguments.length;f++)this.add(arguments[f]);return this}return f===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",f):f&&f.isObject3D?(null!==f.parent&&f.parent.remove(f),f.parent=this,this.children.push(f),f.dispatchEvent(fM)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",f),this},remove:function(f){if(arguments.length>1){for(let f=0;f<arguments.length;f++)this.remove(arguments[f]);return this}let v=this.children.indexOf(f);return -1!==v&&(f.parent=null,this.children.splice(v,1),f.dispatchEvent(fS)),this},clear:function(){for(let f=0;f<this.children.length;f++){let v=this.children[f];v.parent=null,v.dispatchEvent(fS)}return this.children.length=0,this},attach:function(f){return this.updateWorldMatrix(!0,!1),fp.copy(this.matrixWorld).invert(),null!==f.parent&&(f.parent.updateWorldMatrix(!0,!1),fp.multiply(f.parent.matrixWorld)),f.applyMatrix4(fp),f.updateWorldMatrix(!1,!1),this.add(f),this},getObjectById:function(f){return this.getObjectByProperty("id",f)},getObjectByName:function(f){return this.getObjectByProperty("name",f)},getObjectByProperty:function(f,v){if(this[f]===v)return this;for(let e=0,s=this.children.length;e<s;e++){let s=this.children[e].getObjectByProperty(f,v);if(void 0!==s)return s}},getWorldPosition:function(f){return void 0===f&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),f=new T),this.updateWorldMatrix(!0,!1),f.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(f){return void 0===f&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),f=new E),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fg,f,fy),f},getWorldScale:function(f){return void 0===f&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),f=new T),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fg,fx,f),f},getWorldDirection:function(f){void 0===f&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),f=new T),this.updateWorldMatrix(!0,!1);let v=this.matrixWorld.elements;return f.set(v[8],v[9],v[10]).normalize()},raycast:function(){},traverse:function(f){f(this);let v=this.children;for(let e=0,s=v.length;e<s;e++)v[e].traverse(f)},traverseVisible:function(f){if(!1===this.visible)return;f(this);let v=this.children;for(let e=0,s=v.length;e<s;e++)v[e].traverseVisible(f)},traverseAncestors:function(f){let v=this.parent;null!==v&&(f(v),v.traverseAncestors(f))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(f){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||f)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,f=!0);let v=this.children;for(let e=0,s=v.length;e<s;e++)v[e].updateMatrixWorld(f)},updateWorldMatrix:function(f,v){let e=this.parent;if(!0===f&&null!==e&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===v){let f=this.children;for(let v=0,e=f.length;v<e;v++)f[v].updateWorldMatrix(!1,!0)}},toJSON:function(f){let v=void 0===f||"string"==typeof f,e={};v&&(f={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});let s={};function t(v,e){return void 0===v[e.uuid]&&(v[e.uuid]=e.toJSON(f)),e.uuid}if(s.uuid=this.uuid,s.type=this.type,""!==this.name&&(s.name=this.name),!0===this.castShadow&&(s.castShadow=!0),!0===this.receiveShadow&&(s.receiveShadow=!0),!1===this.visible&&(s.visible=!1),!1===this.frustumCulled&&(s.frustumCulled=!1),0!==this.renderOrder&&(s.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){s.geometry=t(f.geometries,this.geometry);let v=this.geometry.parameters;if(void 0!==v&&void 0!==v.shapes){let e=v.shapes;if(Array.isArray(e))for(let v=0,s=e.length;v<s;v++){let s=e[v];t(f.shapes,s)}else t(f.shapes,e)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(t(f.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),void 0!==this.material){if(Array.isArray(this.material)){let v=[];for(let e=0,s=this.material.length;e<s;e++)v.push(t(f.materials,this.material[e]));s.material=v}else s.material=t(f.materials,this.material)}if(this.children.length>0){s.children=[];for(let v=0;v<this.children.length;v++)s.children.push(this.children[v].toJSON(f).object)}if(this.animations.length>0){s.animations=[];for(let v=0;v<this.animations.length;v++){let e=this.animations[v];s.animations.push(t(f.animations,e))}}if(v){let v=i(f.geometries),s=i(f.materials),t=i(f.textures),n=i(f.images),r=i(f.shapes),o=i(f.skeletons),a=i(f.animations);v.length>0&&(e.geometries=v),s.length>0&&(e.materials=s),t.length>0&&(e.textures=t),n.length>0&&(e.images=n),r.length>0&&(e.shapes=r),o.length>0&&(e.skeletons=o),a.length>0&&(e.animations=a)}return e.object=s,e;function i(f){let v=[];for(let e in f){let s=f[e];delete s.metadata,v.push(s)}return v}},clone:function(f){return new this.constructor().copy(this,f)},copy:function(f,v=!0){if(this.name=f.name,this.up.copy(f.up),this.position.copy(f.position),this.rotation.order=f.rotation.order,this.quaternion.copy(f.quaternion),this.scale.copy(f.scale),this.matrix.copy(f.matrix),this.matrixWorld.copy(f.matrixWorld),this.matrixAutoUpdate=f.matrixAutoUpdate,this.matrixWorldNeedsUpdate=f.matrixWorldNeedsUpdate,this.layers.mask=f.layers.mask,this.visible=f.visible,this.castShadow=f.castShadow,this.receiveShadow=f.receiveShadow,this.frustumCulled=f.frustumCulled,this.renderOrder=f.renderOrder,this.userData=JSON.parse(JSON.stringify(f.userData)),!0===v)for(let v=0;v<f.children.length;v++){let e=f.children[v];this.add(e.clone())}return this}});let fT=/*@__PURE__*/new T,fL=/*@__PURE__*/new T,fA=/*@__PURE__*/new y;class fR{constructor(f,v){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==f?f:new T(1,0,0),this.constant=void 0!==v?v:0}set(f,v){return this.normal.copy(f),this.constant=v,this}setComponents(f,v,e,s){return this.normal.set(f,v,e),this.constant=s,this}setFromNormalAndCoplanarPoint(f,v){return this.normal.copy(f),this.constant=-v.dot(this.normal),this}setFromCoplanarPoints(f,v,e){let s=fT.subVectors(e,v).cross(fL.subVectors(f,v)).normalize();return this.setFromNormalAndCoplanarPoint(s,f),this}clone(){return new this.constructor().copy(this)}copy(f){return this.normal.copy(f.normal),this.constant=f.constant,this}normalize(){let f=1/this.normal.length();return this.normal.multiplyScalar(f),this.constant*=f,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(f){return this.normal.dot(f)+this.constant}distanceToSphere(f){return this.distanceToPoint(f.center)-f.radius}projectPoint(f,v){return void 0===v&&(console.warn("THREE.Plane: .projectPoint() target is now required"),v=new T),v.copy(this.normal).multiplyScalar(-this.distanceToPoint(f)).add(f)}intersectLine(f,v){void 0===v&&(console.warn("THREE.Plane: .intersectLine() target is now required"),v=new T);let e=f.delta(fT),s=this.normal.dot(e);if(0===s)return 0===this.distanceToPoint(f.start)?v.copy(f.start):void 0;let t=-(f.start.dot(this.normal)+this.constant)/s;if(!(t<0)&&!(t>1))return v.copy(e).multiplyScalar(t).add(f.start)}intersectsLine(f){let v=this.distanceToPoint(f.start),e=this.distanceToPoint(f.end);return v<0&&e>0||e<0&&v>0}intersectsBox(f){return f.intersectsPlane(this)}intersectsSphere(f){return f.intersectsPlane(this)}coplanarPoint(f){return void 0===f&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),f=new T),f.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(f,v){let e=v||fA.getNormalMatrix(f),s=this.coplanarPoint(fT).applyMatrix4(f),t=this.normal.applyMatrix3(e).normalize();return this.constant=-s.dot(t),this}translate(f){return this.constant-=f.dot(this.normal),this}equals(f){return f.normal.equals(this.normal)&&f.constant===this.constant}}let fC=/*@__PURE__*/new T,fP=/*@__PURE__*/new T,fO=/*@__PURE__*/new T,fD=/*@__PURE__*/new T,fI=/*@__PURE__*/new T,fN=/*@__PURE__*/new T,fz=/*@__PURE__*/new T,fH=/*@__PURE__*/new T,fF=/*@__PURE__*/new T,fB=/*@__PURE__*/new T;class fU{constructor(f,v,e){this.a=void 0!==f?f:new T,this.b=void 0!==v?v:new T,this.c=void 0!==e?e:new T}static getNormal(f,v,e,s){void 0===s&&(console.warn("THREE.Triangle: .getNormal() target is now required"),s=new T),s.subVectors(e,v),fC.subVectors(f,v),s.cross(fC);let t=s.lengthSq();return t>0?s.multiplyScalar(1/Math.sqrt(t)):s.set(0,0,0)}static getBarycoord(f,v,e,s,t){fC.subVectors(s,v),fP.subVectors(e,v),fO.subVectors(f,v);let i=fC.dot(fC),n=fC.dot(fP),r=fC.dot(fO),o=fP.dot(fP),a=fP.dot(fO),l=i*o-n*n;if(void 0===t&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),t=new T),0===l)return t.set(-2,-1,-1);let c=1/l,h=(o*r-n*a)*c,u=(i*a-n*r)*c;return t.set(1-h-u,u,h)}static containsPoint(f,v,e,s){return this.getBarycoord(f,v,e,s,fD),fD.x>=0&&fD.y>=0&&fD.x+fD.y<=1}static getUV(f,v,e,s,t,i,n,r){return this.getBarycoord(f,v,e,s,fD),r.set(0,0),r.addScaledVector(t,fD.x),r.addScaledVector(i,fD.y),r.addScaledVector(n,fD.z),r}static isFrontFacing(f,v,e,s){return fC.subVectors(e,v),fP.subVectors(f,v),0>fC.cross(fP).dot(s)}set(f,v,e){return this.a.copy(f),this.b.copy(v),this.c.copy(e),this}setFromPointsAndIndices(f,v,e,s){return this.a.copy(f[v]),this.b.copy(f[e]),this.c.copy(f[s]),this}clone(){return new this.constructor().copy(this)}copy(f){return this.a.copy(f.a),this.b.copy(f.b),this.c.copy(f.c),this}getArea(){return fC.subVectors(this.c,this.b),fP.subVectors(this.a,this.b),.5*fC.cross(fP).length()}getMidpoint(f){return void 0===f&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),f=new T),f.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(f){return fU.getNormal(this.a,this.b,this.c,f)}getPlane(f){return void 0===f&&(console.warn("THREE.Triangle: .getPlane() target is now required"),f=new fR),f.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(f,v){return fU.getBarycoord(f,this.a,this.b,this.c,v)}getUV(f,v,e,s,t){return fU.getUV(f,this.a,this.b,this.c,v,e,s,t)}containsPoint(f){return fU.containsPoint(f,this.a,this.b,this.c)}isFrontFacing(f){return fU.isFrontFacing(this.a,this.b,this.c,f)}intersectsBox(f){return f.intersectsTriangle(this)}closestPointToPoint(f,v){let e,s;void 0===v&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),v=new T);let t=this.a,i=this.b,n=this.c;fI.subVectors(i,t),fN.subVectors(n,t),fH.subVectors(f,t);let r=fI.dot(fH),o=fN.dot(fH);if(r<=0&&o<=0)return v.copy(t);fF.subVectors(f,i);let a=fI.dot(fF),l=fN.dot(fF);if(a>=0&&l<=a)return v.copy(i);let c=r*l-a*o;if(c<=0&&r>=0&&a<=0)return e=r/(r-a),v.copy(t).addScaledVector(fI,e);fB.subVectors(f,n);let h=fI.dot(fB),u=fN.dot(fB);if(u>=0&&h<=u)return v.copy(n);let d=h*o-r*u;if(d<=0&&o>=0&&u<=0)return s=o/(o-u),v.copy(t).addScaledVector(fN,s);let p=a*u-h*l;if(p<=0&&l-a>=0&&h-u>=0)return fz.subVectors(n,i),s=(l-a)/(l-a+(h-u)),v.copy(i).addScaledVector(fz,s);let m=1/(p+d+c);return e=d*m,s=c*m,v.copy(t).addScaledVector(fI,e).addScaledVector(fN,s)}equals(f){return f.a.equals(this.a)&&f.b.equals(this.b)&&f.c.equals(this.c)}}let fk={aliceblue:0xf0f8ff,antiquewhite:0xfaebd7,aqua:65535,aquamarine:8388564,azure:0xf0ffff,beige:0xf5f5dc,bisque:0xffe4c4,black:0,blanchedalmond:0xffebcd,blue:255,blueviolet:9055202,brown:0xa52a2a,burlywood:0xdeb887,cadetblue:6266528,chartreuse:8388352,chocolate:0xd2691e,coral:0xff7f50,cornflowerblue:6591981,cornsilk:0xfff8dc,crimson:0xdc143c,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:0xb8860b,darkgray:0xa9a9a9,darkgreen:25600,darkgrey:0xa9a9a9,darkkhaki:0xbdb76b,darkmagenta:9109643,darkolivegreen:5597999,darkorange:0xff8c00,darkorchid:0x9932cc,darkred:9109504,darksalmon:0xe9967a,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:0xff1493,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:0xb22222,floralwhite:0xfffaf0,forestgreen:2263842,fuchsia:0xff00ff,gainsboro:0xdcdcdc,ghostwhite:0xf8f8ff,gold:0xffd700,goldenrod:0xdaa520,gray:8421504,green:32768,greenyellow:0xadff2f,grey:8421504,honeydew:0xf0fff0,hotpink:0xff69b4,indianred:0xcd5c5c,indigo:4915330,ivory:0xfffff0,khaki:0xf0e68c,lavender:0xe6e6fa,lavenderblush:0xfff0f5,lawngreen:8190976,lemonchiffon:0xfffacd,lightblue:0xadd8e6,lightcoral:0xf08080,lightcyan:0xe0ffff,lightgoldenrodyellow:0xfafad2,lightgray:0xd3d3d3,lightgreen:9498256,lightgrey:0xd3d3d3,lightpink:0xffb6c1,lightsalmon:0xffa07a,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:0xb0c4de,lightyellow:0xffffe0,lime:65280,limegreen:3329330,linen:0xfaf0e6,magenta:0xff00ff,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:0xba55d3,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:0xc71585,midnightblue:1644912,mintcream:0xf5fffa,mistyrose:0xffe4e1,moccasin:0xffe4b5,navajowhite:0xffdead,navy:128,oldlace:0xfdf5e6,olive:8421376,olivedrab:7048739,orange:0xffa500,orangered:0xff4500,orchid:0xda70d6,palegoldenrod:0xeee8aa,palegreen:0x98fb98,paleturquoise:0xafeeee,palevioletred:0xdb7093,papayawhip:0xffefd5,peachpuff:0xffdab9,peru:0xcd853f,pink:0xffc0cb,plum:0xdda0dd,powderblue:0xb0e0e6,purple:8388736,rebeccapurple:6697881,red:0xff0000,rosybrown:0xbc8f8f,royalblue:4286945,saddlebrown:9127187,salmon:0xfa8072,sandybrown:0xf4a460,seagreen:3050327,seashell:0xfff5ee,sienna:0xa0522d,silver:0xc0c0c0,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:0xfffafa,springgreen:65407,steelblue:4620980,tan:0xd2b48c,teal:32896,thistle:0xd8bfd8,tomato:0xff6347,turquoise:4251856,violet:0xee82ee,wheat:0xf5deb3,white:0xffffff,whitesmoke:0xf5f5f5,yellow:0xffff00,yellowgreen:0x9acd32},fG={h:0,s:0,l:0},fj={h:0,s:0,l:0};function fV(f,v,e){return(e<0&&(e+=1),e>1&&(e-=1),e<1/6)?f+(v-f)*6*e:e<.5?v:e<2/3?f+(v-f)*6*(2/3-e):f}function fW(f){return f<.04045?.0773993808*f:Math.pow(.9478672986*f+.0521327014,2.4)}function fq(f){return f<.0031308?12.92*f:1.055*Math.pow(f,.41666)-.055}class fX{constructor(f,v,e){if(Object.defineProperty(this,"isColor",{value:!0}),void 0===v&&void 0===e)return this.set(f);return this.setRGB(f,v,e)}set(f){return f&&f.isColor?this.copy(f):"number"==typeof f?this.setHex(f):"string"==typeof f&&this.setStyle(f),this}setScalar(f){return this.r=f,this.g=f,this.b=f,this}setHex(f){return f=Math.floor(f),this.r=(f>>16&255)/255,this.g=(f>>8&255)/255,this.b=(255&f)/255,this}setRGB(f,v,e){return this.r=f,this.g=v,this.b=e,this}setHSL(f,v,e){if(f=m.euclideanModulo(f,1),v=m.clamp(v,0,1),e=m.clamp(e,0,1),0===v)this.r=this.g=this.b=e;else{let s=e<=.5?e*(1+v):e+v-e*v,t=2*e-s;this.r=fV(t,s,f+1/3),this.g=fV(t,s,f),this.b=fV(t,s,f-1/3)}return this}setStyle(f){let v;function e(v){void 0!==v&&1>parseFloat(v)&&console.warn("THREE.Color: Alpha component of "+f+" will be ignored.")}if(v=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(f)){let f;let s=v[1],t=v[2];switch(s){case"rgb":case"rgba":if(f=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(t))return this.r=Math.min(255,parseInt(f[1],10))/255,this.g=Math.min(255,parseInt(f[2],10))/255,this.b=Math.min(255,parseInt(f[3],10))/255,e(f[4]),this;if(f=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(t))return this.r=Math.min(100,parseInt(f[1],10))/100,this.g=Math.min(100,parseInt(f[2],10))/100,this.b=Math.min(100,parseInt(f[3],10))/100,e(f[4]),this;break;case"hsl":case"hsla":if(f=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(t)){let v=parseFloat(f[1])/360,s=parseInt(f[2],10)/100,t=parseInt(f[3],10)/100;return e(f[4]),this.setHSL(v,s,t)}}}else if(v=/^\#([A-Fa-f\d]+)$/.exec(f)){let f=v[1],e=f.length;if(3===e)return this.r=parseInt(f.charAt(0)+f.charAt(0),16)/255,this.g=parseInt(f.charAt(1)+f.charAt(1),16)/255,this.b=parseInt(f.charAt(2)+f.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(f.charAt(0)+f.charAt(1),16)/255,this.g=parseInt(f.charAt(2)+f.charAt(3),16)/255,this.b=parseInt(f.charAt(4)+f.charAt(5),16)/255,this}return f&&f.length>0?this.setColorName(f):this}setColorName(f){let v=fk[f];return void 0!==v?this.setHex(v):console.warn("THREE.Color: Unknown color "+f),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(f){return this.r=f.r,this.g=f.g,this.b=f.b,this}copyGammaToLinear(f,v=2){return this.r=Math.pow(f.r,v),this.g=Math.pow(f.g,v),this.b=Math.pow(f.b,v),this}copyLinearToGamma(f,v=2){let e=v>0?1/v:1;return this.r=Math.pow(f.r,e),this.g=Math.pow(f.g,e),this.b=Math.pow(f.b,e),this}convertGammaToLinear(f){return this.copyGammaToLinear(this,f),this}convertLinearToGamma(f){return this.copyLinearToGamma(this,f),this}copySRGBToLinear(f){return this.r=fW(f.r),this.g=fW(f.g),this.b=fW(f.b),this}copyLinearToSRGB(f){return this.r=fq(f.r),this.g=fq(f.g),this.b=fq(f.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(f){let v,e;void 0===f&&(console.warn("THREE.Color: .getHSL() target is now required"),f={h:0,s:0,l:0});let s=this.r,t=this.g,i=this.b,n=Math.max(s,t,i),r=Math.min(s,t,i),o=(r+n)/2;if(r===n)v=0,e=0;else{let f=n-r;switch(e=o<=.5?f/(n+r):f/(2-n-r),n){case s:v=(t-i)/f+(t<i?6:0);break;case t:v=(i-s)/f+2;break;case i:v=(s-t)/f+4}v/=6}return f.h=v,f.s=e,f.l=o,f}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(f,v,e){return this.getHSL(fG),fG.h+=f,fG.s+=v,fG.l+=e,this.setHSL(fG.h,fG.s,fG.l),this}add(f){return this.r+=f.r,this.g+=f.g,this.b+=f.b,this}addColors(f,v){return this.r=f.r+v.r,this.g=f.g+v.g,this.b=f.b+v.b,this}addScalar(f){return this.r+=f,this.g+=f,this.b+=f,this}sub(f){return this.r=Math.max(0,this.r-f.r),this.g=Math.max(0,this.g-f.g),this.b=Math.max(0,this.b-f.b),this}multiply(f){return this.r*=f.r,this.g*=f.g,this.b*=f.b,this}multiplyScalar(f){return this.r*=f,this.g*=f,this.b*=f,this}lerp(f,v){return this.r+=(f.r-this.r)*v,this.g+=(f.g-this.g)*v,this.b+=(f.b-this.b)*v,this}lerpColors(f,v,e){return this.r=f.r+(v.r-f.r)*e,this.g=f.g+(v.g-f.g)*e,this.b=f.b+(v.b-f.b)*e,this}lerpHSL(f,v){this.getHSL(fG),f.getHSL(fj);let e=m.lerp(fG.h,fj.h,v),s=m.lerp(fG.s,fj.s,v),t=m.lerp(fG.l,fj.l,v);return this.setHSL(e,s,t),this}equals(f){return f.r===this.r&&f.g===this.g&&f.b===this.b}fromArray(f,v=0){return this.r=f[v],this.g=f[v+1],this.b=f[v+2],this}toArray(f=[],v=0){return f[v]=this.r,f[v+1]=this.g,f[v+2]=this.b,f}fromBufferAttribute(f,v){return this.r=f.getX(v),this.g=f.getY(v),this.b=f.getZ(v),!0===f.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}fX.NAMES=fk,fX.prototype.r=1,fX.prototype.g=1,fX.prototype.b=1;class fY{constructor(f,v,e,s,t,i=0){this.a=f,this.b=v,this.c=e,this.normal=s&&s.isVector3?s:new T,this.vertexNormals=Array.isArray(s)?s:[],this.color=t&&t.isColor?t:new fX,this.vertexColors=Array.isArray(t)?t:[],this.materialIndex=i}clone(){return new this.constructor().copy(this)}copy(f){this.a=f.a,this.b=f.b,this.c=f.c,this.normal.copy(f.normal),this.color.copy(f.color),this.materialIndex=f.materialIndex;for(let v=0,e=f.vertexNormals.length;v<e;v++)this.vertexNormals[v]=f.vertexNormals[v].clone();for(let v=0,e=f.vertexColors.length;v<e;v++)this.vertexColors[v]=f.vertexColors[v].clone();return this}}let fZ=0;function fJ(){Object.defineProperty(this,"id",{value:fZ++}),this.uuid=m.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=o,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function f$(f){fJ.call(this),this.type="MeshBasicMaterial",this.color=new fX(0xffffff),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(f)}fJ.prototype=Object.assign(Object.create(u.prototype),{constructor:fJ,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(f){if(void 0!==f)for(let v in f){let e=f[v];if(void 0===e){console.warn("THREE.Material: '"+v+"' parameter is undefined.");continue}if("shading"===v){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===e;continue}let s=this[v];if(void 0===s){console.warn("THREE."+this.type+": '"+v+"' is not a property of this material.");continue}s&&s.isColor?s.set(e):s&&s.isVector3&&e&&e.isVector3?s.copy(e):this[v]=e}},toJSON:function(f){let v=void 0===f||"string"==typeof f;v&&(f={textures:{},images:{}});let e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function s(f){let v=[];for(let e in f){let s=f[e];delete s.metadata,v.push(s)}return v}if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),void 0!==this.roughness&&(e.roughness=this.roughness),void 0!==this.metalness&&(e.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(e.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),void 0!==this.shininess&&(e.shininess=this.shininess),void 0!==this.clearcoat&&(e.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(f).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(f).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(f).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(f).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(f).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(f).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(f).uuid),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(f).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(f).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(f).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(f).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(f).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(f).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(f).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(f).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(f).uuid,e.reflectivity=this.reflectivity,e.refractionRatio=this.refractionRatio,void 0!==this.combine&&(e.combine=this.combine),void 0!==this.envMapIntensity&&(e.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(f).uuid),void 0!==this.size&&(e.size=this.size),void 0!==this.sizeAttenuation&&(e.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(e.blending=this.blending),!0===this.flatShading&&(e.flatShading=this.flatShading),this.side!==o&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),!0===this.transparent&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(e.rotation=this.rotation),!0===this.polygonOffset&&(e.polygonOffset=!0),0!==this.polygonOffsetFactor&&(e.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(e.linewidth=this.linewidth),void 0!==this.dashSize&&(e.dashSize=this.dashSize),void 0!==this.gapSize&&(e.gapSize=this.gapSize),void 0!==this.scale&&(e.scale=this.scale),!0===this.dithering&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(e.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(e.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(e.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(e.morphTargets=!0),!0===this.morphNormals&&(e.morphNormals=!0),!0===this.skinning&&(e.skinning=!0),!1===this.visible&&(e.visible=!1),!1===this.toneMapped&&(e.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(e.userData=this.userData),v){let v=s(f.textures),t=s(f.images);v.length>0&&(e.textures=v),t.length>0&&(e.images=t)}return e},clone:function(){return new this.constructor().copy(this)},copy:function(f){this.name=f.name,this.fog=f.fog,this.blending=f.blending,this.side=f.side,this.flatShading=f.flatShading,this.vertexColors=f.vertexColors,this.opacity=f.opacity,this.transparent=f.transparent,this.blendSrc=f.blendSrc,this.blendDst=f.blendDst,this.blendEquation=f.blendEquation,this.blendSrcAlpha=f.blendSrcAlpha,this.blendDstAlpha=f.blendDstAlpha,this.blendEquationAlpha=f.blendEquationAlpha,this.depthFunc=f.depthFunc,this.depthTest=f.depthTest,this.depthWrite=f.depthWrite,this.stencilWriteMask=f.stencilWriteMask,this.stencilFunc=f.stencilFunc,this.stencilRef=f.stencilRef,this.stencilFuncMask=f.stencilFuncMask,this.stencilFail=f.stencilFail,this.stencilZFail=f.stencilZFail,this.stencilZPass=f.stencilZPass,this.stencilWrite=f.stencilWrite;let v=f.clippingPlanes,e=null;if(null!==v){let f=v.length;e=Array(f);for(let s=0;s!==f;++s)e[s]=v[s].clone()}return this.clippingPlanes=e,this.clipIntersection=f.clipIntersection,this.clipShadows=f.clipShadows,this.shadowSide=f.shadowSide,this.colorWrite=f.colorWrite,this.precision=f.precision,this.polygonOffset=f.polygonOffset,this.polygonOffsetFactor=f.polygonOffsetFactor,this.polygonOffsetUnits=f.polygonOffsetUnits,this.dithering=f.dithering,this.alphaTest=f.alphaTest,this.premultipliedAlpha=f.premultipliedAlpha,this.visible=f.visible,this.toneMapped=f.toneMapped,this.userData=JSON.parse(JSON.stringify(f.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(fJ.prototype,"needsUpdate",{set:function(f){!0===f&&this.version++}}),f$.prototype=Object.create(fJ.prototype),f$.prototype.constructor=f$,f$.prototype.isMeshBasicMaterial=!0,f$.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.map=f.map,this.lightMap=f.lightMap,this.lightMapIntensity=f.lightMapIntensity,this.aoMap=f.aoMap,this.aoMapIntensity=f.aoMapIntensity,this.specularMap=f.specularMap,this.alphaMap=f.alphaMap,this.envMap=f.envMap,this.combine=f.combine,this.reflectivity=f.reflectivity,this.refractionRatio=f.refractionRatio,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.wireframeLinecap=f.wireframeLinecap,this.wireframeLinejoin=f.wireframeLinejoin,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this};let fQ=new T,fK=new g;function f1(f,v,e){if(Array.isArray(f))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=f,this.itemSize=v,this.count=void 0!==f?f.length/v:0,this.normalized=!0===e,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}function f2(f,v,e){f1.call(this,new Int8Array(f),v,e)}function f3(f,v,e){f1.call(this,new Uint8Array(f),v,e)}function f4(f,v,e){f1.call(this,new Uint8ClampedArray(f),v,e)}function f0(f,v,e){f1.call(this,new Int16Array(f),v,e)}function f6(f,v,e){f1.call(this,new Uint16Array(f),v,e)}function f5(f,v,e){f1.call(this,new Int32Array(f),v,e)}function f7(f,v,e){f1.call(this,new Uint32Array(f),v,e)}function f8(f,v,e){f1.call(this,new Uint16Array(f),v,e)}function f9(f,v,e){f1.call(this,new Float32Array(f),v,e)}function vf(f,v,e){f1.call(this,new Float64Array(f),v,e)}function vv(f){if(0===f.length)return-1/0;let v=f[0];for(let e=1,s=f.length;e<s;++e)f[e]>v&&(v=f[e]);return v}Object.defineProperty(f1.prototype,"needsUpdate",{set:function(f){!0===f&&this.version++}}),Object.assign(f1.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(f){return this.usage=f,this},copy:function(f){return this.name=f.name,this.array=new f.array.constructor(f.array),this.itemSize=f.itemSize,this.count=f.count,this.normalized=f.normalized,this.usage=f.usage,this},copyAt:function(f,v,e){f*=this.itemSize,e*=v.itemSize;for(let s=0,t=this.itemSize;s<t;s++)this.array[f+s]=v.array[e+s];return this},copyArray:function(f){return this.array.set(f),this},copyColorsArray:function(f){let v=this.array,e=0;for(let s=0,t=f.length;s<t;s++){let t=f[s];void 0===t&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),t=new fX),v[e++]=t.r,v[e++]=t.g,v[e++]=t.b}return this},copyVector2sArray:function(f){let v=this.array,e=0;for(let s=0,t=f.length;s<t;s++){let t=f[s];void 0===t&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),t=new g),v[e++]=t.x,v[e++]=t.y}return this},copyVector3sArray:function(f){let v=this.array,e=0;for(let s=0,t=f.length;s<t;s++){let t=f[s];void 0===t&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),t=new T),v[e++]=t.x,v[e++]=t.y,v[e++]=t.z}return this},copyVector4sArray:function(f){let v=this.array,e=0;for(let s=0,t=f.length;s<t;s++){let t=f[s];void 0===t&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),t=new M),v[e++]=t.x,v[e++]=t.y,v[e++]=t.z,v[e++]=t.w}return this},applyMatrix3:function(f){if(2===this.itemSize)for(let v=0,e=this.count;v<e;v++)fK.fromBufferAttribute(this,v),fK.applyMatrix3(f),this.setXY(v,fK.x,fK.y);else if(3===this.itemSize)for(let v=0,e=this.count;v<e;v++)fQ.fromBufferAttribute(this,v),fQ.applyMatrix3(f),this.setXYZ(v,fQ.x,fQ.y,fQ.z);return this},applyMatrix4:function(f){for(let v=0,e=this.count;v<e;v++)fQ.x=this.getX(v),fQ.y=this.getY(v),fQ.z=this.getZ(v),fQ.applyMatrix4(f),this.setXYZ(v,fQ.x,fQ.y,fQ.z);return this},applyNormalMatrix:function(f){for(let v=0,e=this.count;v<e;v++)fQ.x=this.getX(v),fQ.y=this.getY(v),fQ.z=this.getZ(v),fQ.applyNormalMatrix(f),this.setXYZ(v,fQ.x,fQ.y,fQ.z);return this},transformDirection:function(f){for(let v=0,e=this.count;v<e;v++)fQ.x=this.getX(v),fQ.y=this.getY(v),fQ.z=this.getZ(v),fQ.transformDirection(f),this.setXYZ(v,fQ.x,fQ.y,fQ.z);return this},set:function(f,v=0){return this.array.set(f,v),this},getX:function(f){return this.array[f*this.itemSize]},setX:function(f,v){return this.array[f*this.itemSize]=v,this},getY:function(f){return this.array[f*this.itemSize+1]},setY:function(f,v){return this.array[f*this.itemSize+1]=v,this},getZ:function(f){return this.array[f*this.itemSize+2]},setZ:function(f,v){return this.array[f*this.itemSize+2]=v,this},getW:function(f){return this.array[f*this.itemSize+3]},setW:function(f,v){return this.array[f*this.itemSize+3]=v,this},setXY:function(f,v,e){return f*=this.itemSize,this.array[f+0]=v,this.array[f+1]=e,this},setXYZ:function(f,v,e,s){return f*=this.itemSize,this.array[f+0]=v,this.array[f+1]=e,this.array[f+2]=s,this},setXYZW:function(f,v,e,s,t){return f*=this.itemSize,this.array[f+0]=v,this.array[f+1]=e,this.array[f+2]=s,this.array[f+3]=t,this},onUpload:function(f){return this.onUploadCallback=f,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),f2.prototype=Object.create(f1.prototype),f2.prototype.constructor=f2,f3.prototype=Object.create(f1.prototype),f3.prototype.constructor=f3,f4.prototype=Object.create(f1.prototype),f4.prototype.constructor=f4,f0.prototype=Object.create(f1.prototype),f0.prototype.constructor=f0,f6.prototype=Object.create(f1.prototype),f6.prototype.constructor=f6,f5.prototype=Object.create(f1.prototype),f5.prototype.constructor=f5,f7.prototype=Object.create(f1.prototype),f7.prototype.constructor=f7,f8.prototype=Object.create(f1.prototype),f8.prototype.constructor=f8,f8.prototype.isFloat16BufferAttribute=!0,f9.prototype=Object.create(f1.prototype),f9.prototype.constructor=f9,vf.prototype=Object.create(f1.prototype),vf.prototype.constructor=vf;let ve={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function vs(f,v){return new ve[f](v)}let vt=0,vi=new ff,vn=new fE,vr=new T,vo=new R,va=new R,vl=new T;function vc(){Object.defineProperty(this,"id",{value:vt++}),this.uuid=m.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}vc.prototype=Object.assign(Object.create(u.prototype),{constructor:vc,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(f){return Array.isArray(f)?this.index=new(vv(f)>65535?f7:f6)(f,1):this.index=f,this},getAttribute:function(f){return this.attributes[f]},setAttribute:function(f,v){return this.attributes[f]=v,this},deleteAttribute:function(f){return delete this.attributes[f],this},hasAttribute:function(f){return void 0!==this.attributes[f]},addGroup:function(f,v,e=0){this.groups.push({start:f,count:v,materialIndex:e})},clearGroups:function(){this.groups=[]},setDrawRange:function(f,v){this.drawRange.start=f,this.drawRange.count=v},applyMatrix4:function(f){let v=this.attributes.position;void 0!==v&&(v.applyMatrix4(f),v.needsUpdate=!0);let e=this.attributes.normal;if(void 0!==e){let v=new y().getNormalMatrix(f);e.applyNormalMatrix(v),e.needsUpdate=!0}let s=this.attributes.tangent;return void 0!==s&&(s.transformDirection(f),s.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(f){return vi.makeRotationX(f),this.applyMatrix4(vi),this},rotateY:function(f){return vi.makeRotationY(f),this.applyMatrix4(vi),this},rotateZ:function(f){return vi.makeRotationZ(f),this.applyMatrix4(vi),this},translate:function(f,v,e){return vi.makeTranslation(f,v,e),this.applyMatrix4(vi),this},scale:function(f,v,e){return vi.makeScale(f,v,e),this.applyMatrix4(vi),this},lookAt:function(f){return vn.lookAt(f),vn.updateMatrix(),this.applyMatrix4(vn.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(vr).negate(),this.translate(vr.x,vr.y,vr.z),this},setFromPoints:function(f){let v=[];for(let e=0,s=f.length;e<s;e++){let s=f[e];v.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new f9(v,3)),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new R);let f=this.attributes.position,v=this.morphAttributes.position;if(f&&f.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new T(-1/0,-1/0,-1/0),new T(1/0,1/0,1/0));return}if(void 0!==f){if(this.boundingBox.setFromBufferAttribute(f),v)for(let f=0,e=v.length;f<e;f++){let e=v[f];vo.setFromBufferAttribute(e),this.morphTargetsRelative?(vl.addVectors(this.boundingBox.min,vo.min),this.boundingBox.expandByPoint(vl),vl.addVectors(this.boundingBox.max,vo.max),this.boundingBox.expandByPoint(vl)):(this.boundingBox.expandByPoint(vo.min),this.boundingBox.expandByPoint(vo.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new W);let f=this.attributes.position,v=this.morphAttributes.position;if(f&&f.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new T,1/0);return}if(f){let e=this.boundingSphere.center;if(vo.setFromBufferAttribute(f),v)for(let f=0,e=v.length;f<e;f++){let e=v[f];va.setFromBufferAttribute(e),this.morphTargetsRelative?(vl.addVectors(vo.min,va.min),vo.expandByPoint(vl),vl.addVectors(vo.max,va.max),vo.expandByPoint(vl)):(vo.expandByPoint(va.min),vo.expandByPoint(va.max))}vo.getCenter(e);let s=0;for(let v=0,t=f.count;v<t;v++)vl.fromBufferAttribute(f,v),s=Math.max(s,e.distanceToSquared(vl));if(v)for(let t=0,i=v.length;t<i;t++){let i=v[t],n=this.morphTargetsRelative;for(let v=0,t=i.count;v<t;v++)vl.fromBufferAttribute(i,v),n&&(vr.fromBufferAttribute(f,v),vl.add(vr)),s=Math.max(s,e.distanceToSquared(vl))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){let f=this.index,v=this.attributes;if(null===f||void 0===v.position||void 0===v.normal||void 0===v.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let e=f.array,s=v.position.array,t=v.normal.array,i=v.uv.array,n=s.length/3;void 0===v.tangent&&this.setAttribute("tangent",new f1(new Float32Array(4*n),4));let r=v.tangent.array,o=[],a=[];for(let f=0;f<n;f++)o[f]=new T,a[f]=new T;let l=new T,c=new T,h=new T,u=new g,d=new g,p=new g,m=new T,y=new T,x=this.groups;0===x.length&&(x=[{start:0,count:e.length}]);for(let f=0,v=x.length;f<v;++f){let v=x[f],t=v.start,n=v.count;for(let f=t,v=t+n;f<v;f+=3)!function(f,v,e){l.fromArray(s,3*f),c.fromArray(s,3*v),h.fromArray(s,3*e),u.fromArray(i,2*f),d.fromArray(i,2*v),p.fromArray(i,2*e),c.sub(l),h.sub(l),d.sub(u),p.sub(u);let t=1/(d.x*p.y-p.x*d.y);isFinite(t)&&(m.copy(c).multiplyScalar(p.y).addScaledVector(h,-d.y).multiplyScalar(t),y.copy(h).multiplyScalar(d.x).addScaledVector(c,-p.x).multiplyScalar(t),o[f].add(m),o[v].add(m),o[e].add(m),a[f].add(y),a[v].add(y),a[e].add(y))}(e[f+0],e[f+1],e[f+2])}let b=new T,_=new T,w=new T,M=new T;function S(f){w.fromArray(t,3*f),M.copy(w);let v=o[f];b.copy(v),b.sub(w.multiplyScalar(w.dot(v))).normalize(),_.crossVectors(M,v);let e=_.dot(a[f]);r[4*f]=b.x,r[4*f+1]=b.y,r[4*f+2]=b.z,r[4*f+3]=e<0?-1:1}for(let f=0,v=x.length;f<v;++f){let v=x[f],s=v.start,t=v.count;for(let f=s,v=s+t;f<v;f+=3)S(e[f+0]),S(e[f+1]),S(e[f+2])}},computeVertexNormals:function(){let f=this.index,v=this.getAttribute("position");if(void 0!==v){let e=this.getAttribute("normal");if(void 0===e)e=new f1(new Float32Array(3*v.count),3),this.setAttribute("normal",e);else for(let f=0,v=e.count;f<v;f++)e.setXYZ(f,0,0,0);let s=new T,t=new T,i=new T,n=new T,r=new T,o=new T,a=new T,l=new T;if(f)for(let c=0,h=f.count;c<h;c+=3){let h=f.getX(c+0),u=f.getX(c+1),d=f.getX(c+2);s.fromBufferAttribute(v,h),t.fromBufferAttribute(v,u),i.fromBufferAttribute(v,d),a.subVectors(i,t),l.subVectors(s,t),a.cross(l),n.fromBufferAttribute(e,h),r.fromBufferAttribute(e,u),o.fromBufferAttribute(e,d),n.add(a),r.add(a),o.add(a),e.setXYZ(h,n.x,n.y,n.z),e.setXYZ(u,r.x,r.y,r.z),e.setXYZ(d,o.x,o.y,o.z)}else for(let f=0,n=v.count;f<n;f+=3)s.fromBufferAttribute(v,f+0),t.fromBufferAttribute(v,f+1),i.fromBufferAttribute(v,f+2),a.subVectors(i,t),l.subVectors(s,t),a.cross(l),e.setXYZ(f+0,a.x,a.y,a.z),e.setXYZ(f+1,a.x,a.y,a.z),e.setXYZ(f+2,a.x,a.y,a.z);this.normalizeNormals(),e.needsUpdate=!0}},merge:function(f,v){if(!(f&&f.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",f);return}void 0===v&&(v=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));let e=this.attributes;for(let s in e){if(void 0===f.attributes[s])continue;let t=e[s].array,i=f.attributes[s],n=i.array,r=i.itemSize*v,o=Math.min(n.length,t.length-r);for(let f=0,v=r;f<o;f++,v++)t[v]=n[f]}return this},normalizeNormals:function(){let f=this.attributes.normal;for(let v=0,e=f.count;v<e;v++)vl.fromBufferAttribute(f,v),vl.normalize(),f.setXYZ(v,vl.x,vl.y,vl.z)},toNonIndexed:function(){function f(f,v){let e=f.array,s=f.itemSize,t=f.normalized,i=new e.constructor(v.length*s),n=0,r=0;for(let f=0,t=v.length;f<t;f++){n=v[f]*s;for(let f=0;f<s;f++)i[r++]=e[n++]}return new f1(i,s,t)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let v=new vc,e=this.index.array,s=this.attributes;for(let t in s){let i=f(s[t],e);v.setAttribute(t,i)}let t=this.morphAttributes;for(let s in t){let i=[],n=t[s];for(let v=0,s=n.length;v<s;v++){let s=f(n[v],e);i.push(s)}v.morphAttributes[s]=i}v.morphTargetsRelative=this.morphTargetsRelative;let i=this.groups;for(let f=0,e=i.length;f<e;f++){let e=i[f];v.addGroup(e.start,e.count,e.materialIndex)}return v},toJSON:function(){let f={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(f.uuid=this.uuid,f.type=this.type,""!==this.name&&(f.name=this.name),Object.keys(this.userData).length>0&&(f.userData=this.userData),void 0!==this.parameters){let v=this.parameters;for(let e in v)void 0!==v[e]&&(f[e]=v[e]);return f}f.data={attributes:{}};let v=this.index;null!==v&&(f.data.index={type:v.array.constructor.name,array:Array.prototype.slice.call(v.array)});let e=this.attributes;for(let v in e){let s=e[v],t=s.toJSON(f.data);""!==s.name&&(t.name=s.name),f.data.attributes[v]=t}let s={},t=!1;for(let v in this.morphAttributes){let e=this.morphAttributes[v],i=[];for(let v=0,s=e.length;v<s;v++){let s=e[v],t=s.toJSON(f.data);""!==s.name&&(t.name=s.name),i.push(t)}i.length>0&&(s[v]=i,t=!0)}t&&(f.data.morphAttributes=s,f.data.morphTargetsRelative=this.morphTargetsRelative);let i=this.groups;i.length>0&&(f.data.groups=JSON.parse(JSON.stringify(i)));let n=this.boundingSphere;return null!==n&&(f.data.boundingSphere={center:n.center.toArray(),radius:n.radius}),f},clone:function(){return new vc().copy(this)},copy:function(f){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;let v={};this.name=f.name;let e=f.index;null!==e&&this.setIndex(e.clone(v));let s=f.attributes;for(let f in s){let e=s[f];this.setAttribute(f,e.clone(v))}let t=f.morphAttributes;for(let f in t){let e=[],s=t[f];for(let f=0,t=s.length;f<t;f++)e.push(s[f].clone(v));this.morphAttributes[f]=e}this.morphTargetsRelative=f.morphTargetsRelative;let i=f.groups;for(let f=0,v=i.length;f<v;f++){let v=i[f];this.addGroup(v.start,v.count,v.materialIndex)}let n=f.boundingBox;null!==n&&(this.boundingBox=n.clone());let r=f.boundingSphere;return null!==r&&(this.boundingSphere=r.clone()),this.drawRange.start=f.drawRange.start,this.drawRange.count=f.drawRange.count,this.userData=f.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});let vh=new ff,vu=new K,vd=new W,vp=new T,vm=new T,vg=new T,vy=new T,vx=new T,vb=new T,v_=new T,vw=new T,vM=new T,vS=new g,vE=new g,vT=new g,vL=new T,vA=new T;function vR(f=new vc,v=new f$){fE.call(this),this.type="Mesh",this.geometry=f,this.material=v,this.updateMorphTargets()}function vC(f,v,e,s,t,i,n,r,o,a,l,c){vp.fromBufferAttribute(t,a),vm.fromBufferAttribute(t,l),vg.fromBufferAttribute(t,c);let h=f.morphTargetInfluences;if(v.morphTargets&&i&&h){v_.set(0,0,0),vw.set(0,0,0),vM.set(0,0,0);for(let f=0,v=i.length;f<v;f++){let v=h[f],e=i[f];0!==v&&(vy.fromBufferAttribute(e,a),vx.fromBufferAttribute(e,l),vb.fromBufferAttribute(e,c),n?(v_.addScaledVector(vy,v),vw.addScaledVector(vx,v),vM.addScaledVector(vb,v)):(v_.addScaledVector(vy.sub(vp),v),vw.addScaledVector(vx.sub(vm),v),vM.addScaledVector(vb.sub(vg),v)))}vp.add(v_),vm.add(vw),vg.add(vM)}f.isSkinnedMesh&&(f.boneTransform(a,vp),f.boneTransform(l,vm),f.boneTransform(c,vg));let u=function(f,v,e,s,t,i,n,r){if(null===(1===v.side?s.intersectTriangle(n,i,t,!0,r):s.intersectTriangle(t,i,n,2!==v.side,r)))return null;vA.copy(r),vA.applyMatrix4(f.matrixWorld);let o=e.ray.origin.distanceTo(vA);return o<e.near||o>e.far?null:{distance:o,point:vA.clone(),object:f}}(f,v,e,s,vp,vm,vg,vL);if(u){r&&(vS.fromBufferAttribute(r,a),vE.fromBufferAttribute(r,l),vT.fromBufferAttribute(r,c),u.uv=fU.getUV(vL,vp,vm,vg,vS,vE,vT,new g)),o&&(vS.fromBufferAttribute(o,a),vE.fromBufferAttribute(o,l),vT.fromBufferAttribute(o,c),u.uv2=fU.getUV(vL,vp,vm,vg,vS,vE,vT,new g));let f=new fY(a,l,c);fU.getNormal(vp,vm,vg,f.normal),u.face=f}return u}vR.prototype=Object.assign(Object.create(fE.prototype),{constructor:vR,isMesh:!0,copy:function(f){return fE.prototype.copy.call(this,f),void 0!==f.morphTargetInfluences&&(this.morphTargetInfluences=f.morphTargetInfluences.slice()),void 0!==f.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},f.morphTargetDictionary)),this.material=f.material,this.geometry=f.geometry,this},updateMorphTargets:function(){let f=this.geometry;if(f.isBufferGeometry){let v=f.morphAttributes,e=Object.keys(v);if(e.length>0){let f=v[e[0]];if(void 0!==f){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let v=0,e=f.length;v<e;v++){let e=f[v].name||String(v);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=v}}}}else{let v=f.morphTargets;void 0!==v&&v.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(f,v){let e;let s=this.geometry,t=this.material,i=this.matrixWorld;if(void 0!==t&&(null===s.boundingSphere&&s.computeBoundingSphere(),vd.copy(s.boundingSphere),vd.applyMatrix4(i),!1!==f.ray.intersectsSphere(vd))){if(vh.copy(i).invert(),vu.copy(f.ray).applyMatrix4(vh),null!==s.boundingBox&&!1===vu.intersectsBox(s.boundingBox))return;if(s.isBufferGeometry){let i=s.index,n=s.attributes.position,r=s.morphAttributes.position,o=s.morphTargetsRelative,a=s.attributes.uv,l=s.attributes.uv2,c=s.groups,h=s.drawRange;if(null!==i){if(Array.isArray(t))for(let s=0,u=c.length;s<u;s++){let u=c[s],d=t[u.materialIndex],p=Math.max(u.start,h.start),m=Math.min(u.start+u.count,h.start+h.count);for(let s=p;s<m;s+=3)(e=vC(this,d,f,vu,n,r,o,a,l,i.getX(s),i.getX(s+1),i.getX(s+2)))&&(e.faceIndex=Math.floor(s/3),e.face.materialIndex=u.materialIndex,v.push(e))}else{let s=Math.max(0,h.start),c=Math.min(i.count,h.start+h.count);for(let h=s;h<c;h+=3)(e=vC(this,t,f,vu,n,r,o,a,l,i.getX(h),i.getX(h+1),i.getX(h+2)))&&(e.faceIndex=Math.floor(h/3),v.push(e))}}else if(void 0!==n){if(Array.isArray(t))for(let s=0,i=c.length;s<i;s++){let i=c[s],u=t[i.materialIndex],d=Math.max(i.start,h.start),p=Math.min(i.start+i.count,h.start+h.count);for(let s=d;s<p;s+=3)(e=vC(this,u,f,vu,n,r,o,a,l,s,s+1,s+2))&&(e.faceIndex=Math.floor(s/3),e.face.materialIndex=i.materialIndex,v.push(e))}else{let s=Math.max(0,h.start),i=Math.min(n.count,h.start+h.count);for(let c=s;c<i;c+=3)(e=vC(this,t,f,vu,n,r,o,a,l,c,c+1,c+2))&&(e.faceIndex=Math.floor(c/3),v.push(e))}}}else s.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}});class vP extends vc{constructor(f=1,v=1,e=1,s=1,t=1,i=1){super(),this.type="BoxGeometry",this.parameters={width:f,height:v,depth:e,widthSegments:s,heightSegments:t,depthSegments:i};let n=this;s=Math.floor(s),t=Math.floor(t);let r=[],o=[],a=[],l=[],c=0,h=0;function u(f,v,e,s,t,i,u,d,p,m,g){let y=i/p,x=u/m,b=i/2,_=u/2,w=d/2,M=p+1,S=m+1,E=0,L=0,A=new T;for(let i=0;i<S;i++){let n=i*x-_;for(let r=0;r<M;r++){let c=r*y-b;A[f]=c*s,A[v]=n*t,A[e]=w,o.push(A.x,A.y,A.z),A[f]=0,A[v]=0,A[e]=d>0?1:-1,a.push(A.x,A.y,A.z),l.push(r/p),l.push(1-i/m),E+=1}}for(let f=0;f<m;f++)for(let v=0;v<p;v++){let e=c+v+M*f,s=c+v+M*(f+1),t=c+(v+1)+M*(f+1),i=c+(v+1)+M*f;r.push(e,s,i),r.push(s,t,i),L+=6}n.addGroup(h,L,g),h+=L,c+=E}u("z","y","x",-1,-1,e,v,f,i=Math.floor(i),t,0),u("z","y","x",1,-1,e,v,-f,i,t,1),u("x","z","y",1,1,f,e,v,s,i,2),u("x","z","y",1,-1,f,e,-v,s,i,3),u("x","y","z",1,-1,f,v,e,s,t,4),u("x","y","z",-1,-1,f,v,-e,s,t,5),this.setIndex(r),this.setAttribute("position",new f9(o,3)),this.setAttribute("normal",new f9(a,3)),this.setAttribute("uv",new f9(l,2))}}function vO(f){let v={};for(let e in f)for(let s in v[e]={},f[e]){let t=f[e][s];t&&(t.isColor||t.isMatrix3||t.isMatrix4||t.isVector2||t.isVector3||t.isVector4||t.isTexture)?v[e][s]=t.clone():Array.isArray(t)?v[e][s]=t.slice():v[e][s]=t}return v}function vD(f){let v={};for(let e=0;e<f.length;e++){let s=vO(f[e]);for(let f in s)v[f]=s[f]}return v}let vI={clone:vO};function vN(f){fJ.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==f&&(void 0!==f.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(f))}function vz(){fE.call(this),this.type="Camera",this.matrixWorldInverse=new ff,this.projectionMatrix=new ff,this.projectionMatrixInverse=new ff}function vH(f=50,v=1,e=.1,s=2e3){vz.call(this),this.type="PerspectiveCamera",this.fov=f,this.zoom=1,this.near=e,this.far=s,this.focus=10,this.aspect=v,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}function vF(f,v,e){if(fE.call(this),this.type="CubeCamera",!0!==e.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=e;let s=new vH(90,1,f,v);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new T(1,0,0)),this.add(s);let t=new vH(90,1,f,v);t.layers=this.layers,t.up.set(0,-1,0),t.lookAt(new T(-1,0,0)),this.add(t);let i=new vH(90,1,f,v);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new T(0,1,0)),this.add(i);let n=new vH(90,1,f,v);n.layers=this.layers,n.up.set(0,0,-1),n.lookAt(new T(0,-1,0)),this.add(n);let r=new vH(90,1,f,v);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new T(0,0,1)),this.add(r);let o=new vH(90,1,f,v);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new T(0,0,-1)),this.add(o),this.update=function(f,v){null===this.parent&&this.updateMatrixWorld();let a=f.xr.enabled,l=f.getRenderTarget();f.xr.enabled=!1;let c=e.texture.generateMipmaps;e.texture.generateMipmaps=!1,f.setRenderTarget(e,0),f.render(v,s),f.setRenderTarget(e,1),f.render(v,t),f.setRenderTarget(e,2),f.render(v,i),f.setRenderTarget(e,3),f.render(v,n),f.setRenderTarget(e,4),f.render(v,r),e.texture.generateMipmaps=c,f.setRenderTarget(e,5),f.render(v,o),f.setRenderTarget(l),f.xr.enabled=a}}function vB(f,v,e,s,t,i,n,r,o,a){f=void 0!==f?f:[],v=void 0!==v?v:301,n=void 0!==n?n:1022,_.call(this,f,v,e,s,t,i,n,r,o,a),this.flipY=!1,this._needsFlipEnvMap=!0}vN.prototype=Object.create(fJ.prototype),vN.prototype.constructor=vN,vN.prototype.isShaderMaterial=!0,vN.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.fragmentShader=f.fragmentShader,this.vertexShader=f.vertexShader,this.uniforms=vO(f.uniforms),this.defines=Object.assign({},f.defines),this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.lights=f.lights,this.clipping=f.clipping,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this.extensions=Object.assign({},f.extensions),this.glslVersion=f.glslVersion,this},vN.prototype.toJSON=function(f){let v=fJ.prototype.toJSON.call(this,f);for(let e in v.glslVersion=this.glslVersion,v.uniforms={},this.uniforms){let s=this.uniforms[e].value;s&&s.isTexture?v.uniforms[e]={type:"t",value:s.toJSON(f).uuid}:s&&s.isColor?v.uniforms[e]={type:"c",value:s.getHex()}:s&&s.isVector2?v.uniforms[e]={type:"v2",value:s.toArray()}:s&&s.isVector3?v.uniforms[e]={type:"v3",value:s.toArray()}:s&&s.isVector4?v.uniforms[e]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?v.uniforms[e]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?v.uniforms[e]={type:"m4",value:s.toArray()}:v.uniforms[e]={value:s}}Object.keys(this.defines).length>0&&(v.defines=this.defines),v.vertexShader=this.vertexShader,v.fragmentShader=this.fragmentShader;let e={};for(let f in this.extensions)!0===this.extensions[f]&&(e[f]=!0);return Object.keys(e).length>0&&(v.extensions=e),v},vz.prototype=Object.assign(Object.create(fE.prototype),{constructor:vz,isCamera:!0,copy:function(f,v){return fE.prototype.copy.call(this,f,v),this.matrixWorldInverse.copy(f.matrixWorldInverse),this.projectionMatrix.copy(f.projectionMatrix),this.projectionMatrixInverse.copy(f.projectionMatrixInverse),this},getWorldDirection:function(f){void 0===f&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),f=new T),this.updateWorldMatrix(!0,!1);let v=this.matrixWorld.elements;return f.set(-v[8],-v[9],-v[10]).normalize()},updateMatrixWorld:function(f){fE.prototype.updateMatrixWorld.call(this,f),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(f,v){fE.prototype.updateWorldMatrix.call(this,f,v),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}}),vH.prototype=Object.assign(Object.create(vz.prototype),{constructor:vH,isPerspectiveCamera:!0,copy:function(f,v){return vz.prototype.copy.call(this,f,v),this.fov=f.fov,this.zoom=f.zoom,this.near=f.near,this.far=f.far,this.focus=f.focus,this.aspect=f.aspect,this.view=null===f.view?null:Object.assign({},f.view),this.filmGauge=f.filmGauge,this.filmOffset=f.filmOffset,this},setFocalLength:function(f){let v=.5*this.getFilmHeight()/f;this.fov=2*m.RAD2DEG*Math.atan(v),this.updateProjectionMatrix()},getFocalLength:function(){let f=Math.tan(.5*m.DEG2RAD*this.fov);return .5*this.getFilmHeight()/f},getEffectiveFOV:function(){return 2*m.RAD2DEG*Math.atan(Math.tan(.5*m.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(f,v,e,s,t,i){this.aspect=f/v,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=f,this.view.fullHeight=v,this.view.offsetX=e,this.view.offsetY=s,this.view.width=t,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){let f=this.near,v=f*Math.tan(.5*m.DEG2RAD*this.fov)/this.zoom,e=2*v,s=this.aspect*e,t=-.5*s,i=this.view;if(null!==this.view&&this.view.enabled){let f=i.fullWidth,n=i.fullHeight;t+=i.offsetX*s/f,v-=i.offsetY*e/n,s*=i.width/f,e*=i.height/n}let n=this.filmOffset;0!==n&&(t+=f*n/this.getFilmWidth()),this.projectionMatrix.makePerspective(t,t+s,v,v-e,f,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(f){let v=fE.prototype.toJSON.call(this,f);return v.object.fov=this.fov,v.object.zoom=this.zoom,v.object.near=this.near,v.object.far=this.far,v.object.focus=this.focus,v.object.aspect=this.aspect,null!==this.view&&(v.object.view=Object.assign({},this.view)),v.object.filmGauge=this.filmGauge,v.object.filmOffset=this.filmOffset,v}}),vF.prototype=Object.create(fE.prototype),vF.prototype.constructor=vF,vB.prototype=Object.create(_.prototype),vB.prototype.constructor=vB,vB.prototype.isCubeTexture=!0,Object.defineProperty(vB.prototype,"images",{get:function(){return this.image},set:function(f){this.image=f}});class vU extends S{constructor(f,v,e){Number.isInteger(v)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),v=e),super(f,f,v),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),v=v||{},this.texture=new vB(void 0,v.mapping,v.wrapS,v.wrapT,v.magFilter,v.minFilter,v.format,v.type,v.anisotropy,v.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(f,v){this.texture.type=v.type,this.texture.format=1023,this.texture.encoding=v.encoding,this.texture.generateMipmaps=v.generateMipmaps,this.texture.minFilter=v.minFilter,this.texture.magFilter=v.magFilter;let e={uniforms:{tEquirect:{value:null}},vertexShader:`
// 			`},s=new vP(5,5,5),t=new vN({name:"CubemapFromEquirect",uniforms:vO(e.uniforms),vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,side:1,blending:0});t.uniforms.tEquirect.value=v;let i=new vR(s,t),n=v.minFilter;return 1008===v.minFilter&&(v.minFilter=1006),new vF(1,10,this).update(f,i),v.minFilter=n,i.geometry.dispose(),i.material.dispose(),this}clear(f,v,e,s){let t=f.getRenderTarget();for(let t=0;t<6;t++)f.setRenderTarget(this,t),f.clear(v,e,s);f.setRenderTarget(t)}}function vk(f,v,e,s,t,i,n,r,o,a,l,c){_.call(this,null,i,n,r,o,a,s,t,l,c),this.image={data:f||null,width:v||1,height:e||1},this.magFilter=void 0!==o?o:1003,this.minFilter=void 0!==a?a:1003,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}vk.prototype=Object.create(_.prototype),vk.prototype.constructor=vk,vk.prototype.isDataTexture=!0;let vG=/*@__PURE__*/new W,vj=/*@__PURE__*/new T;class vV{constructor(f,v,e,s,t,i){this.planes=[void 0!==f?f:new fR,void 0!==v?v:new fR,void 0!==e?e:new fR,void 0!==s?s:new fR,void 0!==t?t:new fR,void 0!==i?i:new fR]}set(f,v,e,s,t,i){let n=this.planes;return n[0].copy(f),n[1].copy(v),n[2].copy(e),n[3].copy(s),n[4].copy(t),n[5].copy(i),this}clone(){return new this.constructor().copy(this)}copy(f){let v=this.planes;for(let e=0;e<6;e++)v[e].copy(f.planes[e]);return this}setFromProjectionMatrix(f){let v=this.planes,e=f.elements,s=e[0],t=e[1],i=e[2],n=e[3],r=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=e[9],u=e[10],d=e[11],p=e[12],m=e[13],g=e[14],y=e[15];return v[0].setComponents(n-s,l-r,d-c,y-p).normalize(),v[1].setComponents(n+s,l+r,d+c,y+p).normalize(),v[2].setComponents(n+t,l+o,d+h,y+m).normalize(),v[3].setComponents(n-t,l-o,d-h,y-m).normalize(),v[4].setComponents(n-i,l-a,d-u,y-g).normalize(),v[5].setComponents(n+i,l+a,d+u,y+g).normalize(),this}intersectsObject(f){let v=f.geometry;return null===v.boundingSphere&&v.computeBoundingSphere(),vG.copy(v.boundingSphere).applyMatrix4(f.matrixWorld),this.intersectsSphere(vG)}intersectsSprite(f){return vG.center.set(0,0,0),vG.radius=.7071067811865476,vG.applyMatrix4(f.matrixWorld),this.intersectsSphere(vG)}intersectsSphere(f){let v=this.planes,e=f.center,s=-f.radius;for(let f=0;f<6;f++)if(v[f].distanceToPoint(e)<s)return!1;return!0}intersectsBox(f){let v=this.planes;for(let e=0;e<6;e++){let s=v[e];if(vj.x=s.normal.x>0?f.max.x:f.min.x,vj.y=s.normal.y>0?f.max.y:f.min.y,vj.z=s.normal.z>0?f.max.z:f.min.z,0>s.distanceToPoint(vj))return!1}return!0}containsPoint(f){let v=this.planes;for(let e=0;e<6;e++)if(0>v[e].distanceToPoint(f))return!1;return!0}}function vW(){let f=null,v=!1,e=null,s=null;function t(v,i){e(v,i),s=f.requestAnimationFrame(t)}return{start:function(){!0!==v&&null!==e&&(s=f.requestAnimationFrame(t),v=!0)},stop:function(){f.cancelAnimationFrame(s),v=!1},setAnimationLoop:function(f){e=f},setContext:function(v){f=v}}}function vq(f,v){let e=v.isWebGL2,s=new WeakMap;return{get:function(f){return f.isInterleavedBufferAttribute&&(f=f.data),s.get(f)},remove:function(v){v.isInterleavedBufferAttribute&&(v=v.data);let e=s.get(v);e&&(f.deleteBuffer(e.buffer),s.delete(v))},update:function(v,t){if(v.isGLBufferAttribute){let f=s.get(v);(!f||f.version<v.version)&&s.set(v,{buffer:v.buffer,type:v.type,bytesPerElement:v.elementSize,version:v.version});return}v.isInterleavedBufferAttribute&&(v=v.data);let i=s.get(v);void 0===i?s.set(v,function(v,s){let t=v.array,i=v.usage,n=f.createBuffer();f.bindBuffer(s,n),f.bufferData(s,t,i),v.onUploadCallback();let r=5126;return t instanceof Float32Array?r=5126:t instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):t instanceof Uint16Array?v.isFloat16BufferAttribute?e?r=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):r=5123:t instanceof Int16Array?r=5122:t instanceof Uint32Array?r=5125:t instanceof Int32Array?r=5124:t instanceof Int8Array?r=5120:t instanceof Uint8Array&&(r=5121),{buffer:n,type:r,bytesPerElement:t.BYTES_PER_ELEMENT,version:v.version}}(v,t)):i.version<v.version&&(function(v,s,t){let i=s.array,n=s.updateRange;f.bindBuffer(t,v),-1===n.count?f.bufferSubData(t,0,i):(e?f.bufferSubData(t,n.offset*i.BYTES_PER_ELEMENT,i,n.offset,n.count):f.bufferSubData(t,n.offset*i.BYTES_PER_ELEMENT,i.subarray(n.offset,n.offset+n.count)),n.count=-1)}(i.buffer,v,t),i.version=v.version)}}}class vX extends vc{constructor(f=1,v=1,e=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:f,height:v,widthSegments:e,heightSegments:s};let t=f/2,i=v/2,n=Math.floor(e),r=Math.floor(s),o=n+1,a=r+1,l=f/n,c=v/r,h=[],u=[],d=[],p=[];for(let f=0;f<a;f++){let v=f*c-i;for(let e=0;e<o;e++){let s=e*l-t;u.push(s,-v,0),d.push(0,0,1),p.push(e/n),p.push(1-f/r)}}for(let f=0;f<r;f++)for(let v=0;v<n;v++){let e=v+o*f,s=v+o*(f+1),t=v+1+o*(f+1),i=v+1+o*f;h.push(e,s,i),h.push(s,t,i)}this.setIndex(h),this.setAttribute("position",new f9(u,3)),this.setAttribute("normal",new f9(d,3)),this.setAttribute("uv",new f9(p,2))}}let vY={alphamap_fragment:"#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n	varying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",map_fragment:"#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"},vZ={common:{diffuse:{value:new fX(0xeeeeee)},opacity:{value:1},map:{value:null},uvTransform:{value:new y},uv2Transform:{value:new y},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new g(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new fX(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new fX(0xeeeeee)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new y}},sprite:{diffuse:{value:new fX(0xeeeeee)},opacity:{value:1},center:{value:new g(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new y}}},vJ={basic:{uniforms:vD([vZ.common,vZ.specularmap,vZ.envmap,vZ.aomap,vZ.lightmap,vZ.fog]),vertexShader:vY.meshbasic_vert,fragmentShader:vY.meshbasic_frag},lambert:{uniforms:vD([vZ.common,vZ.specularmap,vZ.envmap,vZ.aomap,vZ.lightmap,vZ.emissivemap,vZ.fog,vZ.lights,{emissive:{value:new fX(0)}}]),vertexShader:vY.meshlambert_vert,fragmentShader:vY.meshlambert_frag},phong:{uniforms:vD([vZ.common,vZ.specularmap,vZ.envmap,vZ.aomap,vZ.lightmap,vZ.emissivemap,vZ.bumpmap,vZ.normalmap,vZ.displacementmap,vZ.fog,vZ.lights,{emissive:{value:new fX(0)},specular:{value:new fX(1118481)},shininess:{value:30}}]),vertexShader:vY.meshphong_vert,fragmentShader:vY.meshphong_frag},standard:{uniforms:vD([vZ.common,vZ.envmap,vZ.aomap,vZ.lightmap,vZ.emissivemap,vZ.bumpmap,vZ.normalmap,vZ.displacementmap,vZ.roughnessmap,vZ.metalnessmap,vZ.fog,vZ.lights,{emissive:{value:new fX(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:vY.meshphysical_vert,fragmentShader:vY.meshphysical_frag},toon:{uniforms:vD([vZ.common,vZ.aomap,vZ.lightmap,vZ.emissivemap,vZ.bumpmap,vZ.normalmap,vZ.displacementmap,vZ.gradientmap,vZ.fog,vZ.lights,{emissive:{value:new fX(0)}}]),vertexShader:vY.meshtoon_vert,fragmentShader:vY.meshtoon_frag},matcap:{uniforms:vD([vZ.common,vZ.bumpmap,vZ.normalmap,vZ.displacementmap,vZ.fog,{matcap:{value:null}}]),vertexShader:vY.meshmatcap_vert,fragmentShader:vY.meshmatcap_frag},points:{uniforms:vD([vZ.points,vZ.fog]),vertexShader:vY.points_vert,fragmentShader:vY.points_frag},dashed:{uniforms:vD([vZ.common,vZ.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:vY.linedashed_vert,fragmentShader:vY.linedashed_frag},depth:{uniforms:vD([vZ.common,vZ.displacementmap]),vertexShader:vY.depth_vert,fragmentShader:vY.depth_frag},normal:{uniforms:vD([vZ.common,vZ.bumpmap,vZ.normalmap,vZ.displacementmap,{opacity:{value:1}}]),vertexShader:vY.normal_vert,fragmentShader:vY.normal_frag},sprite:{uniforms:vD([vZ.sprite,vZ.fog]),vertexShader:vY.sprite_vert,fragmentShader:vY.sprite_frag},background:{uniforms:{uvTransform:{value:new y},t2D:{value:null}},vertexShader:vY.background_vert,fragmentShader:vY.background_frag},cube:{uniforms:vD([vZ.envmap,{opacity:{value:1}}]),vertexShader:vY.cube_vert,fragmentShader:vY.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:vY.equirect_vert,fragmentShader:vY.equirect_frag},distanceRGBA:{uniforms:vD([vZ.common,vZ.displacementmap,{referencePosition:{value:new T},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:vY.distanceRGBA_vert,fragmentShader:vY.distanceRGBA_frag},shadow:{uniforms:vD([vZ.lights,vZ.fog,{color:{value:new fX(0)},opacity:{value:1}}]),vertexShader:vY.shadow_vert,fragmentShader:vY.shadow_frag}};function v$(f,v,e,s,t){let i,n;let r=new fX(0),a=0,l=null,c=0,h=null;function u(f,v){e.buffers.color.setClear(f.r,f.g,f.b,v,t)}return{getClearColor:function(){return r},setClearColor:function(f,v=1){r.set(f),u(r,a=v)},getClearAlpha:function(){return a},setClearAlpha:function(f){u(r,a=f)},render:function(e,t,d,p){let m=!0===t.isScene?t.background:null;m&&m.isTexture&&(m=v.get(m));let g=f.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?u(r,a):m&&m.isColor&&(u(m,1),p=!0),(f.autoClear||p)&&f.clear(f.autoClearColor,f.autoClearDepth,f.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||306===m.mapping)?(void 0===n&&((n=new vR(new vP(1,1,1),new vN({name:"BackgroundCubeMaterial",uniforms:vO(vJ.cube.uniforms),vertexShader:vJ.cube.vertexShader,fragmentShader:vJ.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),n.geometry.deleteAttribute("uv"),n.onBeforeRender=function(f,v,e){this.matrixWorld.copyPosition(e.matrixWorld)},Object.defineProperty(n.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(n)),m.isWebGLCubeRenderTarget&&(m=m.texture),n.material.uniforms.envMap.value=m,n.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,(l!==m||c!==m.version||h!==f.toneMapping)&&(n.material.needsUpdate=!0,l=m,c=m.version,h=f.toneMapping),e.unshift(n,n.geometry,n.material,0,0,null)):m&&m.isTexture&&(void 0===i&&((i=new vR(new vX(2,2),new vN({name:"BackgroundMaterial",uniforms:vO(vJ.background.uniforms),vertexShader:vJ.background.vertexShader,fragmentShader:vJ.background.fragmentShader,side:o,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(i.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(i)),i.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),i.material.uniforms.uvTransform.value.copy(m.matrix),(l!==m||c!==m.version||h!==f.toneMapping)&&(i.material.needsUpdate=!0,l=m,c=m.version,h=f.toneMapping),e.unshift(i,i.geometry,i.material,0,0,null))}}}function vQ(f,v,e,s){let t=f.getParameter(34921),i=s.isWebGL2?null:v.get("OES_vertex_array_object"),n=s.isWebGL2||null!==i,r={},o=h(null),a=o;function l(v){return s.isWebGL2?f.bindVertexArray(v):i.bindVertexArrayOES(v)}function c(v){return s.isWebGL2?f.deleteVertexArray(v):i.deleteVertexArrayOES(v)}function h(f){let v=[],e=[],s=[];for(let f=0;f<t;f++)v[f]=0,e[f]=0,s[f]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:v,enabledAttributes:e,attributeDivisors:s,object:f,attributes:{},index:null}}function u(){let f=a.newAttributes;for(let v=0,e=f.length;v<e;v++)f[v]=0}function d(f){p(f,0)}function p(e,t){let i=a.newAttributes,n=a.enabledAttributes,r=a.attributeDivisors;i[e]=1,0===n[e]&&(f.enableVertexAttribArray(e),n[e]=1),r[e]!==t&&((s.isWebGL2?f:v.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](e,t),r[e]=t)}function m(){let v=a.newAttributes,e=a.enabledAttributes;for(let s=0,t=e.length;s<t;s++)e[s]!==v[s]&&(f.disableVertexAttribArray(s),e[s]=0)}function g(v,e,t,i,n,r){!0===s.isWebGL2&&(5124===t||5125===t)?f.vertexAttribIPointer(v,e,t,n,r):f.vertexAttribPointer(v,e,t,i,n,r)}function y(){x(),a!==o&&l((a=o).object)}function x(){o.geometry=null,o.program=null,o.wireframe=!1}return{setup:function(t,o,c,y,x){let b=!1;if(n){let v=function(v,e,t){let n=!0===t.wireframe,o=r[v.id];void 0===o&&(o={},r[v.id]=o);let a=o[e.id];void 0===a&&(a={},o[e.id]=a);let l=a[n];return void 0===l&&(l=h(s.isWebGL2?f.createVertexArray():i.createVertexArrayOES()),a[n]=l),l}(y,c,o);a!==v&&l((a=v).object),(b=function(f,v){let e=a.attributes,s=f.attributes,t=0;for(let f in s){let v=e[f],i=s[f];if(void 0===v||v.attribute!==i||v.data!==i.data)return!0;t++}return a.attributesNum!==t||a.index!==v}(y,x))&&function(f,v){let e={},s=f.attributes,t=0;for(let f in s){let v=s[f],i={};i.attribute=v,v.data&&(i.data=v.data),e[f]=i,t++}a.attributes=e,a.attributesNum=t,a.index=v}(y,x)}else{let f=!0===o.wireframe;(a.geometry!==y.id||a.program!==c.id||a.wireframe!==f)&&(a.geometry=y.id,a.program=c.id,a.wireframe=f,b=!0)}!0===t.isInstancedMesh&&(b=!0),null!==x&&e.update(x,34963),b&&(function(t,i,n,r){if(!1===s.isWebGL2&&(t.isInstancedMesh||r.isInstancedBufferGeometry)&&null===v.get("ANGLE_instanced_arrays"))return;u();let o=r.attributes,a=n.getAttributes(),l=i.defaultAttributeValues;for(let v in a){let s=a[v];if(s>=0){let i=o[v];if(void 0!==i){let v=i.normalized,t=i.itemSize,n=e.get(i);if(void 0===n)continue;let o=n.buffer,a=n.type,l=n.bytesPerElement;if(i.isInterleavedBufferAttribute){let e=i.data,n=e.stride,c=i.offset;e&&e.isInstancedInterleavedBuffer?(p(s,e.meshPerAttribute),void 0===r._maxInstanceCount&&(r._maxInstanceCount=e.meshPerAttribute*e.count)):d(s),f.bindBuffer(34962,o),g(s,t,a,v,n*l,c*l)}else i.isInstancedBufferAttribute?(p(s,i.meshPerAttribute),void 0===r._maxInstanceCount&&(r._maxInstanceCount=i.meshPerAttribute*i.count)):d(s),f.bindBuffer(34962,o),g(s,t,a,v,0,0)}else if("instanceMatrix"===v){let v=e.get(t.instanceMatrix);if(void 0===v)continue;let i=v.buffer,n=v.type;p(s+0,1),p(s+1,1),p(s+2,1),p(s+3,1),f.bindBuffer(34962,i),f.vertexAttribPointer(s+0,4,n,!1,64,0),f.vertexAttribPointer(s+1,4,n,!1,64,16),f.vertexAttribPointer(s+2,4,n,!1,64,32),f.vertexAttribPointer(s+3,4,n,!1,64,48)}else if("instanceColor"===v){let v=e.get(t.instanceColor);if(void 0===v)continue;let i=v.buffer,n=v.type;p(s,1),f.bindBuffer(34962,i),f.vertexAttribPointer(s,3,n,!1,12,0)}else if(void 0!==l){let e=l[v];if(void 0!==e)switch(e.length){case 2:f.vertexAttrib2fv(s,e);break;case 3:f.vertexAttrib3fv(s,e);break;case 4:f.vertexAttrib4fv(s,e);break;default:f.vertexAttrib1fv(s,e)}}}}m()}(t,o,c,y),null!==x&&f.bindBuffer(34963,e.get(x).buffer))},reset:y,resetDefaultState:x,dispose:function(){for(let f in y(),r){let v=r[f];for(let f in v){let e=v[f];for(let f in e)c(e[f].object),delete e[f];delete v[f]}delete r[f]}},releaseStatesOfGeometry:function(f){if(void 0===r[f.id])return;let v=r[f.id];for(let f in v){let e=v[f];for(let f in e)c(e[f].object),delete e[f];delete v[f]}delete r[f.id]},releaseStatesOfProgram:function(f){for(let v in r){let e=r[v];if(void 0===e[f.id])continue;let s=e[f.id];for(let f in s)c(s[f].object),delete s[f];delete e[f.id]}},initAttributes:u,enableAttribute:d,disableUnusedAttributes:m}}function vK(f,v,e,s){let t;let i=s.isWebGL2;this.setMode=function(f){t=f},this.render=function(v,s){f.drawArrays(t,v,s),e.update(s,t,1)},this.renderInstances=function(s,n,r){let o,a;if(0!==r){if(i)o=f,a="drawArraysInstanced";else if(o=v.get("ANGLE_instanced_arrays"),a="drawArraysInstancedANGLE",null===o){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}o[a](t,s,n,r),e.update(n,t,r)}}}function v1(f,v,e){let s;function t(v){if("highp"===v){if(f.getShaderPrecisionFormat(35633,36338).precision>0&&f.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";v="mediump"}return"mediump"===v&&f.getShaderPrecisionFormat(35633,36337).precision>0&&f.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}let i="undefined"!=typeof WebGL2RenderingContext&&f instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&f instanceof WebGL2ComputeRenderingContext,n=void 0!==e.precision?e.precision:"highp",r=t(n);r!==n&&(console.warn("THREE.WebGLRenderer:",n,"not supported, using",r,"instead."),n=r);let o=!0===e.logarithmicDepthBuffer,a=f.getParameter(34930),l=f.getParameter(35660),c=f.getParameter(3379),h=f.getParameter(34076),u=f.getParameter(34921),d=f.getParameter(36347),p=f.getParameter(36348),m=f.getParameter(36349),g=l>0,y=i||!!v.get("OES_texture_float"),x=i?f.getParameter(36183):0;return{isWebGL2:i,getMaxAnisotropy:function(){if(void 0!==s)return s;let e=v.get("EXT_texture_filter_anisotropic");return s=null!==e?f.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:t,precision:n,logarithmicDepthBuffer:o,maxTextures:a,maxVertexTextures:l,maxTextureSize:c,maxCubemapSize:h,maxAttributes:u,maxVertexUniforms:d,maxVaryings:p,maxFragmentUniforms:m,vertexTextures:g,floatFragmentTextures:y,floatVertexTextures:g&&y,maxSamples:x}}function v2(f){let v=this,e=null,s=0,t=!1,i=!1,n=new fR,r=new y,o={value:null,needsUpdate:!1};function a(){o.value!==e&&(o.value=e,o.needsUpdate=s>0),v.numPlanes=s,v.numIntersection=0}function l(f,e,s,t){let i=null!==f?f.length:0,a=null;if(0!==i){if(a=o.value,!0!==t||null===a){let v=s+4*i,t=e.matrixWorldInverse;r.getNormalMatrix(t),(null===a||a.length<v)&&(a=new Float32Array(v));for(let v=0,e=s;v!==i;++v,e+=4)n.copy(f[v]).applyMatrix4(t,r),n.normal.toArray(a,e),a[e+3]=n.constant}o.value=a,o.needsUpdate=!0}return v.numPlanes=i,v.numIntersection=0,a}this.uniform=o,this.numPlanes=0,this.numIntersection=0,this.init=function(f,v,i){let n=0!==f.length||v||0!==s||t;return t=v,e=l(f,i,0),s=f.length,n},this.beginShadows=function(){i=!0,l(null)},this.endShadows=function(){i=!1,a()},this.setState=function(v,n,r){let c=v.clippingPlanes,h=v.clipIntersection,u=v.clipShadows,d=f.get(v);if(t&&null!==c&&0!==c.length&&(!i||u)){let f=i?0:s,v=4*f,t=d.clippingState||null;o.value=t,t=l(c,n,v,r);for(let f=0;f!==v;++f)t[f]=e[f];d.clippingState=t,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=f}else i?l(null):a()}}function v3(f){let v=new WeakMap;function e(f,v){return 303===v?f.mapping=301:304===v&&(f.mapping=302),f}function s(f){let e=f.target;e.removeEventListener("dispose",s);let t=v.get(e);void 0!==t&&(v.delete(e),t.dispose())}return{get:function(t){if(t&&t.isTexture){let i=t.mapping;if(303===i||304===i){if(v.has(t))return e(v.get(t).texture,t.mapping);{let i=t.image;if(!i||!(i.height>0))return null;{let n=f.getRenderList(),r=f.getRenderTarget(),o=new vU(i.height/2);return o.fromEquirectangularTexture(f,t),v.set(t,o),f.setRenderTarget(r),f.setRenderList(n),t.addEventListener("dispose",s),e(o.texture,t.mapping)}}}}return t},dispose:function(){v=new WeakMap}}}function v4(f){let v={};function e(e){let s;if(void 0!==v[e])return v[e];switch(e){case"WEBGL_depth_texture":s=f.getExtension("WEBGL_depth_texture")||f.getExtension("MOZ_WEBGL_depth_texture")||f.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=f.getExtension("EXT_texture_filter_anisotropic")||f.getExtension("MOZ_EXT_texture_filter_anisotropic")||f.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=f.getExtension("WEBGL_compressed_texture_s3tc")||f.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||f.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=f.getExtension("WEBGL_compressed_texture_pvrtc")||f.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=f.getExtension(e)}return v[e]=s,s}return{has:function(f){return null!==e(f)},init:function(f){f.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(f){let v=e(f);return null===v&&console.warn("THREE.WebGLRenderer: "+f+" extension not supported."),v}}}function v0(f,v,e,s){let t={},i=new WeakMap;function n(f){let r=f.target;for(let f in null!==r.index&&v.remove(r.index),r.attributes)v.remove(r.attributes[f]);r.removeEventListener("dispose",n),delete t[r.id];let o=i.get(r);o&&(v.remove(o),i.delete(r)),s.releaseStatesOfGeometry(r),!0===r.isInstancedBufferGeometry&&delete r._maxInstanceCount,e.memory.geometries--}function r(f){let e=[],s=f.index,t=f.attributes.position,n=0;if(null!==s){let f=s.array;n=s.version;for(let v=0,s=f.length;v<s;v+=3){let s=f[v+0],t=f[v+1],i=f[v+2];e.push(s,t,t,i,i,s)}}else{let f=t.array;n=t.version;for(let v=0,s=f.length/3-1;v<s;v+=3){let f=v+0,s=v+1,t=v+2;e.push(f,s,s,t,t,f)}}let r=new(vv(e)>65535?f7:f6)(e,1);r.version=n;let o=i.get(f);o&&v.remove(o),i.set(f,r)}return{get:function(f,v){return!0===t[v.id]||(v.addEventListener("dispose",n),t[v.id]=!0,e.memory.geometries++),v},update:function(f){let e=f.attributes;for(let f in e)v.update(e[f],34962);let s=f.morphAttributes;for(let f in s){let e=s[f];for(let f=0,s=e.length;f<s;f++)v.update(e[f],34962)}},getWireframeAttribute:function(f){let v=i.get(f);if(v){let e=f.index;null!==e&&v.version<e.version&&r(f)}else r(f);return i.get(f)}}}function v6(f,v,e,s){let t,i,n;let r=s.isWebGL2;this.setMode=function(f){t=f},this.setIndex=function(f){i=f.type,n=f.bytesPerElement},this.render=function(v,s){f.drawElements(t,s,i,v*n),e.update(s,t,1)},this.renderInstances=function(s,o,a){let l,c;if(0!==a){if(r)l=f,c="drawElementsInstanced";else if(l=v.get("ANGLE_instanced_arrays"),c="drawElementsInstancedANGLE",null===l){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}l[c](t,o,i,s*n,a),e.update(o,t,a)}}}function v5(f){let v={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:v,programs:null,autoReset:!0,reset:function(){v.frame++,v.calls=0,v.triangles=0,v.points=0,v.lines=0},update:function(f,e,s){switch(v.calls++,e){case 4:v.triangles+=f/3*s;break;case 1:v.lines+=f/2*s;break;case 3:v.lines+=s*(f-1);break;case 2:v.lines+=s*f;break;case 0:v.points+=s*f;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",e)}}}}function v7(f,v){return f[0]-v[0]}function v8(f,v){return Math.abs(v[1])-Math.abs(f[1])}function v9(f){let v={},e=new Float32Array(8),s=[];for(let f=0;f<8;f++)s[f]=[f,0];return{update:function(t,i,n,r){let o=t.morphTargetInfluences,a=void 0===o?0:o.length,l=v[i.id];if(void 0===l){l=[];for(let f=0;f<a;f++)l[f]=[f,0];v[i.id]=l}for(let f=0;f<a;f++){let v=l[f];v[0]=f,v[1]=o[f]}l.sort(v8);for(let f=0;f<8;f++)f<a&&l[f][1]?(s[f][0]=l[f][0],s[f][1]=l[f][1]):(s[f][0]=Number.MAX_SAFE_INTEGER,s[f][1]=0);s.sort(v7);let c=n.morphTargets&&i.morphAttributes.position,h=n.morphNormals&&i.morphAttributes.normal,u=0;for(let f=0;f<8;f++){let v=s[f],t=v[0],n=v[1];t!==Number.MAX_SAFE_INTEGER&&n?(c&&i.getAttribute("morphTarget"+f)!==c[t]&&i.setAttribute("morphTarget"+f,c[t]),h&&i.getAttribute("morphNormal"+f)!==h[t]&&i.setAttribute("morphNormal"+f,h[t]),e[f]=n,u+=n):(c&&!0===i.hasAttribute("morphTarget"+f)&&i.deleteAttribute("morphTarget"+f),h&&!0===i.hasAttribute("morphNormal"+f)&&i.deleteAttribute("morphNormal"+f),e[f]=0)}let d=i.morphTargetsRelative?1:1-u;r.getUniforms().setValue(f,"morphTargetBaseInfluence",d),r.getUniforms().setValue(f,"morphTargetInfluences",e)}}}function ef(f,v,e,s){let t=new WeakMap;function i(f){let v=f.target;v.removeEventListener("dispose",i),e.remove(v.instanceMatrix),null!==v.instanceColor&&e.remove(v.instanceColor)}return{update:function(f){let n=s.render.frame,r=f.geometry,o=v.get(f,r);return t.get(o)!==n&&(v.update(o),t.set(o,n)),f.isInstancedMesh&&(!1===f.hasEventListener("dispose",i)&&f.addEventListener("dispose",i),e.update(f.instanceMatrix,34962),null!==f.instanceColor&&e.update(f.instanceColor,34962)),o},dispose:function(){t=new WeakMap}}}function ev(f=null,v=1,e=1,s=1){_.call(this,null),this.image={data:f,width:v,height:e,depth:s},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function ee(f=null,v=1,e=1,s=1){_.call(this,null),this.image={data:f,width:v,height:e,depth:s},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}vJ.physical={uniforms:vD([vJ.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new g(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new fX(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:vY.meshphysical_vert,fragmentShader:vY.meshphysical_frag},ev.prototype=Object.create(_.prototype),ev.prototype.constructor=ev,ev.prototype.isDataTexture2DArray=!0,ee.prototype=Object.create(_.prototype),ee.prototype.constructor=ee,ee.prototype.isDataTexture3D=!0;let es=new _,et=new ev,ei=new ee,en=new vB,er=[],eo=[],ea=new Float32Array(16),el=new Float32Array(9),ec=new Float32Array(4);function eh(f,v,e){let s=f[0];if(s<=0||s>0)return f;let t=v*e,i=er[t];if(void 0===i&&(i=new Float32Array(t),er[t]=i),0!==v){s.toArray(i,0);for(let s=1,t=0;s!==v;++s)t+=e,f[s].toArray(i,t)}return i}function eu(f,v){if(f.length!==v.length)return!1;for(let e=0,s=f.length;e<s;e++)if(f[e]!==v[e])return!1;return!0}function ed(f,v){for(let e=0,s=v.length;e<s;e++)f[e]=v[e]}function ep(f,v){let e=eo[v];void 0===e&&(e=new Int32Array(v),eo[v]=e);for(let s=0;s!==v;++s)e[s]=f.allocateTextureUnit();return e}function em(f,v){let e=this.cache;e[0]!==v&&(f.uniform1f(this.addr,v),e[0]=v)}function eg(f,v){let e=this.cache;if(void 0!==v.x)(e[0]!==v.x||e[1]!==v.y)&&(f.uniform2f(this.addr,v.x,v.y),e[0]=v.x,e[1]=v.y);else{if(eu(e,v))return;f.uniform2fv(this.addr,v),ed(e,v)}}function ey(f,v){let e=this.cache;if(void 0!==v.x)(e[0]!==v.x||e[1]!==v.y||e[2]!==v.z)&&(f.uniform3f(this.addr,v.x,v.y,v.z),e[0]=v.x,e[1]=v.y,e[2]=v.z);else if(void 0!==v.r)(e[0]!==v.r||e[1]!==v.g||e[2]!==v.b)&&(f.uniform3f(this.addr,v.r,v.g,v.b),e[0]=v.r,e[1]=v.g,e[2]=v.b);else{if(eu(e,v))return;f.uniform3fv(this.addr,v),ed(e,v)}}function ex(f,v){let e=this.cache;if(void 0!==v.x)(e[0]!==v.x||e[1]!==v.y||e[2]!==v.z||e[3]!==v.w)&&(f.uniform4f(this.addr,v.x,v.y,v.z,v.w),e[0]=v.x,e[1]=v.y,e[2]=v.z,e[3]=v.w);else{if(eu(e,v))return;f.uniform4fv(this.addr,v),ed(e,v)}}function eb(f,v){let e=this.cache,s=v.elements;if(void 0===s){if(eu(e,v))return;f.uniformMatrix2fv(this.addr,!1,v),ed(e,v)}else{if(eu(e,s))return;ec.set(s),f.uniformMatrix2fv(this.addr,!1,ec),ed(e,s)}}function e_(f,v){let e=this.cache,s=v.elements;if(void 0===s){if(eu(e,v))return;f.uniformMatrix3fv(this.addr,!1,v),ed(e,v)}else{if(eu(e,s))return;el.set(s),f.uniformMatrix3fv(this.addr,!1,el),ed(e,s)}}function ew(f,v){let e=this.cache,s=v.elements;if(void 0===s){if(eu(e,v))return;f.uniformMatrix4fv(this.addr,!1,v),ed(e,v)}else{if(eu(e,s))return;ea.set(s),f.uniformMatrix4fv(this.addr,!1,ea),ed(e,s)}}function eM(f,v,e){let s=this.cache,t=e.allocateTextureUnit();s[0]!==t&&(f.uniform1i(this.addr,t),s[0]=t),e.safeSetTexture2D(v||es,t)}function eS(f,v,e){let s=this.cache,t=e.allocateTextureUnit();s[0]!==t&&(f.uniform1i(this.addr,t),s[0]=t),e.setTexture2DArray(v||et,t)}function eE(f,v,e){let s=this.cache,t=e.allocateTextureUnit();s[0]!==t&&(f.uniform1i(this.addr,t),s[0]=t),e.setTexture3D(v||ei,t)}function eT(f,v,e){let s=this.cache,t=e.allocateTextureUnit();s[0]!==t&&(f.uniform1i(this.addr,t),s[0]=t),e.safeSetTextureCube(v||en,t)}function eL(f,v){let e=this.cache;e[0]!==v&&(f.uniform1i(this.addr,v),e[0]=v)}function eA(f,v){let e=this.cache;eu(e,v)||(f.uniform2iv(this.addr,v),ed(e,v))}function eR(f,v){let e=this.cache;eu(e,v)||(f.uniform3iv(this.addr,v),ed(e,v))}function eC(f,v){let e=this.cache;eu(e,v)||(f.uniform4iv(this.addr,v),ed(e,v))}function eP(f,v){let e=this.cache;e[0]!==v&&(f.uniform1ui(this.addr,v),e[0]=v)}function eO(f,v){f.uniform1fv(this.addr,v)}function eD(f,v){f.uniform1iv(this.addr,v)}function eI(f,v){f.uniform2iv(this.addr,v)}function eN(f,v){f.uniform3iv(this.addr,v)}function ez(f,v){f.uniform4iv(this.addr,v)}function eH(f,v){let e=eh(v,this.size,2);f.uniform2fv(this.addr,e)}function eF(f,v){let e=eh(v,this.size,3);f.uniform3fv(this.addr,e)}function eB(f,v){let e=eh(v,this.size,4);f.uniform4fv(this.addr,e)}function eU(f,v){let e=eh(v,this.size,4);f.uniformMatrix2fv(this.addr,!1,e)}function ek(f,v){let e=eh(v,this.size,9);f.uniformMatrix3fv(this.addr,!1,e)}function eG(f,v){let e=eh(v,this.size,16);f.uniformMatrix4fv(this.addr,!1,e)}function ej(f,v,e){let s=v.length,t=ep(e,s);f.uniform1iv(this.addr,t);for(let f=0;f!==s;++f)e.safeSetTexture2D(v[f]||es,t[f])}function eV(f,v,e){let s=v.length,t=ep(e,s);f.uniform1iv(this.addr,t);for(let f=0;f!==s;++f)e.safeSetTextureCube(v[f]||en,t[f])}function eW(f,v,e){this.id=f,this.addr=e,this.cache=[],this.setValue=function(f){switch(f){case 5126:return em;case 35664:return eg;case 35665:return ey;case 35666:return ex;case 35674:return eb;case 35675:return e_;case 35676:return ew;case 5124:case 35670:return eL;case 35667:case 35671:return eA;case 35668:case 35672:return eR;case 35669:case 35673:return eC;case 5125:return eP;case 35678:case 36198:case 36298:case 36306:case 35682:return eM;case 35679:case 36299:case 36307:return eE;case 35680:case 36300:case 36308:case 36293:return eT;case 36289:case 36303:case 36311:case 36292:return eS}}(v.type)}function eq(f,v,e){this.id=f,this.addr=e,this.cache=[],this.size=v.size,this.setValue=function(f){switch(f){case 5126:return eO;case 35664:return eH;case 35665:return eF;case 35666:return eB;case 35674:return eU;case 35675:return ek;case 35676:return eG;case 5124:case 35670:return eD;case 35667:case 35671:return eI;case 35668:case 35672:return eN;case 35669:case 35673:return ez;case 35678:case 36198:case 36298:case 36306:case 35682:return ej;case 35680:case 36300:case 36308:case 36293:return eV}}(v.type)}function eX(f){this.id=f,this.seq=[],this.map={}}eq.prototype.updateCache=function(f){let v=this.cache;f instanceof Float32Array&&v.length!==f.length&&(this.cache=new Float32Array(f.length)),ed(v,f)},eX.prototype.setValue=function(f,v,e){let s=this.seq;for(let t=0,i=s.length;t!==i;++t){let i=s[t];i.setValue(f,v[i.id],e)}};let eY=/(\w+)(\])?(\[|\.)?/g;function eZ(f,v){f.seq.push(v),f.map[v.id]=v}function eJ(f,v){this.seq=[],this.map={};let e=f.getProgramParameter(v,35718);for(let s=0;s<e;++s){let e=f.getActiveUniform(v,s),t=f.getUniformLocation(v,e.name);!function(f,v,e){let s=f.name,t=s.length;for(eY.lastIndex=0;;){let i=eY.exec(s),n=eY.lastIndex,r=i[1],o="]"===i[2],a=i[3];if(o&&(r|=0),void 0===a||"["===a&&n+2===t){eZ(e,void 0===a?new eW(r,f,v):new eq(r,f,v));break}{let f=e.map[r];void 0===f&&eZ(e,f=new eX(r)),e=f}}}(e,t,this)}}function e$(f,v,e){let s=f.createShader(v);return f.shaderSource(s,e),f.compileShader(s),s}eJ.prototype.setValue=function(f,v,e,s){let t=this.map[v];void 0!==t&&t.setValue(f,e,s)},eJ.prototype.setOptional=function(f,v,e){let s=v[e];void 0!==s&&this.setValue(f,e,s)},eJ.upload=function(f,v,e,s){for(let t=0,i=v.length;t!==i;++t){let i=v[t],n=e[i.id];!1!==n.needsUpdate&&i.setValue(f,n.value,s)}},eJ.seqWithValue=function(f,v){let e=[];for(let s=0,t=f.length;s!==t;++s){let t=f[s];t.id in v&&e.push(t)}return e};let eQ=0;function eK(f){switch(f){case 3e3:return["Linear","( value )"];case c:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",f),["Linear","( value )"]}}function e1(f,v,e){let s=f.getShaderParameter(v,35713),t=f.getShaderInfoLog(v).trim();return s&&""===t?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+e+"\n"+t+function(f){let v=f.split("\n");for(let f=0;f<v.length;f++)v[f]=f+1+": "+v[f];return v.join("\n")}(f.getShaderSource(v))}function e2(f,v){let e=eK(v);return"vec4 "+f+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function e3(f){return""!==f}function e4(f,v){return f.replace(/NUM_DIR_LIGHTS/g,v.numDirLights).replace(/NUM_SPOT_LIGHTS/g,v.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,v.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,v.numPointLights).replace(/NUM_HEMI_LIGHTS/g,v.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,v.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,v.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,v.numPointLightShadows)}function e0(f,v){return f.replace(/NUM_CLIPPING_PLANES/g,v.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,v.numClippingPlanes-v.numClipIntersection)}let e6=/^[ \t]*#include +<([\w\d./]+)>/gm;function e5(f){return f.replace(e6,e7)}function e7(f,v){let e=vY[v];if(void 0===e)throw Error("Can not resolve #include <"+v+">");return e5(e)}let e8=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,e9=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function sf(f){return f.replace(e9,se).replace(e8,sv)}function sv(f,v,e,s){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),se(f,v,e,s)}function se(f,v,e,s){let t="";for(let f=parseInt(v);f<parseInt(e);f++)t+=s.replace(/\[\s*i\s*\]/g,"[ "+f+" ]").replace(/UNROLLED_LOOP_INDEX/g,f);return t}function ss(f){let v="precision "+f.precision+" float;\nprecision "+f.precision+" int;";return"highp"===f.precision?v+="\n#define HIGH_PRECISION":"mediump"===f.precision?v+="\n#define MEDIUM_PRECISION":"lowp"===f.precision&&(v+="\n#define LOW_PRECISION"),v}function st(f,v,e,s){let t,i,n,r,o;let l=f.getContext(),c=e.defines,u=e.vertexShader,d=e.fragmentShader,p=(o="SHADOWMAP_TYPE_BASIC",1===e.shadowMapType?o="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?o="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(o="SHADOWMAP_TYPE_VSM"),o),m=function(f){let v="ENVMAP_TYPE_CUBE";if(f.envMap)switch(f.envMapMode){case 301:case 302:v="ENVMAP_TYPE_CUBE";break;case 306:case 307:v="ENVMAP_TYPE_CUBE_UV"}return v}(e),g=function(f){let v="ENVMAP_MODE_REFLECTION";if(f.envMap)switch(f.envMapMode){case 302:case 307:v="ENVMAP_MODE_REFRACTION"}return v}(e),y=function(f){let v="ENVMAP_BLENDING_NONE";if(f.envMap)switch(f.combine){case 0:v="ENVMAP_BLENDING_MULTIPLY";break;case 1:v="ENVMAP_BLENDING_MIX";break;case 2:v="ENVMAP_BLENDING_ADD"}return v}(e),x=f.gammaFactor>0?f.gammaFactor:1,b=e.isWebGL2?"":[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(e3).join("\n"),_=function(f){let v=[];for(let e in f){let s=f[e];!1!==s&&v.push("#define "+e+" "+s)}return v.join("\n")}(c),w=l.createProgram(),M=e.glslVersion?"#version "+e.glslVersion+"\n":"";e.isRawShaderMaterial?((t=[_].filter(e3).join("\n")).length>0&&(t+="\n"),(i=[b,_].filter(e3).join("\n")).length>0&&(i+="\n")):(t=[ss(e),"#define SHADER_NAME "+e.shaderName,_,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+x,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+g:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&!1===e.flatShading?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+p:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif","\n"].filter(e3).join("\n"),i=[b,ss(e),"#define SHADER_NAME "+e.shaderName,_,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+x,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+m:"",e.envMap?"#define "+g:"",e.envMap?"#define "+y:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+p:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==e.toneMapping?"#define TONE_MAPPING":"",0!==e.toneMapping?vY.tonemapping_pars_fragment:"",0!==e.toneMapping?function(f,v){let e;switch(v){case 1:e="Linear";break;case 2:e="Reinhard";break;case 3:e="OptimizedCineon";break;case a:e="ACESFilmic";break;case 5:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",v),e="Linear"}return"vec3 "+f+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",vY.encodings_pars_fragment,e.map?e2("mapTexelToLinear",e.mapEncoding):"",e.matcap?e2("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?e2("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?e2("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?e2("lightMapTexelToLinear",e.lightMapEncoding):"",function(f,v){let e=eK(v);return"vec4 "+f+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"","\n"].filter(e3).join("\n")),u=e0(u=e4(u=e5(u),e),e),d=e0(d=e4(d=e5(d),e),e),u=sf(u),d=sf(d),e.isWebGL2&&!0!==e.isRawShaderMaterial&&(M="#version 300 es\n",t="#define attribute in\n#define varying out\n#define texture2D texture\n"+t,i=["#define varying in",e.glslVersion===h?"":"out highp vec4 pc_fragColor;",e.glslVersion===h?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+i);let S=M+t+u,E=M+i+d,T=e$(l,35633,S),L=e$(l,35632,E);if(l.attachShader(w,T),l.attachShader(w,L),void 0!==e.index0AttributeName?l.bindAttribLocation(w,0,e.index0AttributeName):!0===e.morphTargets&&l.bindAttribLocation(w,0,"position"),l.linkProgram(w),f.debug.checkShaderErrors){let f=l.getProgramInfoLog(w).trim(),v=l.getShaderInfoLog(T).trim(),e=l.getShaderInfoLog(L).trim(),s=!0,n=!0;if(!1===l.getProgramParameter(w,35714)){s=!1;let v=e1(l,T,"vertex"),e=e1(l,L,"fragment");console.error("THREE.WebGLProgram: shader error: ",l.getError(),"35715",l.getProgramParameter(w,35715),"gl.getProgramInfoLog",f,v,e)}else""!==f?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",f):(""===v||""===e)&&(n=!1);n&&(this.diagnostics={runnable:s,programLog:f,vertexShader:{log:v,prefix:t},fragmentShader:{log:e,prefix:i}})}return l.deleteShader(T),l.deleteShader(L),this.getUniforms=function(){return void 0===n&&(n=new eJ(l,w)),n},this.getAttributes=function(){return void 0===r&&(r=function(f,v){let e={},s=f.getProgramParameter(v,35721);for(let t=0;t<s;t++){let s=f.getActiveAttrib(v,t).name;e[s]=f.getAttribLocation(v,s)}return e}(l,w)),r},this.destroy=function(){s.releaseStatesOfProgram(this),l.deleteProgram(w),this.program=void 0},this.name=e.shaderName,this.id=eQ++,this.cacheKey=v,this.usedTimes=1,this.program=w,this.vertexShader=T,this.fragmentShader=L,this}function si(f,v,e,s,t,i){let n=[],r=s.isWebGL2,o=s.logarithmicDepthBuffer,a=s.floatVertexTextures,l=s.maxVertexUniforms,c=s.vertexTextures,h=s.precision,u={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},d=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function p(f){let v;return f&&f.isTexture?v=f.encoding:f&&f.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),v=f.texture.encoding):v=3e3,v}return{getParameters:function(t,n,d,m,g){let y,x;let b=m.fog,_=t.isMeshStandardMaterial?m.environment:null,w=v.get(t.envMap||_),M=u[t.type],S=g.isSkinnedMesh?function(f){let v=f.skeleton.bones;if(a)return 1024;{let f=Math.min(Math.floor((l-20)/4),v.length);return f<v.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+v.length+" bones. This GPU supports "+f+"."),0):f}}(g):0;if(null!==t.precision&&(h=s.getMaxPrecision(t.precision))!==t.precision&&console.warn("THREE.WebGLProgram.getParameters:",t.precision,"not supported, using",h,"instead."),M){let f=vJ[M];y=f.vertexShader,x=f.fragmentShader}else y=t.vertexShader,x=t.fragmentShader;let E=f.getRenderTarget();return{isWebGL2:r,shaderID:M,shaderName:t.type,vertexShader:y,fragmentShader:x,defines:t.defines,isRawShaderMaterial:!0===t.isRawShaderMaterial,glslVersion:t.glslVersion,precision:h,instancing:!0===g.isInstancedMesh,instancingColor:!0===g.isInstancedMesh&&null!==g.instanceColor,supportsVertexTextures:c,outputEncoding:null!==E?p(E.texture):f.outputEncoding,map:!!t.map,mapEncoding:p(t.map),matcap:!!t.matcap,matcapEncoding:p(t.matcap),envMap:!!w,envMapMode:w&&w.mapping,envMapEncoding:p(w),envMapCubeUV:!!w&&(306===w.mapping||307===w.mapping),lightMap:!!t.lightMap,lightMapEncoding:p(t.lightMap),aoMap:!!t.aoMap,emissiveMap:!!t.emissiveMap,emissiveMapEncoding:p(t.emissiveMap),bumpMap:!!t.bumpMap,normalMap:!!t.normalMap,objectSpaceNormalMap:1===t.normalMapType,tangentSpaceNormalMap:0===t.normalMapType,clearcoatMap:!!t.clearcoatMap,clearcoatRoughnessMap:!!t.clearcoatRoughnessMap,clearcoatNormalMap:!!t.clearcoatNormalMap,displacementMap:!!t.displacementMap,roughnessMap:!!t.roughnessMap,metalnessMap:!!t.metalnessMap,specularMap:!!t.specularMap,alphaMap:!!t.alphaMap,gradientMap:!!t.gradientMap,sheen:!!t.sheen,transmissionMap:!!t.transmissionMap,combine:t.combine,vertexTangents:t.normalMap&&t.vertexTangents,vertexColors:t.vertexColors,vertexUvs:!!t.map||!!t.bumpMap||!!t.normalMap||!!t.specularMap||!!t.alphaMap||!!t.emissiveMap||!!t.roughnessMap||!!t.metalnessMap||!!t.clearcoatMap||!!t.clearcoatRoughnessMap||!!t.clearcoatNormalMap||!!t.displacementMap||!!t.transmissionMap,uvsVertexOnly:!(t.map||t.bumpMap||t.normalMap||t.specularMap||t.alphaMap||t.emissiveMap||t.roughnessMap||t.metalnessMap||t.clearcoatNormalMap||t.transmissionMap)&&!!t.displacementMap,fog:!!b,useFog:t.fog,fogExp2:b&&b.isFogExp2,flatShading:t.flatShading,sizeAttenuation:t.sizeAttenuation,logarithmicDepthBuffer:o,skinning:t.skinning&&S>0,maxBones:S,useVertexTexture:a,morphTargets:t.morphTargets,morphNormals:t.morphNormals,maxMorphTargets:f.maxMorphTargets,maxMorphNormals:f.maxMorphNormals,numDirLights:n.directional.length,numPointLights:n.point.length,numSpotLights:n.spot.length,numRectAreaLights:n.rectArea.length,numHemiLights:n.hemi.length,numDirLightShadows:n.directionalShadowMap.length,numPointLightShadows:n.pointShadowMap.length,numSpotLightShadows:n.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:t.dithering,shadowMapEnabled:f.shadowMap.enabled&&d.length>0,shadowMapType:f.shadowMap.type,toneMapping:t.toneMapped?f.toneMapping:0,physicallyCorrectLights:f.physicallyCorrectLights,premultipliedAlpha:t.premultipliedAlpha,alphaTest:t.alphaTest,doubleSided:2===t.side,flipSided:1===t.side,depthPacking:void 0!==t.depthPacking&&t.depthPacking,index0AttributeName:t.index0AttributeName,extensionDerivatives:t.extensions&&t.extensions.derivatives,extensionFragDepth:t.extensions&&t.extensions.fragDepth,extensionDrawBuffers:t.extensions&&t.extensions.drawBuffers,extensionShaderTextureLOD:t.extensions&&t.extensions.shaderTextureLOD,rendererExtensionFragDepth:r||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:r||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:r||e.has("EXT_shader_texture_lod"),customProgramCacheKey:t.customProgramCacheKey()}},getProgramCacheKey:function(v){let e=[];if(v.shaderID?e.push(v.shaderID):(e.push(v.fragmentShader),e.push(v.vertexShader)),void 0!==v.defines)for(let f in v.defines)e.push(f),e.push(v.defines[f]);if(!1===v.isRawShaderMaterial){for(let f=0;f<d.length;f++)e.push(v[d[f]]);e.push(f.outputEncoding),e.push(f.gammaFactor)}return e.push(v.customProgramCacheKey),e.join()},getUniforms:function(f){let v;let e=u[f.type];if(e){let f=vJ[e];v=vI.clone(f.uniforms)}else v=f.uniforms;return v},acquireProgram:function(v,e){let s;for(let f=0,v=n.length;f<v;f++){let v=n[f];if(v.cacheKey===e){s=v,++s.usedTimes;break}}return void 0===s&&(s=new st(f,e,v,t),n.push(s)),s},releaseProgram:function(f){if(0==--f.usedTimes){let v=n.indexOf(f);n[v]=n[n.length-1],n.pop(),f.destroy()}},programs:n}}function sn(){let f=new WeakMap;return{get:function(v){let e=f.get(v);return void 0===e&&(e={},f.set(v,e)),e},remove:function(v){f.delete(v)},update:function(v,e,s){f.get(v)[e]=s},dispose:function(){f=new WeakMap}}}function sr(f,v){return f.groupOrder!==v.groupOrder?f.groupOrder-v.groupOrder:f.renderOrder!==v.renderOrder?f.renderOrder-v.renderOrder:f.program!==v.program?f.program.id-v.program.id:f.material.id!==v.material.id?f.material.id-v.material.id:f.z!==v.z?f.z-v.z:f.id-v.id}function so(f,v){return f.groupOrder!==v.groupOrder?f.groupOrder-v.groupOrder:f.renderOrder!==v.renderOrder?f.renderOrder-v.renderOrder:f.z!==v.z?v.z-f.z:f.id-v.id}function sa(f){let v=[],e=0,s=[],t=[],i={id:-1};function n(s,t,n,r,o,a){let l=v[e],c=f.get(n);return void 0===l?(l={id:s.id,object:s,geometry:t,material:n,program:c.program||i,groupOrder:r,renderOrder:s.renderOrder,z:o,group:a},v[e]=l):(l.id=s.id,l.object=s,l.geometry=t,l.material=n,l.program=c.program||i,l.groupOrder=r,l.renderOrder=s.renderOrder,l.z=o,l.group=a),e++,l}return{opaque:s,transparent:t,init:function(){e=0,s.length=0,t.length=0},push:function(f,v,e,i,r,o){let a=n(f,v,e,i,r,o);(!0===e.transparent?t:s).push(a)},unshift:function(f,v,e,i,r,o){let a=n(f,v,e,i,r,o);(!0===e.transparent?t:s).unshift(a)},finish:function(){for(let f=e,s=v.length;f<s;f++){let e=v[f];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.program=null,e.group=null}},sort:function(f,v){s.length>1&&s.sort(f||sr),t.length>1&&t.sort(v||so)}}}function sl(f){let v=new WeakMap;return{get:function(e,s){let t;let i=v.get(e);return void 0===i?(t=new sa(f),v.set(e,new WeakMap),v.get(e).set(s,t)):void 0===(t=i.get(s))&&(t=new sa(f),i.set(s,t)),t},dispose:function(){v=new WeakMap}}}function sc(){let f={};return{get:function(v){let e;if(void 0!==f[v.id])return f[v.id];switch(v.type){case"DirectionalLight":e={direction:new T,color:new fX};break;case"SpotLight":e={position:new T,direction:new T,color:new fX,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new T,color:new fX,distance:0,decay:0};break;case"HemisphereLight":e={direction:new T,skyColor:new fX,groundColor:new fX};break;case"RectAreaLight":e={color:new fX,position:new T,halfWidth:new T,halfHeight:new T}}return f[v.id]=e,e}}}let sh=0;function su(f,v){return(v.castShadow?1:0)-(f.castShadow?1:0)}function sd(f,v){let e=new sc,s=function(){let f={};return{get:function(v){let e;if(void 0!==f[v.id])return f[v.id];switch(v.type){case"DirectionalLight":case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new g};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new g,shadowCameraNear:1,shadowCameraFar:1e3}}return f[v.id]=e,e}}}(),t={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)t.probe.push(new T);let i=new T,n=new ff,r=new ff;return{setup:function(i){let n=0,r=0,o=0;for(let f=0;f<9;f++)t.probe[f].set(0,0,0);let a=0,l=0,c=0,h=0,u=0,d=0,p=0,m=0;i.sort(su);for(let f=0,v=i.length;f<v;f++){let v=i[f],g=v.color,y=v.intensity,x=v.distance,b=v.shadow&&v.shadow.map?v.shadow.map.texture:null;if(v.isAmbientLight)n+=g.r*y,r+=g.g*y,o+=g.b*y;else if(v.isLightProbe)for(let f=0;f<9;f++)t.probe[f].addScaledVector(v.sh.coefficients[f],y);else if(v.isDirectionalLight){let f=e.get(v);if(f.color.copy(v.color).multiplyScalar(v.intensity),v.castShadow){let f=v.shadow,e=s.get(v);e.shadowBias=f.bias,e.shadowNormalBias=f.normalBias,e.shadowRadius=f.radius,e.shadowMapSize=f.mapSize,t.directionalShadow[a]=e,t.directionalShadowMap[a]=b,t.directionalShadowMatrix[a]=v.shadow.matrix,d++}t.directional[a]=f,a++}else if(v.isSpotLight){let f=e.get(v);if(f.position.setFromMatrixPosition(v.matrixWorld),f.color.copy(g).multiplyScalar(y),f.distance=x,f.coneCos=Math.cos(v.angle),f.penumbraCos=Math.cos(v.angle*(1-v.penumbra)),f.decay=v.decay,v.castShadow){let f=v.shadow,e=s.get(v);e.shadowBias=f.bias,e.shadowNormalBias=f.normalBias,e.shadowRadius=f.radius,e.shadowMapSize=f.mapSize,t.spotShadow[c]=e,t.spotShadowMap[c]=b,t.spotShadowMatrix[c]=v.shadow.matrix,m++}t.spot[c]=f,c++}else if(v.isRectAreaLight){let f=e.get(v);f.color.copy(g).multiplyScalar(y),f.halfWidth.set(.5*v.width,0,0),f.halfHeight.set(0,.5*v.height,0),t.rectArea[h]=f,h++}else if(v.isPointLight){let f=e.get(v);if(f.color.copy(v.color).multiplyScalar(v.intensity),f.distance=v.distance,f.decay=v.decay,v.castShadow){let f=v.shadow,e=s.get(v);e.shadowBias=f.bias,e.shadowNormalBias=f.normalBias,e.shadowRadius=f.radius,e.shadowMapSize=f.mapSize,e.shadowCameraNear=f.camera.near,e.shadowCameraFar=f.camera.far,t.pointShadow[l]=e,t.pointShadowMap[l]=b,t.pointShadowMatrix[l]=v.shadow.matrix,p++}t.point[l]=f,l++}else if(v.isHemisphereLight){let f=e.get(v);f.skyColor.copy(v.color).multiplyScalar(y),f.groundColor.copy(v.groundColor).multiplyScalar(y),t.hemi[u]=f,u++}}h>0&&(v.isWebGL2?(t.rectAreaLTC1=vZ.LTC_FLOAT_1,t.rectAreaLTC2=vZ.LTC_FLOAT_2):!0===f.has("OES_texture_float_linear")?(t.rectAreaLTC1=vZ.LTC_FLOAT_1,t.rectAreaLTC2=vZ.LTC_FLOAT_2):!0===f.has("OES_texture_half_float_linear")?(t.rectAreaLTC1=vZ.LTC_HALF_1,t.rectAreaLTC2=vZ.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),t.ambient[0]=n,t.ambient[1]=r,t.ambient[2]=o;let g=t.hash;(g.directionalLength!==a||g.pointLength!==l||g.spotLength!==c||g.rectAreaLength!==h||g.hemiLength!==u||g.numDirectionalShadows!==d||g.numPointShadows!==p||g.numSpotShadows!==m)&&(t.directional.length=a,t.spot.length=c,t.rectArea.length=h,t.point.length=l,t.hemi.length=u,t.directionalShadow.length=d,t.directionalShadowMap.length=d,t.pointShadow.length=p,t.pointShadowMap.length=p,t.spotShadow.length=m,t.spotShadowMap.length=m,t.directionalShadowMatrix.length=d,t.pointShadowMatrix.length=p,t.spotShadowMatrix.length=m,g.directionalLength=a,g.pointLength=l,g.spotLength=c,g.rectAreaLength=h,g.hemiLength=u,g.numDirectionalShadows=d,g.numPointShadows=p,g.numSpotShadows=m,t.version=sh++)},setupView:function(f,v){let e=0,s=0,o=0,a=0,l=0,c=v.matrixWorldInverse;for(let v=0,h=f.length;v<h;v++){let h=f[v];if(h.isDirectionalLight){let f=t.directional[e];f.direction.setFromMatrixPosition(h.matrixWorld),i.setFromMatrixPosition(h.target.matrixWorld),f.direction.sub(i),f.direction.transformDirection(c),e++}else if(h.isSpotLight){let f=t.spot[o];f.position.setFromMatrixPosition(h.matrixWorld),f.position.applyMatrix4(c),f.direction.setFromMatrixPosition(h.matrixWorld),i.setFromMatrixPosition(h.target.matrixWorld),f.direction.sub(i),f.direction.transformDirection(c),o++}else if(h.isRectAreaLight){let f=t.rectArea[a];f.position.setFromMatrixPosition(h.matrixWorld),f.position.applyMatrix4(c),r.identity(),n.copy(h.matrixWorld),n.premultiply(c),r.extractRotation(n),f.halfWidth.set(.5*h.width,0,0),f.halfHeight.set(0,.5*h.height,0),f.halfWidth.applyMatrix4(r),f.halfHeight.applyMatrix4(r),a++}else if(h.isPointLight){let f=t.point[s];f.position.setFromMatrixPosition(h.matrixWorld),f.position.applyMatrix4(c),s++}else if(h.isHemisphereLight){let f=t.hemi[l];f.direction.setFromMatrixPosition(h.matrixWorld),f.direction.transformDirection(c),f.direction.normalize(),l++}}},state:t}}function sp(f,v){let e=new sd(f,v),s=[],t=[];return{init:function(){s.length=0,t.length=0},state:{lightsArray:s,shadowsArray:t,lights:e},setupLights:function(){e.setup(s)},setupLightsView:function(f){e.setupView(s,f)},pushLight:function(f){s.push(f)},pushShadow:function(f){t.push(f)}}}function sm(f,v){let e=new WeakMap;return{get:function(s,t=0){let i;return!1===e.has(s)?(i=new sp(f,v),e.set(s,[]),e.get(s).push(i)):t>=e.get(s).length?(i=new sp(f,v),e.get(s).push(i)):i=e.get(s)[t],i},dispose:function(){e=new WeakMap}}}function sg(f){fJ.call(this),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(f)}function sy(f){fJ.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new T,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(f)}function sx(f,v,e){let s=new vV,t=new g,i=new g,n=new M,r=[],a=[],l={},c={0:1,1:o,2:2},h=new vN({defines:{SAMPLE_RATE:.25,HALF_SAMPLE_RATE:.125},uniforms:{shadow_pass:{value:null},resolution:{value:new g},radius:{value:4}},vertexShader:"void main() {\n	gl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),u=h.clone();u.defines.HORIZONTAL_PASS=1;let d=new vc;d.setAttribute("position",new f1(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let p=new vR(d,h),m=this;function y(f,v,e){let s=f<<0|v<<1|e<<2,t=r[s];return void 0===t&&(t=new sg({depthPacking:3201,morphTargets:f,skinning:v}),r[s]=t),t}function x(f,v,e){let s=f<<0|v<<1|e<<2,t=a[s];return void 0===t&&(t=new sy({morphTargets:f,skinning:v}),a[s]=t),t}function b(v,e,s,t,i,n,r){let o=null,a=y,h=v.customDepthMaterial;if(!0===t.isPointLight&&(a=x,h=v.customDistanceMaterial),void 0===h){let f=!1;!0===s.morphTargets&&(f=e.morphAttributes&&e.morphAttributes.position&&e.morphAttributes.position.length>0);let t=!1;!0===v.isSkinnedMesh&&(!0===s.skinning?t=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",v)),o=a(f,t,!0===v.isInstancedMesh)}else o=h;if(f.localClippingEnabled&&!0===s.clipShadows&&0!==s.clippingPlanes.length){let f=o.uuid,v=s.uuid,e=l[f];void 0===e&&(e={},l[f]=e);let t=e[v];void 0===t&&(t=o.clone(),e[v]=t),o=t}return o.visible=s.visible,o.wireframe=s.wireframe,3===r?o.side=null!==s.shadowSide?s.shadowSide:s.side:o.side=null!==s.shadowSide?s.shadowSide:c[s.side],o.clipShadows=s.clipShadows,o.clippingPlanes=s.clippingPlanes,o.clipIntersection=s.clipIntersection,o.wireframeLinewidth=s.wireframeLinewidth,o.linewidth=s.linewidth,!0===t.isPointLight&&!0===o.isMeshDistanceMaterial&&(o.referencePosition.setFromMatrixPosition(t.matrixWorld),o.nearDistance=i,o.farDistance=n),o}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(r,o,a){if(!1===m.enabled||!1===m.autoUpdate&&!1===m.needsUpdate||0===r.length)return;let l=f.getRenderTarget(),c=f.getActiveCubeFace(),d=f.getActiveMipmapLevel(),g=f.state;g.setBlending(0),g.buffers.color.setClear(1,1,1,1),g.buffers.depth.setTest(!0),g.setScissorTest(!1);for(let l=0,c=r.length;l<c;l++){let c=r[l],d=c.shadow;if(void 0===d){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===d.autoUpdate&&!1===d.needsUpdate)continue;t.copy(d.mapSize);let m=d.getFrameExtents();if(t.multiply(m),i.copy(d.mapSize),(t.x>e||t.y>e)&&(t.x>e&&(i.x=Math.floor(e/m.x),t.x=i.x*m.x,d.mapSize.x=i.x),t.y>e&&(i.y=Math.floor(e/m.y),t.y=i.y*m.y,d.mapSize.y=i.y)),null===d.map&&!d.isPointLightShadow&&3===this.type){let f={minFilter:1006,magFilter:1006,format:1023};d.map=new S(t.x,t.y,f),d.map.texture.name=c.name+".shadowMap",d.mapPass=new S(t.x,t.y,f),d.camera.updateProjectionMatrix()}if(null===d.map){let f={minFilter:1003,magFilter:1003,format:1023};d.map=new S(t.x,t.y,f),d.map.texture.name=c.name+".shadowMap",d.camera.updateProjectionMatrix()}f.setRenderTarget(d.map),f.clear();let y=d.getViewportCount();for(let e=0;e<y;e++){let t=d.getViewport(e);n.set(i.x*t.x,i.y*t.y,i.x*t.z,i.y*t.w),g.viewport(n),d.updateMatrices(c,e),s=d.getFrustum(),function e(t,i,n,r,o){if(!1===t.visible)return;if(t.layers.test(i.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&3===o)&&(!t.frustumCulled||s.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld);let e=v.update(t),s=t.material;if(Array.isArray(s)){let v=e.groups;for(let i=0,a=v.length;i<a;i++){let a=v[i],l=s[a.materialIndex];if(l&&l.visible){let v=b(t,e,l,r,n.near,n.far,o);f.renderBufferDirect(n,null,e,v,t,a)}}}else if(s.visible){let v=b(t,e,s,r,n.near,n.far,o);f.renderBufferDirect(n,null,e,v,t,null)}}let a=t.children;for(let f=0,v=a.length;f<v;f++)e(a[f],i,n,r,o)}(o,a,d.camera,c,this.type)}d.isPointLightShadow||3!==this.type||function(e,s){let t=v.update(p);h.uniforms.shadow_pass.value=e.map.texture,h.uniforms.resolution.value=e.mapSize,h.uniforms.radius.value=e.radius,f.setRenderTarget(e.mapPass),f.clear(),f.renderBufferDirect(s,null,t,h,p,null),u.uniforms.shadow_pass.value=e.mapPass.texture,u.uniforms.resolution.value=e.mapSize,u.uniforms.radius.value=e.radius,f.setRenderTarget(e.map),f.clear(),f.renderBufferDirect(s,null,t,u,p,null)}(d,a),d.needsUpdate=!1}m.needsUpdate=!1,f.setRenderTarget(l,c,d)}}function sb(f,v,e){let s=e.isWebGL2,t=new function(){let v=!1,e=new M,s=null,t=new M(0,0,0,0);return{setMask:function(e){s===e||v||(f.colorMask(e,e,e,e),s=e)},setLocked:function(f){v=f},setClear:function(v,s,i,n,r){!0===r&&(v*=n,s*=n,i*=n),e.set(v,s,i,n),!1===t.equals(e)&&(f.clearColor(v,s,i,n),t.copy(e))},reset:function(){v=!1,s=null,t.set(-1,0,0,0)}}},i=new function(){let v=!1,e=null,s=null,t=null;return{setTest:function(f){f?D(2929):I(2929)},setMask:function(s){e===s||v||(f.depthMask(s),e=s)},setFunc:function(v){if(s!==v){if(v)switch(v){case 0:f.depthFunc(512);break;case 1:f.depthFunc(519);break;case 2:f.depthFunc(513);break;case 3:default:f.depthFunc(515);break;case 4:f.depthFunc(514);break;case 5:f.depthFunc(518);break;case 6:f.depthFunc(516);break;case 7:f.depthFunc(517)}else f.depthFunc(515);s=v}},setLocked:function(f){v=f},setClear:function(v){t!==v&&(f.clearDepth(v),t=v)},reset:function(){v=!1,e=null,s=null,t=null}}},n=new function(){let v=!1,e=null,s=null,t=null,i=null,n=null,r=null,o=null,a=null;return{setTest:function(f){v||(f?D(2960):I(2960))},setMask:function(s){e===s||v||(f.stencilMask(s),e=s)},setFunc:function(v,e,n){(s!==v||t!==e||i!==n)&&(f.stencilFunc(v,e,n),s=v,t=e,i=n)},setOp:function(v,e,s){(n!==v||r!==e||o!==s)&&(f.stencilOp(v,e,s),n=v,r=e,o=s)},setLocked:function(f){v=f},setClear:function(v){a!==v&&(f.clearStencil(v),a=v)},reset:function(){v=!1,e=null,s=null,t=null,i=null,n=null,r=null,o=null,a=null}}},r={},o=null,a=null,l=null,c=null,h=null,u=null,d=null,p=null,m=null,g=!1,y=null,x=null,b=null,_=null,w=null,S=f.getParameter(35661),E=!1,T=f.getParameter(7938);-1!==T.indexOf("WebGL")?E=parseFloat(/^WebGL (\d)/.exec(T)[1])>=1:-1!==T.indexOf("OpenGL ES")&&(E=parseFloat(/^OpenGL ES (\d)/.exec(T)[1])>=2);let L=null,A={},R=new M,C=new M;function P(v,e,s){let t=new Uint8Array(4),i=f.createTexture();f.bindTexture(v,i),f.texParameteri(v,10241,9728),f.texParameteri(v,10240,9728);for(let v=0;v<s;v++)f.texImage2D(e+v,0,6408,1,1,0,6408,5121,t);return i}let O={};function D(v){!0!==r[v]&&(f.enable(v),r[v]=!0)}function I(v){!1!==r[v]&&(f.disable(v),r[v]=!1)}O[3553]=P(3553,3553,1),O[34067]=P(34067,34069,6),t.setClear(0,0,0,1),i.setClear(1),n.setClear(0),D(2929),i.setFunc(3),F(!1),B(1),D(2884),H(0);let N={100:32774,101:32778,102:32779};if(s)N[103]=32775,N[104]=32776;else{let f=v.get("EXT_blend_minmax");null!==f&&(N[103]=f.MIN_EXT,N[104]=f.MAX_EXT)}let z={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function H(v,e,s,t,i,n,r,o){if(0===v){a&&(I(3042),a=!1);return}if(a||(D(3042),a=!0),5!==v){if(v!==l||o!==g){if((100!==c||100!==d)&&(f.blendEquation(32774),c=100,d=100),o)switch(v){case 1:f.blendFuncSeparate(1,771,1,771);break;case 2:f.blendFunc(1,1);break;case 3:f.blendFuncSeparate(0,0,769,771);break;case 4:f.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",v)}else switch(v){case 1:f.blendFuncSeparate(770,771,1,771);break;case 2:f.blendFunc(770,1);break;case 3:f.blendFunc(0,769);break;case 4:f.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",v)}h=null,u=null,p=null,m=null,l=v,g=o}return}i=i||e,n=n||s,r=r||t,(e!==c||i!==d)&&(f.blendEquationSeparate(N[e],N[i]),c=e,d=i),(s!==h||t!==u||n!==p||r!==m)&&(f.blendFuncSeparate(z[s],z[t],z[n],z[r]),h=s,u=t,p=n,m=r),l=v,g=null}function F(v){y!==v&&(v?f.frontFace(2304):f.frontFace(2305),y=v)}function B(v){0!==v?(D(2884),v!==x&&(1===v?f.cullFace(1029):2===v?f.cullFace(1028):f.cullFace(1032))):I(2884),x=v}function U(v,e,s){v?(D(32823),(_!==e||w!==s)&&(f.polygonOffset(e,s),_=e,w=s)):I(32823)}function k(v){void 0===v&&(v=33984+S-1),L!==v&&(f.activeTexture(v),L=v)}return{buffers:{color:t,depth:i,stencil:n},enable:D,disable:I,useProgram:function(v){return o!==v&&(f.useProgram(v),o=v,!0)},setBlending:H,setMaterial:function(f,v){2===f.side?I(2884):D(2884);let e=1===f.side;v&&(e=!e),F(e),1===f.blending&&!1===f.transparent?H(0):H(f.blending,f.blendEquation,f.blendSrc,f.blendDst,f.blendEquationAlpha,f.blendSrcAlpha,f.blendDstAlpha,f.premultipliedAlpha),i.setFunc(f.depthFunc),i.setTest(f.depthTest),i.setMask(f.depthWrite),t.setMask(f.colorWrite);let s=f.stencilWrite;n.setTest(s),s&&(n.setMask(f.stencilWriteMask),n.setFunc(f.stencilFunc,f.stencilRef,f.stencilFuncMask),n.setOp(f.stencilFail,f.stencilZFail,f.stencilZPass)),U(f.polygonOffset,f.polygonOffsetFactor,f.polygonOffsetUnits)},setFlipSided:F,setCullFace:B,setLineWidth:function(v){v!==b&&(E&&f.lineWidth(v),b=v)},setPolygonOffset:U,setScissorTest:function(f){f?D(3089):I(3089)},activeTexture:k,bindTexture:function(v,e){null===L&&k();let s=A[L];void 0===s&&(s={type:void 0,texture:void 0},A[L]=s),(s.type!==v||s.texture!==e)&&(f.bindTexture(v,e||O[v]),s.type=v,s.texture=e)},unbindTexture:function(){let v=A[L];void 0!==v&&void 0!==v.type&&(f.bindTexture(v.type,null),v.type=void 0,v.texture=void 0)},compressedTexImage2D:function(){try{f.compressedTexImage2D.apply(f,arguments)}catch(f){console.error("THREE.WebGLState:",f)}},texImage2D:function(){try{f.texImage2D.apply(f,arguments)}catch(f){console.error("THREE.WebGLState:",f)}},texImage3D:function(){try{f.texImage3D.apply(f,arguments)}catch(f){console.error("THREE.WebGLState:",f)}},scissor:function(v){!1===R.equals(v)&&(f.scissor(v.x,v.y,v.z,v.w),R.copy(v))},viewport:function(v){!1===C.equals(v)&&(f.viewport(v.x,v.y,v.z,v.w),C.copy(v))},reset:function(){r={},L=null,A={},o=null,a=null,l=null,c=null,h=null,u=null,d=null,p=null,m=null,g=!1,y=null,x=null,b=null,_=null,w=null,t.reset(),i.reset(),n.reset()}}}function s_(f,v,e,s,t,i,n){let r;let o=t.isWebGL2,a=t.maxTextures,c=t.maxCubemapSize,h=t.maxTextureSize,u=t.maxSamples,d=new WeakMap,p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(f){}function g(f,v){return p?new OffscreenCanvas(f,v):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(f,v,e,s){let t=1;if((f.width>s||f.height>s)&&(t=s/Math.max(f.width,f.height)),t<1||!0===v){if("undefined"!=typeof HTMLImageElement&&f instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&f instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&f instanceof ImageBitmap){let s=v?m.floorPowerOfTwo:Math.floor,i=s(t*f.width),n=s(t*f.height);void 0===r&&(r=g(i,n));let o=e?g(i,n):r;return o.width=i,o.height=n,o.getContext("2d").drawImage(f,0,0,i,n),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+f.width+"x"+f.height+") to ("+i+"x"+n+")."),o}"data"in f&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+f.width+"x"+f.height+").")}return f}function x(f){return m.isPowerOfTwo(f.width)&&m.isPowerOfTwo(f.height)}function b(f,v){return f.generateMipmaps&&v&&1003!==f.minFilter&&1006!==f.minFilter}function _(v,e,t,i){f.generateMipmap(v),s.get(e).__maxMipLevel=Math.log(Math.max(t,i))*Math.LOG2E}function w(e,s,t){if(!1===o)return s;if(null!==e){if(void 0!==f[e])return f[e];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+e+"'")}let i=s;return 6403===s&&(5126===t&&(i=33326),5131===t&&(i=33325),5121===t&&(i=33321)),6407===s&&(5126===t&&(i=34837),5131===t&&(i=34843),5121===t&&(i=32849)),6408===s&&(5126===t&&(i=34836),5131===t&&(i=34842),5121===t&&(i=32856)),(33325===i||33326===i||34842===i||34836===i)&&v.get("EXT_color_buffer_float"),i}function M(f){return 1003===f||1004===f||1005===f?9728:9729}function S(v){let e=v.target;e.removeEventListener("dispose",S),function(v){let e=s.get(v);void 0!==e.__webglInit&&(f.deleteTexture(e.__webglTexture),s.remove(v))}(e),e.isVideoTexture&&d.delete(e),n.memory.textures--}function E(v){let e=v.target;e.removeEventListener("dispose",E),function(v){let e=s.get(v),t=s.get(v.texture);if(v){if(void 0!==t.__webglTexture&&f.deleteTexture(t.__webglTexture),v.depthTexture&&v.depthTexture.dispose(),v.isWebGLCubeRenderTarget)for(let v=0;v<6;v++)f.deleteFramebuffer(e.__webglFramebuffer[v]),e.__webglDepthbuffer&&f.deleteRenderbuffer(e.__webglDepthbuffer[v]);else f.deleteFramebuffer(e.__webglFramebuffer),e.__webglDepthbuffer&&f.deleteRenderbuffer(e.__webglDepthbuffer),e.__webglMultisampledFramebuffer&&f.deleteFramebuffer(e.__webglMultisampledFramebuffer),e.__webglColorRenderbuffer&&f.deleteRenderbuffer(e.__webglColorRenderbuffer),e.__webglDepthRenderbuffer&&f.deleteRenderbuffer(e.__webglDepthRenderbuffer);s.remove(v.texture),s.remove(v)}}(e),n.memory.textures--}let T=0;function L(f,v){let t=s.get(f);if(f.isVideoTexture&&function(f){let v=n.render.frame;d.get(f)!==v&&(d.set(f,v),f.update())}(f),f.version>0&&t.__version!==f.version){let e=f.image;if(void 0===e)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(!1===e.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{D(t,f,v);return}}e.activeTexture(33984+v),e.bindTexture(3553,t.__webglTexture)}function A(v,t){let n=s.get(v);if(v.version>0&&n.__version!==v.version){(function(v,s,t){let n;if(6!==s.image.length)return;O(v,s),e.activeTexture(33984+t),e.bindTexture(34067,v.__webglTexture),f.pixelStorei(37440,s.flipY),f.pixelStorei(37441,s.premultiplyAlpha),f.pixelStorei(3317,s.unpackAlignment);let r=s&&(s.isCompressedTexture||s.image[0].isCompressedTexture),a=s.image[0]&&s.image[0].isDataTexture,l=[];for(let f=0;f<6;f++)r||a?l[f]=a?s.image[f].image:s.image[f]:l[f]=y(s.image[f],!1,!0,c);let h=l[0],u=x(h)||o,d=i.convert(s.format),p=i.convert(s.type),m=w(s.internalFormat,d,p);if(P(34067,s,u),r){for(let f=0;f<6;f++){n=l[f].mipmaps;for(let v=0;v<n.length;v++){let t=n[v];1023!==s.format&&1022!==s.format?null!==d?e.compressedTexImage2D(34069+f,v,m,t.width,t.height,0,t.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+f,v,m,t.width,t.height,0,d,p,t.data)}}v.__maxMipLevel=n.length-1}else{n=s.mipmaps;for(let f=0;f<6;f++)if(a){e.texImage2D(34069+f,0,m,l[f].width,l[f].height,0,d,p,l[f].data);for(let v=0;v<n.length;v++){let s=n[v].image[f].image;e.texImage2D(34069+f,v+1,m,s.width,s.height,0,d,p,s.data)}}else{e.texImage2D(34069+f,0,m,d,p,l[f]);for(let v=0;v<n.length;v++){let s=n[v];e.texImage2D(34069+f,v+1,m,d,p,s.image[f])}}v.__maxMipLevel=n.length}b(s,u)&&_(34067,s,h.width,h.height),v.__version=s.version,s.onUpdate&&s.onUpdate(s)})(n,v,t);return}e.activeTexture(33984+t),e.bindTexture(34067,n.__webglTexture)}let R={[l]:10497,1001:33071,1002:33648},C={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function P(e,i,n){n?(f.texParameteri(e,10242,R[i.wrapS]),f.texParameteri(e,10243,R[i.wrapT]),(32879===e||35866===e)&&f.texParameteri(e,32882,R[i.wrapR]),f.texParameteri(e,10240,C[i.magFilter]),f.texParameteri(e,10241,C[i.minFilter])):(f.texParameteri(e,10242,33071),f.texParameteri(e,10243,33071),(32879===e||35866===e)&&f.texParameteri(e,32882,33071),(1001!==i.wrapS||1001!==i.wrapT)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),f.texParameteri(e,10240,M(i.magFilter)),f.texParameteri(e,10241,M(i.minFilter)),1003!==i.minFilter&&1006!==i.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));let r=v.get("EXT_texture_filter_anisotropic");if(r){if(1015===i.type&&null===v.get("OES_texture_float_linear")||1016===i.type&&null===(o||v.get("OES_texture_half_float_linear")))return;(i.anisotropy>1||s.get(i).__currentAnisotropy)&&(f.texParameterf(e,r.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(i.anisotropy,t.getMaxAnisotropy())),s.get(i).__currentAnisotropy=i.anisotropy)}}function O(v,e){void 0===v.__webglInit&&(v.__webglInit=!0,e.addEventListener("dispose",S),v.__webglTexture=f.createTexture(),n.memory.textures++)}function D(v,s,t){let n,r=3553;s.isDataTexture2DArray&&(r=35866),s.isDataTexture3D&&(r=32879),O(v,s),e.activeTexture(33984+t),e.bindTexture(r,v.__webglTexture),f.pixelStorei(37440,s.flipY),f.pixelStorei(37441,s.premultiplyAlpha),f.pixelStorei(3317,s.unpackAlignment);let a=!o&&(1001!==s.wrapS||1001!==s.wrapT||1003!==s.minFilter&&1006!==s.minFilter)&&!1===x(s.image),l=y(s.image,a,!1,h),c=x(l)||o,u=i.convert(s.format),d=i.convert(s.type),p=w(s.internalFormat,u,d);P(r,s,c);let m=s.mipmaps;if(s.isDepthTexture)p=6402,o?p=1015===s.type?36012:1014===s.type?33190:1020===s.type?35056:33189:1015===s.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===s.format&&6402===p&&1012!==s.type&&1014!==s.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),s.type=1012,d=i.convert(s.type)),1027===s.format&&6402===p&&(p=34041,1020!==s.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),s.type=1020,d=i.convert(s.type))),e.texImage2D(3553,0,p,l.width,l.height,0,u,d,null);else if(s.isDataTexture){if(m.length>0&&c){for(let f=0,v=m.length;f<v;f++)n=m[f],e.texImage2D(3553,f,p,n.width,n.height,0,u,d,n.data);s.generateMipmaps=!1,v.__maxMipLevel=m.length-1}else e.texImage2D(3553,0,p,l.width,l.height,0,u,d,l.data),v.__maxMipLevel=0}else if(s.isCompressedTexture){for(let f=0,v=m.length;f<v;f++)n=m[f],1023!==s.format&&1022!==s.format?null!==u?e.compressedTexImage2D(3553,f,p,n.width,n.height,0,n.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,f,p,n.width,n.height,0,u,d,n.data);v.__maxMipLevel=m.length-1}else if(s.isDataTexture2DArray)e.texImage3D(35866,0,p,l.width,l.height,l.depth,0,u,d,l.data),v.__maxMipLevel=0;else if(s.isDataTexture3D)e.texImage3D(32879,0,p,l.width,l.height,l.depth,0,u,d,l.data),v.__maxMipLevel=0;else if(m.length>0&&c){for(let f=0,v=m.length;f<v;f++)n=m[f],e.texImage2D(3553,f,p,u,d,n);s.generateMipmaps=!1,v.__maxMipLevel=m.length-1}else e.texImage2D(3553,0,p,u,d,l),v.__maxMipLevel=0;b(s,c)&&_(r,s,l.width,l.height),v.__version=s.version,s.onUpdate&&s.onUpdate(s)}function I(v,t,n,r){let o=i.convert(t.texture.format),a=i.convert(t.texture.type),l=w(t.texture.internalFormat,o,a);e.texImage2D(r,0,l,t.width,t.height,0,o,a,null),f.bindFramebuffer(36160,v),f.framebufferTexture2D(36160,n,r,s.get(t.texture).__webglTexture,0),f.bindFramebuffer(36160,null)}function N(v,e,s){if(f.bindRenderbuffer(36161,v),e.depthBuffer&&!e.stencilBuffer){let t=33189;if(s){let v=e.depthTexture;v&&v.isDepthTexture&&(1015===v.type?t=36012:1014===v.type&&(t=33190));let s=z(e);f.renderbufferStorageMultisample(36161,s,t,e.width,e.height)}else f.renderbufferStorage(36161,t,e.width,e.height);f.framebufferRenderbuffer(36160,36096,36161,v)}else if(e.depthBuffer&&e.stencilBuffer){if(s){let v=z(e);f.renderbufferStorageMultisample(36161,v,35056,e.width,e.height)}else f.renderbufferStorage(36161,34041,e.width,e.height);f.framebufferRenderbuffer(36160,33306,36161,v)}else{let v=i.convert(e.texture.format),t=i.convert(e.texture.type),n=w(e.texture.internalFormat,v,t);if(s){let v=z(e);f.renderbufferStorageMultisample(36161,v,n,e.width,e.height)}else f.renderbufferStorage(36161,n,e.width,e.height)}f.bindRenderbuffer(36161,null)}function z(f){return o&&f.isWebGLMultisampleRenderTarget?Math.min(u,f.samples):0}let H=!1,F=!1;this.allocateTextureUnit=function(){let f=T;return f>=a&&console.warn("THREE.WebGLTextures: Trying to use "+f+" texture units while this GPU supports only "+a),T+=1,f},this.resetTextureUnits=function(){T=0},this.setTexture2D=L,this.setTexture2DArray=function(f,v){let t=s.get(f);if(f.version>0&&t.__version!==f.version){D(t,f,v);return}e.activeTexture(33984+v),e.bindTexture(35866,t.__webglTexture)},this.setTexture3D=function(f,v){let t=s.get(f);if(f.version>0&&t.__version!==f.version){D(t,f,v);return}e.activeTexture(33984+v),e.bindTexture(32879,t.__webglTexture)},this.setTextureCube=A,this.setupRenderTarget=function(v){let t=s.get(v),r=s.get(v.texture);v.addEventListener("dispose",E),r.__webglTexture=f.createTexture(),n.memory.textures++;let a=!0===v.isWebGLCubeRenderTarget,l=!0===v.isWebGLMultisampleRenderTarget,c=x(v)||o;if(o&&1022===v.texture.format&&(1015===v.texture.type||1016===v.texture.type)&&(v.texture.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),a){t.__webglFramebuffer=[];for(let v=0;v<6;v++)t.__webglFramebuffer[v]=f.createFramebuffer()}else if(t.__webglFramebuffer=f.createFramebuffer(),l){if(o){t.__webglMultisampledFramebuffer=f.createFramebuffer(),t.__webglColorRenderbuffer=f.createRenderbuffer(),f.bindRenderbuffer(36161,t.__webglColorRenderbuffer);let e=i.convert(v.texture.format),s=i.convert(v.texture.type),n=w(v.texture.internalFormat,e,s),r=z(v);f.renderbufferStorageMultisample(36161,r,n,v.width,v.height),f.bindFramebuffer(36160,t.__webglMultisampledFramebuffer),f.framebufferRenderbuffer(36160,36064,36161,t.__webglColorRenderbuffer),f.bindRenderbuffer(36161,null),v.depthBuffer&&(t.__webglDepthRenderbuffer=f.createRenderbuffer(),N(t.__webglDepthRenderbuffer,v,!0)),f.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}if(a){e.bindTexture(34067,r.__webglTexture),P(34067,v.texture,c);for(let f=0;f<6;f++)I(t.__webglFramebuffer[f],v,36064,34069+f);b(v.texture,c)&&_(34067,v.texture,v.width,v.height),e.bindTexture(34067,null)}else e.bindTexture(3553,r.__webglTexture),P(3553,v.texture,c),I(t.__webglFramebuffer,v,36064,3553),b(v.texture,c)&&_(3553,v.texture,v.width,v.height),e.bindTexture(3553,null);v.depthBuffer&&function(v){let e=s.get(v),t=!0===v.isWebGLCubeRenderTarget;if(v.depthTexture){if(t)throw Error("target.depthTexture not supported in Cube render targets");!function(v,e){if(e&&e.isWebGLCubeRenderTarget)throw Error("Depth Texture with cube render targets is not supported");if(f.bindFramebuffer(36160,v),!(e.depthTexture&&e.depthTexture.isDepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");s.get(e.depthTexture).__webglTexture&&e.depthTexture.image.width===e.width&&e.depthTexture.image.height===e.height||(e.depthTexture.image.width=e.width,e.depthTexture.image.height=e.height,e.depthTexture.needsUpdate=!0),L(e.depthTexture,0);let t=s.get(e.depthTexture).__webglTexture;if(1026===e.depthTexture.format)f.framebufferTexture2D(36160,36096,3553,t,0);else if(1027===e.depthTexture.format)f.framebufferTexture2D(36160,33306,3553,t,0);else throw Error("Unknown depthTexture format")}(e.__webglFramebuffer,v)}else if(t){e.__webglDepthbuffer=[];for(let s=0;s<6;s++)f.bindFramebuffer(36160,e.__webglFramebuffer[s]),e.__webglDepthbuffer[s]=f.createRenderbuffer(),N(e.__webglDepthbuffer[s],v,!1)}else f.bindFramebuffer(36160,e.__webglFramebuffer),e.__webglDepthbuffer=f.createRenderbuffer(),N(e.__webglDepthbuffer,v,!1);f.bindFramebuffer(36160,null)}(v)},this.updateRenderTargetMipmap=function(f){let v=f.texture;if(b(v,x(f)||o)){let t=f.isWebGLCubeRenderTarget?34067:3553,i=s.get(v).__webglTexture;e.bindTexture(t,i),_(t,v,f.width,f.height),e.bindTexture(t,null)}},this.updateMultisampleRenderTarget=function(v){if(v.isWebGLMultisampleRenderTarget){if(o){let e=s.get(v);f.bindFramebuffer(36008,e.__webglMultisampledFramebuffer),f.bindFramebuffer(36009,e.__webglFramebuffer);let t=v.width,i=v.height,n=16384;v.depthBuffer&&(n|=256),v.stencilBuffer&&(n|=1024),f.blitFramebuffer(0,0,t,i,0,0,t,i,n,9728),f.bindFramebuffer(36160,e.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}},this.safeSetTexture2D=function(f,v){f&&f.isWebGLRenderTarget&&(!1===H&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),H=!0),f=f.texture),L(f,v)},this.safeSetTextureCube=function(f,v){f&&f.isWebGLCubeRenderTarget&&(!1===F&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),F=!0),f=f.texture),A(f,v)}}function sw(f,v,e){let s=e.isWebGL2;return{convert:function(f){let e;if(1009===f)return 5121;if(1017===f)return 32819;if(1018===f)return 32820;if(1019===f)return 33635;if(1010===f)return 5120;if(1011===f)return 5122;if(1012===f)return 5123;if(1013===f)return 5124;if(1014===f)return 5125;if(1015===f)return 5126;if(1016===f)return s?5131:null!==(e=v.get("OES_texture_half_float"))?e.HALF_FLOAT_OES:null;if(1021===f)return 6406;if(1022===f)return 6407;if(1023===f)return 6408;if(1024===f)return 6409;if(1025===f)return 6410;if(1026===f)return 6402;if(1027===f)return 34041;if(1028===f)return 6403;if(1029===f)return 36244;if(1030===f)return 33319;if(1031===f)return 33320;if(1032===f)return 36248;if(1033===f)return 36249;if(33776===f||33777===f||33778===f||33779===f){if(null===(e=v.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===f)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===f)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===f)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===f)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===f||35841===f||35842===f||35843===f){if(null===(e=v.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===f)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===f)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===f)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===f)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===f)return null!==(e=v.get("WEBGL_compressed_texture_etc1"))?e.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===f||37496===f)&&null!==(e=v.get("WEBGL_compressed_texture_etc"))){if(37492===f)return e.COMPRESSED_RGB8_ETC2;if(37496===f)return e.COMPRESSED_RGBA8_ETC2_EAC}return 37808===f||37809===f||37810===f||37811===f||37812===f||37813===f||37814===f||37815===f||37816===f||37817===f||37818===f||37819===f||37820===f||37821===f||37840===f||37841===f||37842===f||37843===f||37844===f||37845===f||37846===f||37847===f||37848===f||37849===f||37850===f||37851===f||37852===f||37853===f?null!==(e=v.get("WEBGL_compressed_texture_astc"))?f:null:36492===f?null!==(e=v.get("EXT_texture_compression_bptc"))?f:null:1020===f?s?34042:null!==(e=v.get("WEBGL_depth_texture"))?e.UNSIGNED_INT_24_8_WEBGL:null:void 0}}}function sM(f=[]){vH.call(this),this.cameras=f}function sS(){fE.call(this),this.type="Group"}function sE(){this._targetRay=null,this._grip=null,this._hand=null}function sT(f,v){let e=this,s=null,t=1,i=null,n="local-floor",r=null,o=[],a=new Map,l=new vH;l.layers.enable(1),l.viewport=new M;let c=new vH;c.layers.enable(2),c.viewport=new M;let h=[l,c],u=new sM;u.layers.enable(1),u.layers.enable(2);let d=null,p=null;function m(f){let v=a.get(f.inputSource);v&&v.dispatchEvent({type:f.type,data:f.inputSource})}function g(){a.forEach(function(f,v){f.disconnect(v)}),a.clear(),d=null,p=null,f.setFramebuffer(null),f.setRenderTarget(f.getRenderTarget()),S.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}function y(f){let v=s.inputSources;for(let f=0;f<o.length;f++)a.set(v[f],o[f]);for(let v=0;v<f.removed.length;v++){let e=f.removed[v],s=a.get(e);s&&(s.dispatchEvent({type:"disconnected",data:e}),a.delete(e))}for(let v=0;v<f.added.length;v++){let e=f.added[v],s=a.get(e);s&&s.dispatchEvent({type:"connected",data:e})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(f){let v=o[f];return void 0===v&&(v=new sE,o[f]=v),v.getTargetRaySpace()},this.getControllerGrip=function(f){let v=o[f];return void 0===v&&(v=new sE,o[f]=v),v.getGripSpace()},this.getHand=function(f){let v=o[f];return void 0===v&&(v=new sE,o[f]=v),v.getHandSpace()},this.setFramebufferScaleFactor=function(f){t=f,!0===e.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(f){n=f,!0===e.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return s},this.setSession=async function(f){if(null!==(s=f)){s.addEventListener("select",m),s.addEventListener("selectstart",m),s.addEventListener("selectend",m),s.addEventListener("squeeze",m),s.addEventListener("squeezestart",m),s.addEventListener("squeezeend",m),s.addEventListener("end",g),s.addEventListener("inputsourceschange",y);let f=v.getContextAttributes();!0!==f.xrCompatible&&await v.makeXRCompatible();let r={antialias:f.antialias,alpha:f.alpha,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:t},o=new XRWebGLLayer(s,v,r);s.updateRenderState({baseLayer:o}),i=await s.requestReferenceSpace(n),S.setContext(s),S.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};let x=new T,b=new T;function _(f,v){null===v?f.matrixWorld.copy(f.matrix):f.matrixWorld.multiplyMatrices(v.matrixWorld,f.matrix),f.matrixWorldInverse.copy(f.matrixWorld).invert()}this.getCamera=function(f){u.near=c.near=l.near=f.near,u.far=c.far=l.far=f.far,(d!==u.near||p!==u.far)&&(s.updateRenderState({depthNear:u.near,depthFar:u.far}),d=u.near,p=u.far);let v=f.parent,e=u.cameras;_(u,v);for(let f=0;f<e.length;f++)_(e[f],v);f.matrixWorld.copy(u.matrixWorld),f.matrix.copy(u.matrix),f.matrix.decompose(f.position,f.quaternion,f.scale);let t=f.children;for(let f=0,v=t.length;f<v;f++)t[f].updateMatrixWorld(!0);return 2===e.length?function(f,v,e){x.setFromMatrixPosition(v.matrixWorld),b.setFromMatrixPosition(e.matrixWorld);let s=x.distanceTo(b),t=v.projectionMatrix.elements,i=e.projectionMatrix.elements,n=t[14]/(t[10]-1),r=t[14]/(t[10]+1),o=(t[9]+1)/t[5],a=(t[9]-1)/t[5],l=(t[8]-1)/t[0],c=(i[8]+1)/i[0],h=s/(-l+c),u=-(h*l);v.matrixWorld.decompose(f.position,f.quaternion,f.scale),f.translateX(u),f.translateZ(h),f.matrixWorld.compose(f.position,f.quaternion,f.scale),f.matrixWorldInverse.copy(f.matrixWorld).invert();let d=n+h,p=r+h;f.projectionMatrix.makePerspective(n*l-u,n*c+(s-u),o*r/p*d,a*r/p*d,d,p)}(u,l,c):u.projectionMatrix.copy(l.projectionMatrix),u};let w=null,S=new vW;S.setAnimationLoop(function(v,e){if(null!==(r=e.getViewerPose(i))){let v=r.views,e=s.renderState.baseLayer;f.setFramebuffer(e.framebuffer);let t=!1;v.length!==u.cameras.length&&(u.cameras.length=0,t=!0);for(let f=0;f<v.length;f++){let s=v[f],i=e.getViewport(s),n=h[f];n.matrix.fromArray(s.transform.matrix),n.projectionMatrix.fromArray(s.projectionMatrix),n.viewport.set(i.x,i.y,i.width,i.height),0===f&&u.matrix.copy(n.matrix),!0===t&&u.cameras.push(n)}}let t=s.inputSources;for(let f=0;f<o.length;f++){let v=o[f],s=t[f];v.update(s,e,i)}w&&w(v,e)}),this.setAnimationLoop=function(f){w=f},this.dispose=function(){}}function sL(f){function v(v,e){let s,t;v.opacity.value=e.opacity,e.color&&v.diffuse.value.copy(e.color),e.emissive&&v.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),e.map&&(v.map.value=e.map),e.alphaMap&&(v.alphaMap.value=e.alphaMap),e.specularMap&&(v.specularMap.value=e.specularMap);let i=f.get(e).envMap;if(i){v.envMap.value=i,v.flipEnvMap.value=i.isCubeTexture&&i._needsFlipEnvMap?-1:1,v.reflectivity.value=e.reflectivity,v.refractionRatio.value=e.refractionRatio;let s=f.get(i).__maxMipLevel;void 0!==s&&(v.maxMipLevel.value=s)}e.lightMap&&(v.lightMap.value=e.lightMap,v.lightMapIntensity.value=e.lightMapIntensity),e.aoMap&&(v.aoMap.value=e.aoMap,v.aoMapIntensity.value=e.aoMapIntensity),e.map?s=e.map:e.specularMap?s=e.specularMap:e.displacementMap?s=e.displacementMap:e.normalMap?s=e.normalMap:e.bumpMap?s=e.bumpMap:e.roughnessMap?s=e.roughnessMap:e.metalnessMap?s=e.metalnessMap:e.alphaMap?s=e.alphaMap:e.emissiveMap?s=e.emissiveMap:e.clearcoatMap?s=e.clearcoatMap:e.clearcoatNormalMap?s=e.clearcoatNormalMap:e.clearcoatRoughnessMap&&(s=e.clearcoatRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),v.uvTransform.value.copy(s.matrix)),e.aoMap?t=e.aoMap:e.lightMap&&(t=e.lightMap),void 0!==t&&(t.isWebGLRenderTarget&&(t=t.texture),!0===t.matrixAutoUpdate&&t.updateMatrix(),v.uv2Transform.value.copy(t.matrix))}function e(v,e){v.roughness.value=e.roughness,v.metalness.value=e.metalness,e.roughnessMap&&(v.roughnessMap.value=e.roughnessMap),e.metalnessMap&&(v.metalnessMap.value=e.metalnessMap),e.emissiveMap&&(v.emissiveMap.value=e.emissiveMap),e.bumpMap&&(v.bumpMap.value=e.bumpMap,v.bumpScale.value=e.bumpScale,1===e.side&&(v.bumpScale.value*=-1)),e.normalMap&&(v.normalMap.value=e.normalMap,v.normalScale.value.copy(e.normalScale),1===e.side&&v.normalScale.value.negate()),e.displacementMap&&(v.displacementMap.value=e.displacementMap,v.displacementScale.value=e.displacementScale,v.displacementBias.value=e.displacementBias),f.get(e).envMap&&(v.envMapIntensity.value=e.envMapIntensity)}return{refreshFogUniforms:function(f,v){f.fogColor.value.copy(v.color),v.isFog?(f.fogNear.value=v.near,f.fogFar.value=v.far):v.isFogExp2&&(f.fogDensity.value=v.density)},refreshMaterialUniforms:function(f,s,t,i){let n,r;s.isMeshBasicMaterial?v(f,s):s.isMeshLambertMaterial?(v(f,s),s.emissiveMap&&(f.emissiveMap.value=s.emissiveMap)):s.isMeshToonMaterial?(v(f,s),s.gradientMap&&(f.gradientMap.value=s.gradientMap),s.emissiveMap&&(f.emissiveMap.value=s.emissiveMap),s.bumpMap&&(f.bumpMap.value=s.bumpMap,f.bumpScale.value=s.bumpScale,1===s.side&&(f.bumpScale.value*=-1)),s.normalMap&&(f.normalMap.value=s.normalMap,f.normalScale.value.copy(s.normalScale),1===s.side&&f.normalScale.value.negate()),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias)):s.isMeshPhongMaterial?(v(f,s),f.specular.value.copy(s.specular),f.shininess.value=Math.max(s.shininess,1e-4),s.emissiveMap&&(f.emissiveMap.value=s.emissiveMap),s.bumpMap&&(f.bumpMap.value=s.bumpMap,f.bumpScale.value=s.bumpScale,1===s.side&&(f.bumpScale.value*=-1)),s.normalMap&&(f.normalMap.value=s.normalMap,f.normalScale.value.copy(s.normalScale),1===s.side&&f.normalScale.value.negate()),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias)):s.isMeshStandardMaterial?(v(f,s),s.isMeshPhysicalMaterial?(e(f,s),f.reflectivity.value=s.reflectivity,f.clearcoat.value=s.clearcoat,f.clearcoatRoughness.value=s.clearcoatRoughness,s.sheen&&f.sheen.value.copy(s.sheen),s.clearcoatMap&&(f.clearcoatMap.value=s.clearcoatMap),s.clearcoatRoughnessMap&&(f.clearcoatRoughnessMap.value=s.clearcoatRoughnessMap),s.clearcoatNormalMap&&(f.clearcoatNormalScale.value.copy(s.clearcoatNormalScale),f.clearcoatNormalMap.value=s.clearcoatNormalMap,1===s.side&&f.clearcoatNormalScale.value.negate()),f.transmission.value=s.transmission,s.transmissionMap&&(f.transmissionMap.value=s.transmissionMap)):e(f,s)):s.isMeshMatcapMaterial?(v(f,s),s.matcap&&(f.matcap.value=s.matcap),s.bumpMap&&(f.bumpMap.value=s.bumpMap,f.bumpScale.value=s.bumpScale,1===s.side&&(f.bumpScale.value*=-1)),s.normalMap&&(f.normalMap.value=s.normalMap,f.normalScale.value.copy(s.normalScale),1===s.side&&f.normalScale.value.negate()),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias)):s.isMeshDepthMaterial?(v(f,s),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias)):s.isMeshDistanceMaterial?(v(f,s),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias),f.referencePosition.value.copy(s.referencePosition),f.nearDistance.value=s.nearDistance,f.farDistance.value=s.farDistance):s.isMeshNormalMaterial?(v(f,s),s.bumpMap&&(f.bumpMap.value=s.bumpMap,f.bumpScale.value=s.bumpScale,1===s.side&&(f.bumpScale.value*=-1)),s.normalMap&&(f.normalMap.value=s.normalMap,f.normalScale.value.copy(s.normalScale),1===s.side&&f.normalScale.value.negate()),s.displacementMap&&(f.displacementMap.value=s.displacementMap,f.displacementScale.value=s.displacementScale,f.displacementBias.value=s.displacementBias)):s.isLineBasicMaterial?(f.diffuse.value.copy(s.color),f.opacity.value=s.opacity,s.isLineDashedMaterial&&(f.dashSize.value=s.dashSize,f.totalSize.value=s.dashSize+s.gapSize,f.scale.value=s.scale)):s.isPointsMaterial?(f.diffuse.value.copy(s.color),f.opacity.value=s.opacity,f.size.value=s.size*t,f.scale.value=.5*i,s.map&&(f.map.value=s.map),s.alphaMap&&(f.alphaMap.value=s.alphaMap),s.map?n=s.map:s.alphaMap&&(n=s.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),f.uvTransform.value.copy(n.matrix))):s.isSpriteMaterial?(f.diffuse.value.copy(s.color),f.opacity.value=s.opacity,f.rotation.value=s.rotation,s.map&&(f.map.value=s.map),s.alphaMap&&(f.alphaMap.value=s.alphaMap),s.map?r=s.map:s.alphaMap&&(r=s.alphaMap),void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),f.uvTransform.value.copy(r.matrix))):s.isShadowMaterial?(f.color.value.copy(s.color),f.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function sA(f){let v,e,s,t,i,n,r,o,a,l,c,h,u,d,p,y,x,b,_,w,S;let E=void 0!==(f=f||{}).canvas?f.canvas:function(){let f=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return f.style.display="block",f}(),L=void 0!==f.context?f.context:null,A=void 0!==f.alpha&&f.alpha,R=void 0===f.depth||f.depth,C=void 0===f.stencil||f.stencil,P=void 0!==f.antialias&&f.antialias,O=void 0===f.premultipliedAlpha||f.premultipliedAlpha,D=void 0!==f.preserveDrawingBuffer&&f.preserveDrawingBuffer,I=void 0!==f.powerPreference?f.powerPreference:"default",N=void 0!==f.failIfMajorPerformanceCaveat&&f.failIfMajorPerformanceCaveat,z=null,H=null,F=[];this.domElement=E,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;let B=this,U=!1,k=null,G=0,j=0,V=null,W=null,q=-1,X=null,Y=new M,Z=new M,J=null,$=E.width,Q=E.height,K=1,fv=null,fe=null,fs=new M(0,0,$,Q),ft=new M(0,0,$,Q),fi=!1,fn=new vV,fr=!1,fo=!1,fa=new ff,fl=new T,fc={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function fh(){return null===V?K:1}let fu=L;function fd(f,v){for(let e=0;e<f.length;e++){let s=f[e],t=E.getContext(s,v);if(null!==t)return t}return null}try{if(E.addEventListener("webglcontextlost",fy,!1),E.addEventListener("webglcontextrestored",fx,!1),null===fu){let f=["webgl2","webgl","experimental-webgl"];if(!0===B.isWebGL1Renderer&&f.shift(),fu=fd(f,{alpha:A,depth:R,stencil:C,antialias:P,premultipliedAlpha:O,preserveDrawingBuffer:D,powerPreference:I,failIfMajorPerformanceCaveat:N}),null===fu){if(fd(f))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.")}}void 0===fu.getShaderPrecisionFormat&&(fu.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(f){throw console.error("THREE.WebGLRenderer: "+f.message),f}function fp(){v=new v4(fu),e=new v1(fu,v,f),v.init(e),w=new sw(fu,v,e),(s=new sb(fu,v,e)).scissor(Z.copy(ft).multiplyScalar(K).floor()),s.viewport(Y.copy(fs).multiplyScalar(K).floor()),t=new v5(fu),i=new sn,n=new s_(fu,v,s,i,e,w,t),r=new v3(B),o=new vq(fu,e),S=new vQ(fu,v,o,e),a=new v0(fu,o,t,S),l=new ef(fu,a,o,t),x=new v9(fu),p=new v2(i),c=new si(B,r,v,e,S,p),h=new sL(i),u=new sl(i),d=new sm(v,e),y=new v$(B,r,s,l,O),b=new vK(fu,v,t,e),_=new v6(fu,v,t,e),t.programs=c.programs,B.capabilities=e,B.extensions=v,B.properties=i,B.renderLists=u,B.state=s,B.info=t}fp();let fm=new sT(B,fu);this.xr=fm;let fg=new sx(B,l,e.maxTextureSize);function fy(f){f.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),U=!0}function fx(){console.log("THREE.WebGLRenderer: Context Restored."),U=!1,fp()}function fb(f){let v=f.target;v.removeEventListener("dispose",fb),f_(v),i.remove(v)}function f_(f){let v=i.get(f).program;void 0!==v&&c.releaseProgram(v)}this.shadowMap=fg,this.getContext=function(){return fu},this.getContextAttributes=function(){return fu.getContextAttributes()},this.forceContextLoss=function(){let f=v.get("WEBGL_lose_context");f&&f.loseContext()},this.forceContextRestore=function(){let f=v.get("WEBGL_lose_context");f&&f.restoreContext()},this.getPixelRatio=function(){return K},this.setPixelRatio=function(f){void 0!==f&&(K=f,this.setSize($,Q,!1))},this.getSize=function(f){return void 0===f&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),f=new g),f.set($,Q)},this.setSize=function(f,v,e){if(fm.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}$=f,Q=v,E.width=Math.floor(f*K),E.height=Math.floor(v*K),!1!==e&&(E.style.width=f+"px",E.style.height=v+"px"),this.setViewport(0,0,f,v)},this.getDrawingBufferSize=function(f){return void 0===f&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),f=new g),f.set($*K,Q*K).floor()},this.setDrawingBufferSize=function(f,v,e){$=f,Q=v,K=e,E.width=Math.floor(f*e),E.height=Math.floor(v*e),this.setViewport(0,0,f,v)},this.getCurrentViewport=function(f){return void 0===f&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),f=new M),f.copy(Y)},this.getViewport=function(f){return f.copy(fs)},this.setViewport=function(f,v,e,t){f.isVector4?fs.set(f.x,f.y,f.z,f.w):fs.set(f,v,e,t),s.viewport(Y.copy(fs).multiplyScalar(K).floor())},this.getScissor=function(f){return f.copy(ft)},this.setScissor=function(f,v,e,t){f.isVector4?ft.set(f.x,f.y,f.z,f.w):ft.set(f,v,e,t),s.scissor(Z.copy(ft).multiplyScalar(K).floor())},this.getScissorTest=function(){return fi},this.setScissorTest=function(f){s.setScissorTest(fi=f)},this.setOpaqueSort=function(f){fv=f},this.setTransparentSort=function(f){fe=f},this.getClearColor=function(f){return void 0===f&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),f=new fX),f.copy(y.getClearColor())},this.setClearColor=function(){y.setClearColor.apply(y,arguments)},this.getClearAlpha=function(){return y.getClearAlpha()},this.setClearAlpha=function(){y.setClearAlpha.apply(y,arguments)},this.clear=function(f,v,e){let s=0;(void 0===f||f)&&(s|=16384),(void 0===v||v)&&(s|=256),(void 0===e||e)&&(s|=1024),fu.clear(s)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){E.removeEventListener("webglcontextlost",fy,!1),E.removeEventListener("webglcontextrestored",fx,!1),u.dispose(),d.dispose(),i.dispose(),r.dispose(),l.dispose(),S.dispose(),fm.dispose(),fM.stop()},this.renderBufferImmediate=function(f,v){S.initAttributes();let e=i.get(f);f.hasPositions&&!e.position&&(e.position=fu.createBuffer()),f.hasNormals&&!e.normal&&(e.normal=fu.createBuffer()),f.hasUvs&&!e.uv&&(e.uv=fu.createBuffer()),f.hasColors&&!e.color&&(e.color=fu.createBuffer());let s=v.getAttributes();f.hasPositions&&(fu.bindBuffer(34962,e.position),fu.bufferData(34962,f.positionArray,35048),S.enableAttribute(s.position),fu.vertexAttribPointer(s.position,3,5126,!1,0,0)),f.hasNormals&&(fu.bindBuffer(34962,e.normal),fu.bufferData(34962,f.normalArray,35048),S.enableAttribute(s.normal),fu.vertexAttribPointer(s.normal,3,5126,!1,0,0)),f.hasUvs&&(fu.bindBuffer(34962,e.uv),fu.bufferData(34962,f.uvArray,35048),S.enableAttribute(s.uv),fu.vertexAttribPointer(s.uv,2,5126,!1,0,0)),f.hasColors&&(fu.bindBuffer(34962,e.color),fu.bufferData(34962,f.colorArray,35048),S.enableAttribute(s.color),fu.vertexAttribPointer(s.color,3,5126,!1,0,0)),S.disableUnusedAttributes(),fu.drawArrays(4,0,f.count),f.count=0},this.renderBufferDirect=function(f,v,e,t,i,n){let r;null===v&&(v=fc);let l=i.isMesh&&0>i.matrixWorld.determinant(),c=fL(f,v,t,i);s.setMaterial(t,l);let h=e.index,u=e.attributes.position;if(null===h){if(void 0===u||0===u.count)return}else if(0===h.count)return;let d=1;!0===t.wireframe&&(h=a.getWireframeAttribute(e),d=2),(t.morphTargets||t.morphNormals)&&x.update(i,e,t,c),S.setup(i,t,c,e,h);let p=b;null!==h&&(r=o.get(h),(p=_).setIndex(r));let m=null!==h?h.count:u.count,g=e.drawRange.start*d,y=e.drawRange.count*d,w=null!==n?n.start*d:0,M=null!==n?n.count*d:1/0,E=Math.max(g,w),T=Math.max(0,Math.min(m,g+y,w+M)-1-E+1);if(0!==T){if(i.isMesh)!0===t.wireframe?(s.setLineWidth(t.wireframeLinewidth*fh()),p.setMode(1)):p.setMode(4);else if(i.isLine){let f=t.linewidth;void 0===f&&(f=1),s.setLineWidth(f*fh()),i.isLineSegments?p.setMode(1):i.isLineLoop?p.setMode(2):p.setMode(3)}else i.isPoints?p.setMode(0):i.isSprite&&p.setMode(4);if(i.isInstancedMesh)p.renderInstances(E,T,i.count);else if(e.isInstancedBufferGeometry){let f=Math.min(e.instanceCount,e._maxInstanceCount);p.renderInstances(E,T,f)}else p.render(E,T)}},this.compile=function(f,v){(H=d.get(f)).init(),f.traverseVisible(function(f){f.isLight&&f.layers.test(v.layers)&&(H.pushLight(f),f.castShadow&&H.pushShadow(f))}),H.setupLights();let e=new WeakMap;f.traverse(function(v){let s=v.material;if(s){if(Array.isArray(s))for(let t=0;t<s.length;t++){let i=s[t];!1===e.has(i)&&(fT(i,f,v),e.set(i))}else!1===e.has(s)&&(fT(s,f,v),e.set(s))}})};let fw=null,fM=new vW;function fS(f,v,e){let t=!0===v.isScene?v.overrideMaterial:null;for(let i=0,n=f.length;i<n;i++){let n=f[i],r=n.object,o=n.geometry,a=null===t?n.material:t,l=n.group;if(e.isArrayCamera){let f=e.cameras;for(let e=0,t=f.length;e<t;e++){let t=f[e];r.layers.test(t.layers)&&(s.viewport(Y.copy(t.viewport)),H.setupLightsView(t),fE(r,v,t,o,a,l))}}else fE(r,v,e,o,a,l)}}function fE(f,v,e,t,i,n){if(f.onBeforeRender(B,v,e,t,i,n),f.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,f.matrixWorld),f.normalMatrix.getNormalMatrix(f.modelViewMatrix),f.isImmediateRenderObject){let t=fL(e,v,i,f);s.setMaterial(i),S.reset(),function(f,v){f.render(function(f){B.renderBufferImmediate(f,v)})}(f,t)}else B.renderBufferDirect(e,v,t,i,f,n);f.onAfterRender(B,v,e,t,i,n)}function fT(f,v,e){!0!==v.isScene&&(v=fc);let s=i.get(f),t=H.state.lights,n=H.state.shadowsArray,o=t.state.version,a=c.getParameters(f,t.state,n,v,e),l=c.getProgramCacheKey(a),h=s.program,u=!0;if(s.environment=f.isMeshStandardMaterial?v.environment:null,s.fog=v.fog,s.envMap=r.get(f.envMap||s.environment),void 0===h)f.addEventListener("dispose",fb);else if(h.cacheKey!==l)f_(f);else if(s.lightsStateVersion!==o)u=!1;else{if(void 0!==a.shaderID)return;u=!1}u&&(a.uniforms=c.getUniforms(f),f.onBeforeCompile(a,B),h=c.acquireProgram(a,l),s.program=h,s.uniforms=a.uniforms,s.outputEncoding=a.outputEncoding);let d=s.uniforms;(f.isShaderMaterial||f.isRawShaderMaterial)&&!0!==f.clipping||(s.numClippingPlanes=p.numPlanes,s.numIntersection=p.numIntersection,d.clippingPlanes=p.uniform),s.needsLights=f.isMeshLambertMaterial||f.isMeshToonMaterial||f.isMeshPhongMaterial||f.isMeshStandardMaterial||f.isShadowMaterial||f.isShaderMaterial&&!0===f.lights,s.lightsStateVersion=o,s.needsLights&&(d.ambientLightColor.value=t.state.ambient,d.lightProbe.value=t.state.probe,d.directionalLights.value=t.state.directional,d.directionalLightShadows.value=t.state.directionalShadow,d.spotLights.value=t.state.spot,d.spotLightShadows.value=t.state.spotShadow,d.rectAreaLights.value=t.state.rectArea,d.ltc_1.value=t.state.rectAreaLTC1,d.ltc_2.value=t.state.rectAreaLTC2,d.pointLights.value=t.state.point,d.pointLightShadows.value=t.state.pointShadow,d.hemisphereLights.value=t.state.hemi,d.directionalShadowMap.value=t.state.directionalShadowMap,d.directionalShadowMatrix.value=t.state.directionalShadowMatrix,d.spotShadowMap.value=t.state.spotShadowMap,d.spotShadowMatrix.value=t.state.spotShadowMatrix,d.pointShadowMap.value=t.state.pointShadowMap,d.pointShadowMatrix.value=t.state.pointShadowMatrix);let m=s.program.getUniforms(),g=eJ.seqWithValue(m.seq,d);s.uniformsList=g}function fL(f,v,t,o){var a;!0!==v.isScene&&(v=fc),n.resetTextureUnits();let l=v.fog,c=t.isMeshStandardMaterial?v.environment:null,u=null===V?B.outputEncoding:V.texture.encoding,d=r.get(t.envMap||c),g=i.get(t),y=H.state.lights;if(!0===fr&&(!0===fo||f!==X)){let v=f===X&&t.id===q;p.setState(t,f,v)}t.version===g.__version?t.fog&&g.fog!==l?fT(t,v,o):g.environment!==c?fT(t,v,o):g.needsLights&&g.lightsStateVersion!==y.state.version?fT(t,v,o):void 0!==g.numClippingPlanes&&(g.numClippingPlanes!==p.numPlanes||g.numIntersection!==p.numIntersection)?fT(t,v,o):g.outputEncoding!==u?fT(t,v,o):g.envMap!==d&&fT(t,v,o):(fT(t,v,o),g.__version=t.version);let x=!1,b=!1,_=!1,w=g.program,M=w.getUniforms(),S=g.uniforms;if(s.useProgram(w.program)&&(x=!0,b=!0,_=!0),t.id!==q&&(q=t.id,b=!0),x||X!==f){if(M.setValue(fu,"projectionMatrix",f.projectionMatrix),e.logarithmicDepthBuffer&&M.setValue(fu,"logDepthBufFC",2/(Math.log(f.far+1)/Math.LN2)),X!==f&&(X=f,b=!0,_=!0),t.isShaderMaterial||t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshStandardMaterial||t.envMap){let v=M.map.cameraPosition;void 0!==v&&v.setValue(fu,fl.setFromMatrixPosition(f.matrixWorld))}(t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshLambertMaterial||t.isMeshBasicMaterial||t.isMeshStandardMaterial||t.isShaderMaterial)&&M.setValue(fu,"isOrthographic",!0===f.isOrthographicCamera),(t.isMeshPhongMaterial||t.isMeshToonMaterial||t.isMeshLambertMaterial||t.isMeshBasicMaterial||t.isMeshStandardMaterial||t.isShaderMaterial||t.isShadowMaterial||t.skinning)&&M.setValue(fu,"viewMatrix",f.matrixWorldInverse)}if(t.skinning){M.setOptional(fu,o,"bindMatrix"),M.setOptional(fu,o,"bindMatrixInverse");let f=o.skeleton;if(f){let v=f.bones;if(e.floatVertexTextures){if(null===f.boneTexture){let e=Math.sqrt(4*v.length),s=new Float32Array((e=Math.max(e=m.ceilPowerOfTwo(e),4))*e*4);s.set(f.boneMatrices);let t=new vk(s,e,e,1023,1015);f.boneMatrices=s,f.boneTexture=t,f.boneTextureSize=e}M.setValue(fu,"boneTexture",f.boneTexture,n),M.setValue(fu,"boneTextureSize",f.boneTextureSize)}else M.setOptional(fu,f,"boneMatrices")}}return(b||g.receiveShadow!==o.receiveShadow)&&(g.receiveShadow=o.receiveShadow,M.setValue(fu,"receiveShadow",o.receiveShadow)),b&&(M.setValue(fu,"toneMappingExposure",B.toneMappingExposure),g.needsLights&&(a=_,S.ambientLightColor.needsUpdate=a,S.lightProbe.needsUpdate=a,S.directionalLights.needsUpdate=a,S.directionalLightShadows.needsUpdate=a,S.pointLights.needsUpdate=a,S.pointLightShadows.needsUpdate=a,S.spotLights.needsUpdate=a,S.spotLightShadows.needsUpdate=a,S.rectAreaLights.needsUpdate=a,S.hemisphereLights.needsUpdate=a),l&&t.fog&&h.refreshFogUniforms(S,l),h.refreshMaterialUniforms(S,t,K,Q),eJ.upload(fu,g.uniformsList,S,n)),t.isShaderMaterial&&!0===t.uniformsNeedUpdate&&(eJ.upload(fu,g.uniformsList,S,n),t.uniformsNeedUpdate=!1),t.isSpriteMaterial&&M.setValue(fu,"center",o.center),M.setValue(fu,"modelViewMatrix",o.modelViewMatrix),M.setValue(fu,"normalMatrix",o.normalMatrix),M.setValue(fu,"modelMatrix",o.matrixWorld),w}fM.setAnimationLoop(function(f){!fm.isPresenting&&fw&&fw(f)}),"undefined"!=typeof window&&fM.setContext(window),this.setAnimationLoop=function(f){fw=f,fm.setAnimationLoop(f),null===f?fM.stop():fM.start()},this.render=function(f,v){let e,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),e=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0!==v&&!0!==v.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===U)return;S.resetDefaultState(),q=-1,X=null,!0===f.autoUpdate&&f.updateMatrixWorld(),null===v.parent&&v.updateMatrixWorld(),!0===fm.enabled&&!0===fm.isPresenting&&(v=fm.getCamera(v)),!0===f.isScene&&f.onBeforeRender(B,f,v,e||V),(H=d.get(f,F.length)).init(),F.push(H),fa.multiplyMatrices(v.projectionMatrix,v.matrixWorldInverse),fn.setFromProjectionMatrix(fa),fo=this.localClippingEnabled,fr=p.init(this.clippingPlanes,fo,v),(z=u.get(f,v)).init(),function f(v,e,s,i){if(!1===v.visible)return;if(v.layers.test(e.layers)){if(v.isGroup)s=v.renderOrder;else if(v.isLOD)!0===v.autoUpdate&&v.update(e);else if(v.isLight)H.pushLight(v),v.castShadow&&H.pushShadow(v);else if(v.isSprite){if(!v.frustumCulled||fn.intersectsSprite(v)){i&&fl.setFromMatrixPosition(v.matrixWorld).applyMatrix4(fa);let f=l.update(v),e=v.material;e.visible&&z.push(v,f,e,s,fl.z,null)}}else if(v.isImmediateRenderObject)i&&fl.setFromMatrixPosition(v.matrixWorld).applyMatrix4(fa),z.push(v,null,v.material,s,fl.z,null);else if((v.isMesh||v.isLine||v.isPoints)&&(v.isSkinnedMesh&&v.skeleton.frame!==t.render.frame&&(v.skeleton.update(),v.skeleton.frame=t.render.frame),!v.frustumCulled||fn.intersectsObject(v))){i&&fl.setFromMatrixPosition(v.matrixWorld).applyMatrix4(fa);let f=l.update(v),e=v.material;if(Array.isArray(e)){let t=f.groups;for(let i=0,n=t.length;i<n;i++){let n=t[i],r=e[n.materialIndex];r&&r.visible&&z.push(v,f,r,s,fl.z,n)}}else e.visible&&z.push(v,f,e,s,fl.z,null)}}let n=v.children;for(let v=0,t=n.length;v<t;v++)f(n[v],e,s,i)}(f,v,0,B.sortObjects),z.finish(),!0===B.sortObjects&&z.sort(fv,fe),!0===fr&&p.beginShadows();let r=H.state.shadowsArray;fg.render(r,f,v),H.setupLights(),H.setupLightsView(v),!0===fr&&p.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==e&&this.setRenderTarget(e),y.render(z,f,v,i);let o=z.opaque,a=z.transparent;o.length>0&&fS(o,f,v),a.length>0&&fS(a,f,v),!0===f.isScene&&f.onAfterRender(B,f,v),null!==V&&(n.updateRenderTargetMipmap(V),n.updateMultisampleRenderTarget(V)),s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),s.setPolygonOffset(!1),F.pop(),H=F.length>0?F[F.length-1]:null,z=null},this.setFramebuffer=function(f){k!==f&&null===V&&fu.bindFramebuffer(36160,f),k=f},this.getActiveCubeFace=function(){return G},this.getActiveMipmapLevel=function(){return j},this.getRenderList=function(){return z},this.setRenderList=function(f){z=f},this.getRenderTarget=function(){return V},this.setRenderTarget=function(f,v=0,e=0){V=f,G=v,j=e,f&&void 0===i.get(f).__webglFramebuffer&&n.setupRenderTarget(f);let t=k,r=!1;if(f){let e=i.get(f).__webglFramebuffer;f.isWebGLCubeRenderTarget?(t=e[v],r=!0):t=f.isWebGLMultisampleRenderTarget?i.get(f).__webglMultisampledFramebuffer:e,Y.copy(f.viewport),Z.copy(f.scissor),J=f.scissorTest}else Y.copy(fs).multiplyScalar(K).floor(),Z.copy(ft).multiplyScalar(K).floor(),J=fi;if(W!==t&&(fu.bindFramebuffer(36160,t),W=t),s.viewport(Y),s.scissor(Z),s.setScissorTest(J),r){let s=i.get(f.texture);fu.framebufferTexture2D(36160,36064,34069+v,s.__webglTexture,e)}},this.readRenderTargetPixels=function(f,s,t,n,r,o,a){if(!(f&&f.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let l=i.get(f).__webglFramebuffer;if(f.isWebGLCubeRenderTarget&&void 0!==a&&(l=l[a]),l){let i=!1;l!==W&&(fu.bindFramebuffer(36160,l),i=!0);try{let i=f.texture,a=i.format,l=i.type;if(1023!==a&&w.convert(a)!==fu.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}let c=1016===l&&(v.has("EXT_color_buffer_half_float")||e.isWebGL2&&v.has("EXT_color_buffer_float"));if(1009!==l&&w.convert(l)!==fu.getParameter(35738)&&!(1015===l&&(e.isWebGL2||v.has("OES_texture_float")||v.has("WEBGL_color_buffer_float")))&&!c){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}36053===fu.checkFramebufferStatus(36160)?s>=0&&s<=f.width-n&&t>=0&&t<=f.height-r&&fu.readPixels(s,t,n,r,w.convert(a),w.convert(l),o):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{i&&fu.bindFramebuffer(36160,W)}}},this.copyFramebufferToTexture=function(f,v,e=0){let t=Math.pow(2,-e),i=Math.floor(v.image.width*t),r=Math.floor(v.image.height*t),o=w.convert(v.format);n.setTexture2D(v,0),fu.copyTexImage2D(3553,e,o,f.x,f.y,i,r,0),s.unbindTexture()},this.copyTextureToTexture=function(f,v,e,t=0){let i=v.image.width,r=v.image.height,o=w.convert(e.format),a=w.convert(e.type);n.setTexture2D(e,0),fu.pixelStorei(37440,e.flipY),fu.pixelStorei(37441,e.premultiplyAlpha),fu.pixelStorei(3317,e.unpackAlignment),v.isDataTexture?fu.texSubImage2D(3553,t,f.x,f.y,i,r,o,a,v.image.data):v.isCompressedTexture?fu.compressedTexSubImage2D(3553,t,f.x,f.y,v.mipmaps[0].width,v.mipmaps[0].height,o,v.mipmaps[0].data):fu.texSubImage2D(3553,t,f.x,f.y,o,a,v.image),0===t&&e.generateMipmaps&&fu.generateMipmap(3553),s.unbindTexture()},this.initTexture=function(f){n.setTexture2D(f,0),s.unbindTexture()},this.resetState=function(){s.reset(),S.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function sR(f){sA.call(this,f)}sg.prototype=Object.create(fJ.prototype),sg.prototype.constructor=sg,sg.prototype.isMeshDepthMaterial=!0,sg.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.depthPacking=f.depthPacking,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.map=f.map,this.alphaMap=f.alphaMap,this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this},sy.prototype=Object.create(fJ.prototype),sy.prototype.constructor=sy,sy.prototype.isMeshDistanceMaterial=!0,sy.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.referencePosition.copy(f.referencePosition),this.nearDistance=f.nearDistance,this.farDistance=f.farDistance,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.map=f.map,this.alphaMap=f.alphaMap,this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this},sM.prototype=Object.assign(Object.create(vH.prototype),{constructor:sM,isArrayCamera:!0}),sS.prototype=Object.assign(Object.create(fE.prototype),{constructor:sS,isGroup:!0}),Object.assign(sE.prototype,{constructor:sE,getHandSpace:function(){return null===this._hand&&(this._hand=new sS,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new sS,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new sS,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(f){return null!==this._targetRay&&this._targetRay.dispatchEvent(f),null!==this._grip&&this._grip.dispatchEvent(f),null!==this._hand&&this._hand.dispatchEvent(f),this},disconnect:function(f){return this.dispatchEvent({type:"disconnected",data:f}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(f,v,e){let s=null,t=null,i=null,n=this._targetRay,r=this._grip,o=this._hand;if(f&&"visible-blurred"!==v.session.visibilityState){if(o&&f.hand){for(let s of(i=!0,f.hand.values())){let f=v.getJointPose(s,e);if(void 0===o.joints[s.jointName]){let f=new sS;f.matrixAutoUpdate=!1,f.visible=!1,o.joints[s.jointName]=f,o.add(f)}let t=o.joints[s.jointName];null!==f&&(t.matrix.fromArray(f.transform.matrix),t.matrix.decompose(t.position,t.rotation,t.scale),t.jointRadius=f.radius),t.visible=null!==f}let s=o.joints["index-finger-tip"],t=o.joints["thumb-tip"],n=s.position.distanceTo(t.position);o.inputState.pinching&&n>.025?(o.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:f.handedness,target:this})):!o.inputState.pinching&&n<=.015&&(o.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:f.handedness,target:this}))}else null!==n&&null!==(s=v.getPose(f.targetRaySpace,e))&&(n.matrix.fromArray(s.transform.matrix),n.matrix.decompose(n.position,n.rotation,n.scale)),null!==r&&f.gripSpace&&null!==(t=v.getPose(f.gripSpace,e))&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale))}return null!==n&&(n.visible=null!==s),null!==r&&(r.visible=null!==t),null!==o&&(o.visible=null!==i),this}}),Object.assign(sT.prototype,u.prototype),sR.prototype=Object.assign(Object.create(sA.prototype),{constructor:sR,isWebGL1Renderer:!0});class sC{constructor(f,v,e){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new fX(f),this.near=void 0!==v?v:1,this.far=void 0!==e?e:1e3}clone(){return new sC(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class sP extends fE{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(f,v){return super.copy(f,v),null!==f.background&&(this.background=f.background.clone()),null!==f.environment&&(this.environment=f.environment.clone()),null!==f.fog&&(this.fog=f.fog.clone()),null!==f.overrideMaterial&&(this.overrideMaterial=f.overrideMaterial.clone()),this.autoUpdate=f.autoUpdate,this.matrixAutoUpdate=f.matrixAutoUpdate,this}toJSON(f){let v=super.toJSON(f);return null!==this.background&&(v.object.background=this.background.toJSON(f)),null!==this.environment&&(v.object.environment=this.environment.toJSON(f)),null!==this.fog&&(v.object.fog=this.fog.toJSON()),v}}function sO(f,v){this.array=f,this.stride=v,this.count=void 0!==f?f.length/v:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=m.generateUUID()}Object.defineProperty(sO.prototype,"needsUpdate",{set:function(f){!0===f&&this.version++}}),Object.assign(sO.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(f){return this.usage=f,this},copy:function(f){return this.array=new f.array.constructor(f.array),this.count=f.count,this.stride=f.stride,this.usage=f.usage,this},copyAt:function(f,v,e){f*=this.stride,e*=v.stride;for(let s=0,t=this.stride;s<t;s++)this.array[f+s]=v.array[e+s];return this},set:function(f,v=0){return this.array.set(f,v),this},clone:function(f){void 0===f.arrayBuffers&&(f.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=m.generateUUID()),void 0===f.arrayBuffers[this.array.buffer._uuid]&&(f.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let v=new sO(new this.array.constructor(f.arrayBuffers[this.array.buffer._uuid]),this.stride);return v.setUsage(this.usage),v},onUpload:function(f){return this.onUploadCallback=f,this},toJSON:function(f){return void 0===f.arrayBuffers&&(f.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=m.generateUUID()),void 0===f.arrayBuffers[this.array.buffer._uuid]&&(f.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});let sD=new T;function sI(f,v,e,s){this.name="",this.data=f,this.itemSize=v,this.offset=e,this.normalized=!0===s}function sN(f){fJ.call(this),this.type="SpriteMaterial",this.color=new fX(0xffffff),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(f)}Object.defineProperties(sI.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(f){this.data.needsUpdate=f}}}),Object.assign(sI.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(f){for(let v=0,e=this.data.count;v<e;v++)sD.x=this.getX(v),sD.y=this.getY(v),sD.z=this.getZ(v),sD.applyMatrix4(f),this.setXYZ(v,sD.x,sD.y,sD.z);return this},setX:function(f,v){return this.data.array[f*this.data.stride+this.offset]=v,this},setY:function(f,v){return this.data.array[f*this.data.stride+this.offset+1]=v,this},setZ:function(f,v){return this.data.array[f*this.data.stride+this.offset+2]=v,this},setW:function(f,v){return this.data.array[f*this.data.stride+this.offset+3]=v,this},getX:function(f){return this.data.array[f*this.data.stride+this.offset]},getY:function(f){return this.data.array[f*this.data.stride+this.offset+1]},getZ:function(f){return this.data.array[f*this.data.stride+this.offset+2]},getW:function(f){return this.data.array[f*this.data.stride+this.offset+3]},setXY:function(f,v,e){return f=f*this.data.stride+this.offset,this.data.array[f+0]=v,this.data.array[f+1]=e,this},setXYZ:function(f,v,e,s){return f=f*this.data.stride+this.offset,this.data.array[f+0]=v,this.data.array[f+1]=e,this.data.array[f+2]=s,this},setXYZW:function(f,v,e,s,t){return f=f*this.data.stride+this.offset,this.data.array[f+0]=v,this.data.array[f+1]=e,this.data.array[f+2]=s,this.data.array[f+3]=t,this},clone:function(f){if(void 0!==f)return void 0===f.interleavedBuffers&&(f.interleavedBuffers={}),void 0===f.interleavedBuffers[this.data.uuid]&&(f.interleavedBuffers[this.data.uuid]=this.data.clone(f)),new sI(f.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");let f=[];for(let v=0;v<this.count;v++){let e=v*this.data.stride+this.offset;for(let v=0;v<this.itemSize;v++)f.push(this.data.array[e+v])}return new f1(new this.array.constructor(f),this.itemSize,this.normalized)}},toJSON:function(f){if(void 0!==f)return void 0===f.interleavedBuffers&&(f.interleavedBuffers={}),void 0===f.interleavedBuffers[this.data.uuid]&&(f.interleavedBuffers[this.data.uuid]=this.data.toJSON(f)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");let f=[];for(let v=0;v<this.count;v++){let e=v*this.data.stride+this.offset;for(let v=0;v<this.itemSize;v++)f.push(this.data.array[e+v])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:f,normalized:this.normalized}}}}),sN.prototype=Object.create(fJ.prototype),sN.prototype.constructor=sN,sN.prototype.isSpriteMaterial=!0,sN.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.map=f.map,this.alphaMap=f.alphaMap,this.rotation=f.rotation,this.sizeAttenuation=f.sizeAttenuation,this};let sz=new T,sH=new T,sF=new T,sB=new g,sU=new g,sk=new ff,sG=new T,sj=new T,sV=new T,sW=new g,sq=new g,sX=new g;function sY(f){if(fE.call(this),this.type="Sprite",void 0===t){t=new vc;let f=new sO(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);t.setIndex([0,1,2,0,2,3]),t.setAttribute("position",new sI(f,3,0,!1)),t.setAttribute("uv",new sI(f,2,3,!1))}this.geometry=t,this.material=void 0!==f?f:new sN,this.center=new g(.5,.5)}function sZ(f,v,e,s,t,i){sB.subVectors(f,e).addScalar(.5).multiply(s),void 0!==t?(sU.x=i*sB.x-t*sB.y,sU.y=t*sB.x+i*sB.y):sU.copy(sB),f.copy(v),f.x+=sU.x,f.y+=sU.y,f.applyMatrix4(sk)}sY.prototype=Object.assign(Object.create(fE.prototype),{constructor:sY,isSprite:!0,raycast:function(f,v){let e,s;null===f.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),sH.setFromMatrixScale(this.matrixWorld),sk.copy(f.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(f.camera.matrixWorldInverse,this.matrixWorld),sF.setFromMatrixPosition(this.modelViewMatrix),f.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&sH.multiplyScalar(-sF.z);let t=this.material.rotation;0!==t&&(s=Math.cos(t),e=Math.sin(t));let i=this.center;sZ(sG.set(-.5,-.5,0),sF,i,sH,e,s),sZ(sj.set(.5,-.5,0),sF,i,sH,e,s),sZ(sV.set(.5,.5,0),sF,i,sH,e,s),sW.set(0,0),sq.set(1,0),sX.set(1,1);let n=f.ray.intersectTriangle(sG,sj,sV,!1,sz);if(null===n&&(sZ(sj.set(-.5,.5,0),sF,i,sH,e,s),sq.set(0,1),null===(n=f.ray.intersectTriangle(sG,sV,sj,!1,sz))))return;let r=f.ray.origin.distanceTo(sz);r<f.near||r>f.far||v.push({distance:r,point:sz.clone(),uv:fU.getUV(sz,sG,sj,sV,sW,sq,sX,new g),face:null,object:this})},copy:function(f){return fE.prototype.copy.call(this,f),void 0!==f.center&&this.center.copy(f.center),this.material=f.material,this}});let sJ=new T,s$=new T;function sQ(){fE.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}sQ.prototype=Object.assign(Object.create(fE.prototype),{constructor:sQ,isLOD:!0,copy:function(f){fE.prototype.copy.call(this,f,!1);let v=f.levels;for(let f=0,e=v.length;f<e;f++){let e=v[f];this.addLevel(e.object.clone(),e.distance)}return this.autoUpdate=f.autoUpdate,this},addLevel:function(f,v=0){let e;v=Math.abs(v);let s=this.levels;for(e=0;e<s.length&&!(v<s[e].distance);e++);return s.splice(e,0,{distance:v,object:f}),this.add(f),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(f){let v=this.levels;if(v.length>0){let e,s;for(e=1,s=v.length;e<s&&!(f<v[e].distance);e++);return v[e-1].object}return null},raycast:function(f,v){if(this.levels.length>0){sJ.setFromMatrixPosition(this.matrixWorld);let e=f.ray.origin.distanceTo(sJ);this.getObjectForDistance(e).raycast(f,v)}},update:function(f){let v=this.levels;if(v.length>1){let e,s;sJ.setFromMatrixPosition(f.matrixWorld),s$.setFromMatrixPosition(this.matrixWorld);let t=sJ.distanceTo(s$)/f.zoom;for(e=1,v[0].object.visible=!0,s=v.length;e<s&&t>=v[e].distance;e++)v[e-1].object.visible=!1,v[e].object.visible=!0;for(this._currentLevel=e-1;e<s;e++)v[e].object.visible=!1}},toJSON:function(f){let v=fE.prototype.toJSON.call(this,f);!1===this.autoUpdate&&(v.object.autoUpdate=!1),v.object.levels=[];let e=this.levels;for(let f=0,s=e.length;f<s;f++){let s=e[f];v.object.levels.push({object:s.object.uuid,distance:s.distance})}return v}});let sK=new T,s1=new M,s2=new M,s3=new T,s4=new ff;function s0(f,v){f&&f.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),vR.call(this,f,v),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ff,this.bindMatrixInverse=new ff}function s6(){fE.call(this),this.type="Bone"}s0.prototype=Object.assign(Object.create(vR.prototype),{constructor:s0,isSkinnedMesh:!0,copy:function(f){return vR.prototype.copy.call(this,f),this.bindMode=f.bindMode,this.bindMatrix.copy(f.bindMatrix),this.bindMatrixInverse.copy(f.bindMatrixInverse),this.skeleton=f.skeleton,this},bind:function(f,v){this.skeleton=f,void 0===v&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),v=this.matrixWorld),this.bindMatrix.copy(v),this.bindMatrixInverse.copy(v).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){let f=new M,v=this.geometry.attributes.skinWeight;for(let e=0,s=v.count;e<s;e++){f.x=v.getX(e),f.y=v.getY(e),f.z=v.getZ(e),f.w=v.getW(e);let s=1/f.manhattanLength();s!==1/0?f.multiplyScalar(s):f.set(1,0,0,0),v.setXYZW(e,f.x,f.y,f.z,f.w)}},updateMatrixWorld:function(f){vR.prototype.updateMatrixWorld.call(this,f),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(f,v){let e=this.skeleton,s=this.geometry;s1.fromBufferAttribute(s.attributes.skinIndex,f),s2.fromBufferAttribute(s.attributes.skinWeight,f),sK.fromBufferAttribute(s.attributes.position,f).applyMatrix4(this.bindMatrix),v.set(0,0,0);for(let f=0;f<4;f++){let s=s2.getComponent(f);if(0!==s){let t=s1.getComponent(f);s4.multiplyMatrices(e.bones[t].matrixWorld,e.boneInverses[t]),v.addScaledVector(s3.copy(sK).applyMatrix4(s4),s)}}return v.applyMatrix4(this.bindMatrixInverse)}}),s6.prototype=Object.assign(Object.create(fE.prototype),{constructor:s6,isBone:!0});let s5=new ff,s7=new ff;function s8(f=[],v=[]){this.uuid=m.generateUUID(),this.bones=f.slice(0),this.boneInverses=v,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(s8.prototype,{init:function(){let f=this.bones,v=this.boneInverses;if(this.boneMatrices=new Float32Array(16*f.length),0===v.length)this.calculateInverses();else if(f.length!==v.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let f=0,v=this.bones.length;f<v;f++)this.boneInverses.push(new ff)}},calculateInverses:function(){this.boneInverses.length=0;for(let f=0,v=this.bones.length;f<v;f++){let v=new ff;this.bones[f]&&v.copy(this.bones[f].matrixWorld).invert(),this.boneInverses.push(v)}},pose:function(){for(let f=0,v=this.bones.length;f<v;f++){let v=this.bones[f];v&&v.matrixWorld.copy(this.boneInverses[f]).invert()}for(let f=0,v=this.bones.length;f<v;f++){let v=this.bones[f];v&&(v.parent&&v.parent.isBone?(v.matrix.copy(v.parent.matrixWorld).invert(),v.matrix.multiply(v.matrixWorld)):v.matrix.copy(v.matrixWorld),v.matrix.decompose(v.position,v.quaternion,v.scale))}},update:function(){let f=this.bones,v=this.boneInverses,e=this.boneMatrices,s=this.boneTexture;for(let s=0,t=f.length;s<t;s++){let t=f[s]?f[s].matrixWorld:s7;s5.multiplyMatrices(t,v[s]),s5.toArray(e,16*s)}null!==s&&(s.needsUpdate=!0)},clone:function(){return new s8(this.bones,this.boneInverses)},getBoneByName:function(f){for(let v=0,e=this.bones.length;v<e;v++){let e=this.bones[v];if(e.name===f)return e}},dispose:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(f,v){this.uuid=f.uuid;for(let e=0,s=f.bones.length;e<s;e++){let s=f.bones[e],t=v[s];void 0===t&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),t=new s6),this.bones.push(t),this.boneInverses.push(new ff().fromArray(f.boneInverses[e]))}return this.init(),this},toJSON:function(){let f={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};f.uuid=this.uuid;let v=this.bones,e=this.boneInverses;for(let s=0,t=v.length;s<t;s++){let t=v[s];f.bones.push(t.uuid);let i=e[s];f.boneInverses.push(i.toArray())}return f}});let s9=new ff,tf=new ff,tv=[],te=new vR;function ts(f,v,e){vR.call(this,f,v),this.instanceMatrix=new f1(new Float32Array(16*e),16),this.instanceColor=null,this.count=e,this.frustumCulled=!1}function tt(f){fJ.call(this),this.type="LineBasicMaterial",this.color=new fX(0xffffff),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(f)}ts.prototype=Object.assign(Object.create(vR.prototype),{constructor:ts,isInstancedMesh:!0,copy:function(f){return vR.prototype.copy.call(this,f),this.instanceMatrix.copy(f.instanceMatrix),null!==f.instanceColor&&(this.instanceColor=f.instanceColor.clone()),this.count=f.count,this},getColorAt:function(f,v){v.fromArray(this.instanceColor.array,3*f)},getMatrixAt:function(f,v){v.fromArray(this.instanceMatrix.array,16*f)},raycast:function(f,v){let e=this.matrixWorld,s=this.count;if(te.geometry=this.geometry,te.material=this.material,void 0!==te.material)for(let t=0;t<s;t++){this.getMatrixAt(t,s9),tf.multiplyMatrices(e,s9),te.matrixWorld=tf,te.raycast(f,tv);for(let f=0,e=tv.length;f<e;f++){let e=tv[f];e.instanceId=t,e.object=this,v.push(e)}tv.length=0}},setColorAt:function(f,v){null===this.instanceColor&&(this.instanceColor=new f1(new Float32Array(3*this.count),3)),v.toArray(this.instanceColor.array,3*f)},setMatrixAt:function(f,v){v.toArray(this.instanceMatrix.array,16*f)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),tt.prototype=Object.create(fJ.prototype),tt.prototype.constructor=tt,tt.prototype.isLineBasicMaterial=!0,tt.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.linewidth=f.linewidth,this.linecap=f.linecap,this.linejoin=f.linejoin,this.morphTargets=f.morphTargets,this};let ti=new T,tn=new T,tr=new ff,to=new K,ta=new W;function tl(f=new vc,v=new tt){fE.call(this),this.type="Line",this.geometry=f,this.material=v,this.updateMorphTargets()}tl.prototype=Object.assign(Object.create(fE.prototype),{constructor:tl,isLine:!0,copy:function(f){return fE.prototype.copy.call(this,f),this.material=f.material,this.geometry=f.geometry,this},computeLineDistances:function(){let f=this.geometry;if(f.isBufferGeometry){if(null===f.index){let v=f.attributes.position,e=[0];for(let f=1,s=v.count;f<s;f++)ti.fromBufferAttribute(v,f-1),tn.fromBufferAttribute(v,f),e[f]=e[f-1],e[f]+=ti.distanceTo(tn);f.setAttribute("lineDistance",new f9(e,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else f.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(f,v){let e=this.geometry,s=this.matrixWorld,t=f.params.Line.threshold;if(null===e.boundingSphere&&e.computeBoundingSphere(),ta.copy(e.boundingSphere),ta.applyMatrix4(s),ta.radius+=t,!1===f.ray.intersectsSphere(ta))return;tr.copy(s).invert(),to.copy(f.ray).applyMatrix4(tr);let i=t/((this.scale.x+this.scale.y+this.scale.z)/3),n=i*i,r=new T,o=new T,a=new T,l=new T,c=this.isLineSegments?2:1;if(e.isBufferGeometry){let s=e.index,t=e.attributes.position;if(null!==s){let e=s.array;for(let s=0,i=e.length-1;s<i;s+=c){let i=e[s],c=e[s+1];if(r.fromBufferAttribute(t,i),o.fromBufferAttribute(t,c),to.distanceSqToSegment(r,o,l,a)>n)continue;l.applyMatrix4(this.matrixWorld);let h=f.ray.origin.distanceTo(l);h<f.near||h>f.far||v.push({distance:h,point:a.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}else for(let e=0,s=t.count-1;e<s;e+=c){if(r.fromBufferAttribute(t,e),o.fromBufferAttribute(t,e+1),to.distanceSqToSegment(r,o,l,a)>n)continue;l.applyMatrix4(this.matrixWorld);let s=f.ray.origin.distanceTo(l);s<f.near||s>f.far||v.push({distance:s,point:a.clone().applyMatrix4(this.matrixWorld),index:e,face:null,faceIndex:null,object:this})}}else e.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){let f=this.geometry;if(f.isBufferGeometry){let v=f.morphAttributes,e=Object.keys(v);if(e.length>0){let f=v[e[0]];if(void 0!==f){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let v=0,e=f.length;v<e;v++){let e=f[v].name||String(v);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=v}}}}else{let v=f.morphTargets;void 0!==v&&v.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});let tc=new T,th=new T;function tu(f,v){tl.call(this,f,v),this.type="LineSegments"}function td(f,v){tl.call(this,f,v),this.type="LineLoop"}function tp(f){fJ.call(this),this.type="PointsMaterial",this.color=new fX(0xffffff),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(f)}tu.prototype=Object.assign(Object.create(tl.prototype),{constructor:tu,isLineSegments:!0,computeLineDistances:function(){let f=this.geometry;if(f.isBufferGeometry){if(null===f.index){let v=f.attributes.position,e=[];for(let f=0,s=v.count;f<s;f+=2)tc.fromBufferAttribute(v,f),th.fromBufferAttribute(v,f+1),e[f]=0===f?0:e[f-1],e[f+1]=e[f]+tc.distanceTo(th);f.setAttribute("lineDistance",new f9(e,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else f.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),td.prototype=Object.assign(Object.create(tl.prototype),{constructor:td,isLineLoop:!0}),tp.prototype=Object.create(fJ.prototype),tp.prototype.constructor=tp,tp.prototype.isPointsMaterial=!0,tp.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.map=f.map,this.alphaMap=f.alphaMap,this.size=f.size,this.sizeAttenuation=f.sizeAttenuation,this.morphTargets=f.morphTargets,this};let tm=new ff,tg=new K,ty=new W,tx=new T;function tb(f=new vc,v=new tp){fE.call(this),this.type="Points",this.geometry=f,this.material=v,this.updateMorphTargets()}function t_(f,v,e,s,t,i,n){let r=tg.distanceSqToPoint(f);if(r<e){let e=new T;tg.closestPointToPoint(f,e),e.applyMatrix4(s);let o=t.ray.origin.distanceTo(e);if(o<t.near||o>t.far)return;i.push({distance:o,distanceToRay:Math.sqrt(r),point:e,index:v,face:null,object:n})}}function tw(f,v,e,s,t,i,n,r,o){_.call(this,f,v,e,s,t,i,n,r,o),this.format=void 0!==n?n:1022,this.minFilter=void 0!==i?i:1006,this.magFilter=void 0!==t?t:1006,this.generateMipmaps=!1;let a=this;"requestVideoFrameCallback"in f&&f.requestVideoFrameCallback(function v(){a.needsUpdate=!0,f.requestVideoFrameCallback(v)})}function tM(f,v,e,s,t,i,n,r,o,a,l,c){_.call(this,null,i,n,r,o,a,s,t,l,c),this.image={width:v,height:e},this.mipmaps=f,this.flipY=!1,this.generateMipmaps=!1}function tS(f,v,e,s,t,i,n,r,o){_.call(this,f,v,e,s,t,i,n,r,o),this.needsUpdate=!0}function tE(f,v,e,s,t,i,n,r,o,a){if(1026!==(a=void 0!==a?a:1026)&&1027!==a)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===e&&1026===a&&(e=1012),void 0===e&&1027===a&&(e=1020),_.call(this,null,s,t,i,n,r,a,e,o),this.image={width:f,height:v},this.magFilter=void 0!==n?n:1003,this.minFilter=void 0!==r?r:1003,this.flipY=!1,this.generateMipmaps=!1}tb.prototype=Object.assign(Object.create(fE.prototype),{constructor:tb,isPoints:!0,copy:function(f){return fE.prototype.copy.call(this,f),this.material=f.material,this.geometry=f.geometry,this},raycast:function(f,v){let e=this.geometry,s=this.matrixWorld,t=f.params.Points.threshold;if(null===e.boundingSphere&&e.computeBoundingSphere(),ty.copy(e.boundingSphere),ty.applyMatrix4(s),ty.radius+=t,!1===f.ray.intersectsSphere(ty))return;tm.copy(s).invert(),tg.copy(f.ray).applyMatrix4(tm);let i=t/((this.scale.x+this.scale.y+this.scale.z)/3),n=i*i;if(e.isBufferGeometry){let t=e.index,i=e.attributes.position;if(null!==t){let e=t.array;for(let t=0,r=e.length;t<r;t++){let r=e[t];tx.fromBufferAttribute(i,r),t_(tx,r,n,s,f,v,this)}}else for(let e=0,t=i.count;e<t;e++)tx.fromBufferAttribute(i,e),t_(tx,e,n,s,f,v,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){let f=this.geometry;if(f.isBufferGeometry){let v=f.morphAttributes,e=Object.keys(v);if(e.length>0){let f=v[e[0]];if(void 0!==f){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let v=0,e=f.length;v<e;v++){let e=f[v].name||String(v);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=v}}}}else{let v=f.morphTargets;void 0!==v&&v.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),tw.prototype=Object.assign(Object.create(_.prototype),{constructor:tw,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){let f=this.image;!1=="requestVideoFrameCallback"in f&&f.readyState>=f.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),tM.prototype=Object.create(_.prototype),tM.prototype.constructor=tM,tM.prototype.isCompressedTexture=!0,tS.prototype=Object.create(_.prototype),tS.prototype.constructor=tS,tS.prototype.isCanvasTexture=!0,tE.prototype=Object.create(_.prototype),tE.prototype.constructor=tE,tE.prototype.isDepthTexture=!0,new T,new T,new T,new fU;let tT=function(f,v,e){let s,t,i,n,r,o,a;e=e||2;let l=v&&v.length,c=l?v[0]*e:f.length,h=tL(f,0,c,e,!0),u=[];if(!h||h.next===h.prev)return u;if(l&&(h=function(f,v,e,s){let t,i,n,r,o;let a=[];for(t=0,i=v.length;t<i;t++)n=v[t]*s,r=t<i-1?v[t+1]*s:f.length,(o=tL(f,n,r,s,!1))===o.next&&(o.steiner=!0),a.push(function(f){let v=f,e=f;do(v.x<e.x||v.x===e.x&&v.y<e.y)&&(e=v),v=v.next;while(v!==f)return e}(o));for(a.sort(tR),t=0;t<a.length;t++)(function(f,v){if(v=function(f,v){let e=v,s=f.x,t=f.y,i=-1/0,n;do{if(t<=e.y&&t>=e.next.y&&e.next.y!==e.y){let f=e.x+(t-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(f<=s&&f>i){if(i=f,f===s){if(t===e.y)return e;if(t===e.next.y)return e.next}n=e.x<e.next.x?e:e.next}}e=e.next}while(e!==v)if(!n)return null;if(s===i)return n;let r=n,o=n.x,a=n.y,l=1/0,c;e=n;do{var h,u;s>=e.x&&e.x>=o&&s!==e.x&&tP(t<a?s:i,t,o,a,t<a?i:s,t,e.x,e.y)&&(c=Math.abs(t-e.y)/(s-e.x),tH(e,f)&&(c<l||c===l&&(e.x>n.x||e.x===n.x&&(h=n,u=e,0>tO(h.prev,h,u.prev)&&0>tO(u.next,h,h.next))))&&(n=e,l=c)),e=e.next}while(e!==r)return n}(f,v)){let e=tF(v,f);tA(v,v.next),tA(e,e.next)}})(a[t],e),e=tA(e,e.next);return e}(f,v,h,e)),f.length>80*e){s=i=f[0],t=n=f[1];for(let v=e;v<c;v+=e)r=f[v],o=f[v+1],r<s&&(s=r),o<t&&(t=o),r>i&&(i=r),o>n&&(n=o);a=0!==(a=Math.max(i-s,n-t))?1/a:0}return function f(v,e,s,t,i,n,r){if(!v)return;!r&&n&&function(f,v,e,s){let t=f;do null===t.z&&(t.z=tC(t.x,t.y,v,e,s)),t.prevZ=t.prev,t.nextZ=t.next,t=t.next;while(t!==f)t.prevZ.nextZ=null,t.prevZ=null,function(f){let v,e,s,t,i,n,r,o,a=1;do{for(e=f,f=null,i=null,n=0;e;){for(n++,s=e,r=0,v=0;v<a&&(r++,s=s.nextZ);v++);for(o=a;r>0||o>0&&s;)0!==r&&(0===o||!s||e.z<=s.z)?(t=e,e=e.nextZ,r--):(t=s,s=s.nextZ,o--),i?i.nextZ=t:f=t,t.prevZ=i,i=t;e=s}i.nextZ=null,a*=2}while(n>1)}(t)}(v,t,i,n);let o=v,a,l;for(;v.prev!==v.next;){if(a=v.prev,l=v.next,n?function(f,v,e,s){let t=f.prev,i=f.next;if(tO(t,f,i)>=0)return!1;let n=t.x<f.x?t.x<i.x?t.x:i.x:f.x<i.x?f.x:i.x,r=t.y<f.y?t.y<i.y?t.y:i.y:f.y<i.y?f.y:i.y,o=t.x>f.x?t.x>i.x?t.x:i.x:f.x>i.x?f.x:i.x,a=t.y>f.y?t.y>i.y?t.y:i.y:f.y>i.y?f.y:i.y,l=tC(n,r,v,e,s),c=tC(o,a,v,e,s),h=f.prevZ,u=f.nextZ;for(;h&&h.z>=l&&u&&u.z<=c;){if(h!==f.prev&&h!==f.next&&tP(t.x,t.y,f.x,f.y,i.x,i.y,h.x,h.y)&&tO(h.prev,h,h.next)>=0||(h=h.prevZ,u!==f.prev&&u!==f.next&&tP(t.x,t.y,f.x,f.y,i.x,i.y,u.x,u.y)&&tO(u.prev,u,u.next)>=0))return!1;u=u.nextZ}for(;h&&h.z>=l;){if(h!==f.prev&&h!==f.next&&tP(t.x,t.y,f.x,f.y,i.x,i.y,h.x,h.y)&&tO(h.prev,h,h.next)>=0)return!1;h=h.prevZ}for(;u&&u.z<=c;){if(u!==f.prev&&u!==f.next&&tP(t.x,t.y,f.x,f.y,i.x,i.y,u.x,u.y)&&tO(u.prev,u,u.next)>=0)return!1;u=u.nextZ}return!0}(v,t,i,n):function(f){let v=f.prev,e=f.next;if(tO(v,f,e)>=0)return!1;let s=f.next.next;for(;s!==f.prev;){if(tP(v.x,v.y,f.x,f.y,e.x,e.y,s.x,s.y)&&tO(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}(v)){e.push(a.i/s),e.push(v.i/s),e.push(l.i/s),tU(v),v=l.next,o=l.next;continue}if((v=l)===o){r?1===r?f(v=function(f,v,e){let s=f;do{let t=s.prev,i=s.next.next;!tD(t,i)&&tI(t,s,s.next,i)&&tH(t,i)&&tH(i,t)&&(v.push(t.i/e),v.push(s.i/e),v.push(i.i/e),tU(s),tU(s.next),s=f=i),s=s.next}while(s!==f)return tA(s)}(tA(v),e,s),e,s,t,i,n,2):2===r&&function(v,e,s,t,i,n){let r=v;do{let v=r.next.next;for(;v!==r.prev;){var o,a;if(r.i!==v.i&&(o=r,a=v,o.next.i!==a.i&&o.prev.i!==a.i&&!function(f,v){let e=f;do{if(e.i!==f.i&&e.next.i!==f.i&&e.i!==v.i&&e.next.i!==v.i&&tI(e,e.next,f,v))return!0;e=e.next}while(e!==f)return!1}(o,a)&&(tH(o,a)&&tH(a,o)&&function(f,v){let e=f,s=!1,t=(f.x+v.x)/2,i=(f.y+v.y)/2;do e.y>i!=e.next.y>i&&e.next.y!==e.y&&t<(e.next.x-e.x)*(i-e.y)/(e.next.y-e.y)+e.x&&(s=!s),e=e.next;while(e!==f)return s}(o,a)&&(tO(o.prev,o,a.prev)||tO(o,a.prev,a))||tD(o,a)&&tO(o.prev,o,o.next)>0&&tO(a.prev,a,a.next)>0))){let o=tF(r,v);r=tA(r,r.next),o=tA(o,o.next),f(r,e,s,t,i,n),f(o,e,s,t,i,n);return}v=v.next}r=r.next}while(r!==v)}(v,e,s,t,i,n):f(tA(v),e,s,t,i,n,1);break}}}(h,u,e,s,t,a),u};function tL(f,v,e,s,t){let i,n;if(t===function(f,v,e,s){let t=0;for(let i=v,n=e-s;i<e;i+=s)t+=(f[n]-f[i])*(f[i+1]+f[n+1]),n=i;return t}(f,v,e,s)>0)for(i=v;i<e;i+=s)n=tB(i,f[i],f[i+1],n);else for(i=e-s;i>=v;i-=s)n=tB(i,f[i],f[i+1],n);return n&&tD(n,n.next)&&(tU(n),n=n.next),n}function tA(f,v){if(!f)return f;v||(v=f);let e=f,s;do if(s=!1,!e.steiner&&(tD(e,e.next)||0===tO(e.prev,e,e.next))){if(tU(e),(e=v=e.prev)===e.next)break;s=!0}else e=e.next;while(s||e!==v)return v}function tR(f,v){return f.x-v.x}function tC(f,v,e,s,t){return(f=((f=((f=((f=((f=32767*(f-e)*t)|f<<8)&0xff00ff)|f<<4)&0xf0f0f0f)|f<<2)&0x33333333)|f<<1)&0x55555555)|(v=((v=((v=((v=((v=32767*(v-s)*t)|v<<8)&0xff00ff)|v<<4)&0xf0f0f0f)|v<<2)&0x33333333)|v<<1)&0x55555555)<<1}function tP(f,v,e,s,t,i,n,r){return(t-n)*(v-r)-(f-n)*(i-r)>=0&&(f-n)*(s-r)-(e-n)*(v-r)>=0&&(e-n)*(i-r)-(t-n)*(s-r)>=0}function tO(f,v,e){return(v.y-f.y)*(e.x-v.x)-(v.x-f.x)*(e.y-v.y)}function tD(f,v){return f.x===v.x&&f.y===v.y}function tI(f,v,e,s){let t=tz(tO(f,v,e)),i=tz(tO(f,v,s)),n=tz(tO(e,s,f)),r=tz(tO(e,s,v));return!!(t!==i&&n!==r||0===t&&tN(f,e,v)||0===i&&tN(f,s,v)||0===n&&tN(e,f,s)||0===r&&tN(e,v,s))}function tN(f,v,e){return v.x<=Math.max(f.x,e.x)&&v.x>=Math.min(f.x,e.x)&&v.y<=Math.max(f.y,e.y)&&v.y>=Math.min(f.y,e.y)}function tz(f){return f>0?1:f<0?-1:0}function tH(f,v){return 0>tO(f.prev,f,f.next)?tO(f,v,f.next)>=0&&tO(f,f.prev,v)>=0:0>tO(f,v,f.prev)||0>tO(f,f.next,v)}function tF(f,v){let e=new tk(f.i,f.x,f.y),s=new tk(v.i,v.x,v.y),t=f.next,i=v.prev;return f.next=v,v.prev=f,e.next=t,t.prev=e,s.next=e,e.prev=s,i.next=s,s.prev=i,s}function tB(f,v,e,s){let t=new tk(f,v,e);return s?(t.next=s.next,t.prev=s,s.next.prev=t,s.next=t):(t.prev=t,t.next=t),t}function tU(f){f.next.prev=f.prev,f.prev.next=f.next,f.prevZ&&(f.prevZ.nextZ=f.nextZ),f.nextZ&&(f.nextZ.prevZ=f.prevZ)}function tk(f,v,e){this.i=f,this.x=v,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}let tG={area:function(f){let v=f.length,e=0;for(let s=v-1,t=0;t<v;s=t++)e+=f[s].x*f[t].y-f[t].x*f[s].y;return .5*e},isClockWise:function(f){return 0>tG.area(f)},triangulateShape:function(f,v){let e=[],s=[],t=[];tj(f),tV(e,f);let i=f.length;v.forEach(tj);for(let f=0;f<v.length;f++)s.push(i),i+=v[f].length,tV(e,v[f]);let n=tT(e,s);for(let f=0;f<n.length;f+=3)t.push(n.slice(f,f+3));return t}};function tj(f){let v=f.length;v>2&&f[v-1].equals(f[0])&&f.pop()}function tV(f,v){for(let e=0;e<v.length;e++)f.push(v[e].x),f.push(v[e].y)}class tW extends vc{constructor(f,v){super(),this.type="ExtrudeGeometry",this.parameters={shapes:f,options:v},f=Array.isArray(f)?f:[f];let e=this,s=[],t=[];for(let i=0,n=f.length;i<n;i++)(function(f){let i,n,r,o;let a=[],l=void 0!==v.curveSegments?v.curveSegments:12,c=void 0!==v.steps?v.steps:1,h=void 0!==v.depth?v.depth:100,u=void 0===v.bevelEnabled||v.bevelEnabled,d=void 0!==v.bevelThickness?v.bevelThickness:6,p=void 0!==v.bevelSize?v.bevelSize:d-2,m=void 0!==v.bevelOffset?v.bevelOffset:0,y=void 0!==v.bevelSegments?v.bevelSegments:3,x=v.extrudePath,b=void 0!==v.UVGenerator?v.UVGenerator:tq;void 0!==v.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=v.amount);let _,w=!1;x&&(_=x.getSpacedPoints(c),w=!0,u=!1,i=x.computeFrenetFrames(c,!1),n=new T,r=new T,o=new T),u||(y=0,d=0,p=0,m=0);let M=f.extractPoints(l),S=M.shape,E=M.holes;if(!tG.isClockWise(S)){S=S.reverse();for(let f=0,v=E.length;f<v;f++){let v=E[f];tG.isClockWise(v)&&(E[f]=v.reverse())}}let L=tG.triangulateShape(S,E),A=S;for(let f=0,v=E.length;f<v;f++){let v=E[f];S=S.concat(v)}function R(f,v,e){return v||console.error("THREE.ExtrudeGeometry: vec does not exist"),v.clone().multiplyScalar(e).add(f)}let C=S.length,P=L.length;function O(f,v,e){let s,t,i;let n=f.x-v.x,r=f.y-v.y,o=e.x-f.x,a=e.y-f.y,l=n*n+r*r;if(Math.abs(n*a-r*o)>Number.EPSILON){let c=Math.sqrt(l),h=Math.sqrt(o*o+a*a),u=v.x-r/c,d=v.y+n/c,p=((e.x-a/h-u)*a-(e.y+o/h-d)*o)/(n*a-r*o),m=(s=u+n*p-f.x)*s+(t=d+r*p-f.y)*t;if(m<=2)return new g(s,t);i=Math.sqrt(m/2)}else{let f=!1;n>Number.EPSILON?o>Number.EPSILON&&(f=!0):n<-Number.EPSILON?o<-Number.EPSILON&&(f=!0):Math.sign(r)===Math.sign(a)&&(f=!0),f?(s=-r,t=n,i=Math.sqrt(l)):(s=n,t=r,i=Math.sqrt(l/2))}return new g(s/i,t/i)}let D=[];for(let f=0,v=A.length,e=v-1,s=f+1;f<v;f++,e++,s++)e===v&&(e=0),s===v&&(s=0),D[f]=O(A[f],A[e],A[s]);let I=[],N,z=D.concat();for(let f=0,v=E.length;f<v;f++){let v=E[f];N=[];for(let f=0,e=v.length,s=e-1,t=f+1;f<e;f++,s++,t++)s===e&&(s=0),t===e&&(t=0),N[f]=O(v[f],v[s],v[t]);I.push(N),z=z.concat(N)}for(let f=0;f<y;f++){let v=f/y,e=d*Math.cos(v*Math.PI/2),s=p*Math.sin(v*Math.PI/2)+m;for(let f=0,v=A.length;f<v;f++){let v=R(A[f],D[f],s);B(v.x,v.y,-e)}for(let f=0,v=E.length;f<v;f++){let v=E[f];N=I[f];for(let f=0,t=v.length;f<t;f++){let t=R(v[f],N[f],s);B(t.x,t.y,-e)}}}let H=p+m;for(let f=0;f<C;f++){let v=u?R(S[f],z[f],H):S[f];w?(r.copy(i.normals[0]).multiplyScalar(v.x),n.copy(i.binormals[0]).multiplyScalar(v.y),o.copy(_[0]).add(r).add(n),B(o.x,o.y,o.z)):B(v.x,v.y,0)}for(let f=1;f<=c;f++)for(let v=0;v<C;v++){let e=u?R(S[v],z[v],H):S[v];w?(r.copy(i.normals[f]).multiplyScalar(e.x),n.copy(i.binormals[f]).multiplyScalar(e.y),o.copy(_[f]).add(r).add(n),B(o.x,o.y,o.z)):B(e.x,e.y,h/c*f)}for(let f=y-1;f>=0;f--){let v=f/y,e=d*Math.cos(v*Math.PI/2),s=p*Math.sin(v*Math.PI/2)+m;for(let f=0,v=A.length;f<v;f++){let v=R(A[f],D[f],s);B(v.x,v.y,h+e)}for(let f=0,v=E.length;f<v;f++){let v=E[f];N=I[f];for(let f=0,t=v.length;f<t;f++){let t=R(v[f],N[f],s);w?B(t.x,t.y+_[c-1].y,_[c-1].x+e):B(t.x,t.y,h+e)}}}function F(f,v){let t=f.length;for(;--t>=0;){let i=t,n=t-1;n<0&&(n=f.length-1);for(let f=0,t=c+2*y;f<t;f++){let t=C*f,r=C*(f+1);(function(f,v,t,i){k(f),k(v),k(i),k(v),k(t),k(i);let n=s.length/3,r=b.generateSideWallUV(e,s,n-6,n-3,n-2,n-1);G(r[0]),G(r[1]),G(r[3]),G(r[1]),G(r[2]),G(r[3])})(v+i+t,v+n+t,v+n+r,v+i+r)}}}function B(f,v,e){a.push(f),a.push(v),a.push(e)}function U(f,v,t){k(f),k(v),k(t);let i=s.length/3,n=b.generateTopUV(e,s,i-3,i-2,i-1);G(n[0]),G(n[1]),G(n[2])}function k(f){s.push(a[3*f+0]),s.push(a[3*f+1]),s.push(a[3*f+2])}function G(f){t.push(f.x),t.push(f.y)}(function(){let f=s.length/3;if(u){let f=0*C;for(let v=0;v<P;v++){let e=L[v];U(e[2]+f,e[1]+f,e[0]+f)}f=C*(c+2*y);for(let v=0;v<P;v++){let e=L[v];U(e[0]+f,e[1]+f,e[2]+f)}}else{for(let f=0;f<P;f++){let v=L[f];U(v[2],v[1],v[0])}for(let f=0;f<P;f++){let v=L[f];U(v[0]+C*c,v[1]+C*c,v[2]+C*c)}}e.addGroup(f,s.length/3-f,0)})(),function(){let f=s.length/3,v=0;F(A,0),v+=A.length;for(let f=0,e=E.length;f<e;f++){let e=E[f];F(e,v),v+=e.length}e.addGroup(f,s.length/3-f,1)}()})(f[i]);this.setAttribute("position",new f9(s,3)),this.setAttribute("uv",new f9(t,2)),this.computeVertexNormals()}toJSON(){let f=vc.prototype.toJSON.call(this);return function(f,v,e){if(e.shapes=[],Array.isArray(f))for(let v=0,s=f.length;v<s;v++){let s=f[v];e.shapes.push(s.uuid)}else e.shapes.push(f.uuid);return void 0!==v.extrudePath&&(e.options.extrudePath=v.extrudePath.toJSON()),e}(this.parameters.shapes,this.parameters.options,f)}}let tq={generateTopUV:function(f,v,e,s,t){let i=v[3*e],n=v[3*e+1],r=v[3*s],o=v[3*s+1],a=v[3*t],l=v[3*t+1];return[new g(i,n),new g(r,o),new g(a,l)]},generateSideWallUV:function(f,v,e,s,t,i){let n=v[3*e],r=v[3*e+1],o=v[3*e+2],a=v[3*s],l=v[3*s+1],c=v[3*s+2],h=v[3*t],u=v[3*t+1],d=v[3*t+2],p=v[3*i],m=v[3*i+1],y=v[3*i+2];return .01>Math.abs(r-l)?[new g(n,1-o),new g(a,1-c),new g(h,1-d),new g(p,1-y)]:[new g(r,1-o),new g(l,1-c),new g(u,1-d),new g(m,1-y)]}};function tX(f,v,e){vc.call(this),this.type="ParametricGeometry",this.parameters={func:f,slices:v,stacks:e};let s=[],t=[],i=[],n=[],r=new T,o=new T,a=new T,l=new T,c=new T;f.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");let h=v+1;for(let s=0;s<=e;s++){let h=s/e;for(let e=0;e<=v;e++){let s=e/v;f(s,h,o),t.push(o.x,o.y,o.z),s-1e-5>=0?(f(s-1e-5,h,a),l.subVectors(o,a)):(f(s+1e-5,h,a),l.subVectors(a,o)),h-1e-5>=0?(f(s,h-1e-5,a),c.subVectors(o,a)):(f(s,h+1e-5,a),c.subVectors(a,o)),r.crossVectors(l,c).normalize(),i.push(r.x,r.y,r.z),n.push(s,h)}}for(let f=0;f<e;f++)for(let e=0;e<v;e++){let v=f*h+e,t=f*h+e+1,i=(f+1)*h+e+1,n=(f+1)*h+e;s.push(v,t,n),s.push(t,i,n)}this.setIndex(s),this.setAttribute("position",new f9(t,3)),this.setAttribute("normal",new f9(i,3)),this.setAttribute("uv",new f9(n,2))}tX.prototype=Object.create(vc.prototype),tX.prototype.constructor=tX;class tY extends vc{constructor(f,v=12){super(),this.type="ShapeGeometry",this.parameters={shapes:f,curveSegments:v};let e=[],s=[],t=[],i=[],n=0,r=0;if(!1===Array.isArray(f))o(f);else for(let v=0;v<f.length;v++)o(f[v]),this.addGroup(n,r,v),n+=r,r=0;function o(f){let n=s.length/3,o=f.extractPoints(v),a=o.shape,l=o.holes;!1===tG.isClockWise(a)&&(a=a.reverse());for(let f=0,v=l.length;f<v;f++){let v=l[f];!0===tG.isClockWise(v)&&(l[f]=v.reverse())}let c=tG.triangulateShape(a,l);for(let f=0,v=l.length;f<v;f++){let v=l[f];a=a.concat(v)}for(let f=0,v=a.length;f<v;f++){let v=a[f];s.push(v.x,v.y,0),t.push(0,0,1),i.push(v.x,v.y)}for(let f=0,v=c.length;f<v;f++){let v=c[f],s=v[0]+n,t=v[1]+n,i=v[2]+n;e.push(s,t,i),r+=3}}this.setIndex(e),this.setAttribute("position",new f9(s,3)),this.setAttribute("normal",new f9(t,3)),this.setAttribute("uv",new f9(i,2))}toJSON(){let f=vc.prototype.toJSON.call(this);return function(f,v){if(v.shapes=[],Array.isArray(f))for(let e=0,s=f.length;e<s;e++){let s=f[e];v.shapes.push(s.uuid)}else v.shapes.push(f.uuid);return v}(this.parameters.shapes,f)}}class tZ extends vc{constructor(f){if(super(),this.type="WireframeGeometry",!0===f.isGeometry){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}let v=[],e=[0,0],s={},t=new T;if(null!==f.index){let i=f.attributes.position,n=f.index,r=f.groups;0===r.length&&(r=[{start:0,count:n.count,materialIndex:0}]);for(let f=0,v=r.length;f<v;++f){let v=r[f],t=v.start,i=v.count;for(let f=t,v=t+i;f<v;f+=3)for(let v=0;v<3;v++){let t=n.getX(f+v),i=n.getX(f+(v+1)%3);e[0]=Math.min(t,i),e[1]=Math.max(t,i);let r=e[0]+","+e[1];void 0===s[r]&&(s[r]={index1:e[0],index2:e[1]})}}for(let f in s){let e=s[f];t.fromBufferAttribute(i,e.index1),v.push(t.x,t.y,t.z),t.fromBufferAttribute(i,e.index2),v.push(t.x,t.y,t.z)}}else{let e=f.attributes.position;for(let f=0,s=e.count/3;f<s;f++)for(let s=0;s<3;s++){let i=3*f+s;t.fromBufferAttribute(e,i),v.push(t.x,t.y,t.z);let n=3*f+(s+1)%3;t.fromBufferAttribute(e,n),v.push(t.x,t.y,t.z)}}this.setAttribute("position",new f9(v,3))}}function tJ(f){fJ.call(this),this.type="ShadowMaterial",this.color=new fX(0),this.transparent=!0,this.setValues(f)}function t$(f){vN.call(this,f),this.type="RawShaderMaterial"}function tQ(f){fJ.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new fX(0xffffff),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fX(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new g(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(f)}function tK(f){tQ.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new g(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(f){this.reflectivity=m.clamp(2.5*(f-1)/(f+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(f)}function t1(f){fJ.call(this),this.type="MeshPhongMaterial",this.color=new fX(0xffffff),this.specular=new fX(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fX(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new g(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(f)}function t2(f){fJ.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new fX(0xffffff),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fX(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new g(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(f)}function t3(f){fJ.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new g(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(f)}function t4(f){fJ.call(this),this.type="MeshLambertMaterial",this.color=new fX(0xffffff),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fX(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(f)}function t0(f){fJ.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new fX(0xffffff),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new g(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(f)}function t6(f){tt.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(f)}tJ.prototype=Object.create(fJ.prototype),tJ.prototype.constructor=tJ,tJ.prototype.isShadowMaterial=!0,tJ.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this},t$.prototype=Object.create(vN.prototype),t$.prototype.constructor=t$,t$.prototype.isRawShaderMaterial=!0,tQ.prototype=Object.create(fJ.prototype),tQ.prototype.constructor=tQ,tQ.prototype.isMeshStandardMaterial=!0,tQ.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.defines={STANDARD:""},this.color.copy(f.color),this.roughness=f.roughness,this.metalness=f.metalness,this.map=f.map,this.lightMap=f.lightMap,this.lightMapIntensity=f.lightMapIntensity,this.aoMap=f.aoMap,this.aoMapIntensity=f.aoMapIntensity,this.emissive.copy(f.emissive),this.emissiveMap=f.emissiveMap,this.emissiveIntensity=f.emissiveIntensity,this.bumpMap=f.bumpMap,this.bumpScale=f.bumpScale,this.normalMap=f.normalMap,this.normalMapType=f.normalMapType,this.normalScale.copy(f.normalScale),this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.roughnessMap=f.roughnessMap,this.metalnessMap=f.metalnessMap,this.alphaMap=f.alphaMap,this.envMap=f.envMap,this.envMapIntensity=f.envMapIntensity,this.refractionRatio=f.refractionRatio,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.wireframeLinecap=f.wireframeLinecap,this.wireframeLinejoin=f.wireframeLinejoin,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this.vertexTangents=f.vertexTangents,this},tK.prototype=Object.create(tQ.prototype),tK.prototype.constructor=tK,tK.prototype.isMeshPhysicalMaterial=!0,tK.prototype.copy=function(f){return tQ.prototype.copy.call(this,f),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=f.clearcoat,this.clearcoatMap=f.clearcoatMap,this.clearcoatRoughness=f.clearcoatRoughness,this.clearcoatRoughnessMap=f.clearcoatRoughnessMap,this.clearcoatNormalMap=f.clearcoatNormalMap,this.clearcoatNormalScale.copy(f.clearcoatNormalScale),this.reflectivity=f.reflectivity,f.sheen?this.sheen=(this.sheen||new fX).copy(f.sheen):this.sheen=null,this.transmission=f.transmission,this.transmissionMap=f.transmissionMap,this},t1.prototype=Object.create(fJ.prototype),t1.prototype.constructor=t1,t1.prototype.isMeshPhongMaterial=!0,t1.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.specular.copy(f.specular),this.shininess=f.shininess,this.map=f.map,this.lightMap=f.lightMap,this.lightMapIntensity=f.lightMapIntensity,this.aoMap=f.aoMap,this.aoMapIntensity=f.aoMapIntensity,this.emissive.copy(f.emissive),this.emissiveMap=f.emissiveMap,this.emissiveIntensity=f.emissiveIntensity,this.bumpMap=f.bumpMap,this.bumpScale=f.bumpScale,this.normalMap=f.normalMap,this.normalMapType=f.normalMapType,this.normalScale.copy(f.normalScale),this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.specularMap=f.specularMap,this.alphaMap=f.alphaMap,this.envMap=f.envMap,this.combine=f.combine,this.reflectivity=f.reflectivity,this.refractionRatio=f.refractionRatio,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.wireframeLinecap=f.wireframeLinecap,this.wireframeLinejoin=f.wireframeLinejoin,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this},t2.prototype=Object.create(fJ.prototype),t2.prototype.constructor=t2,t2.prototype.isMeshToonMaterial=!0,t2.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.map=f.map,this.gradientMap=f.gradientMap,this.lightMap=f.lightMap,this.lightMapIntensity=f.lightMapIntensity,this.aoMap=f.aoMap,this.aoMapIntensity=f.aoMapIntensity,this.emissive.copy(f.emissive),this.emissiveMap=f.emissiveMap,this.emissiveIntensity=f.emissiveIntensity,this.bumpMap=f.bumpMap,this.bumpScale=f.bumpScale,this.normalMap=f.normalMap,this.normalMapType=f.normalMapType,this.normalScale.copy(f.normalScale),this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.alphaMap=f.alphaMap,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.wireframeLinecap=f.wireframeLinecap,this.wireframeLinejoin=f.wireframeLinejoin,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this},t3.prototype=Object.create(fJ.prototype),t3.prototype.constructor=t3,t3.prototype.isMeshNormalMaterial=!0,t3.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.bumpMap=f.bumpMap,this.bumpScale=f.bumpScale,this.normalMap=f.normalMap,this.normalMapType=f.normalMapType,this.normalScale.copy(f.normalScale),this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this},t4.prototype=Object.create(fJ.prototype),t4.prototype.constructor=t4,t4.prototype.isMeshLambertMaterial=!0,t4.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.color.copy(f.color),this.map=f.map,this.lightMap=f.lightMap,this.lightMapIntensity=f.lightMapIntensity,this.aoMap=f.aoMap,this.aoMapIntensity=f.aoMapIntensity,this.emissive.copy(f.emissive),this.emissiveMap=f.emissiveMap,this.emissiveIntensity=f.emissiveIntensity,this.specularMap=f.specularMap,this.alphaMap=f.alphaMap,this.envMap=f.envMap,this.combine=f.combine,this.reflectivity=f.reflectivity,this.refractionRatio=f.refractionRatio,this.wireframe=f.wireframe,this.wireframeLinewidth=f.wireframeLinewidth,this.wireframeLinecap=f.wireframeLinecap,this.wireframeLinejoin=f.wireframeLinejoin,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this},t0.prototype=Object.create(fJ.prototype),t0.prototype.constructor=t0,t0.prototype.isMeshMatcapMaterial=!0,t0.prototype.copy=function(f){return fJ.prototype.copy.call(this,f),this.defines={MATCAP:""},this.color.copy(f.color),this.matcap=f.matcap,this.map=f.map,this.bumpMap=f.bumpMap,this.bumpScale=f.bumpScale,this.normalMap=f.normalMap,this.normalMapType=f.normalMapType,this.normalScale.copy(f.normalScale),this.displacementMap=f.displacementMap,this.displacementScale=f.displacementScale,this.displacementBias=f.displacementBias,this.alphaMap=f.alphaMap,this.skinning=f.skinning,this.morphTargets=f.morphTargets,this.morphNormals=f.morphNormals,this},t6.prototype=Object.create(tt.prototype),t6.prototype.constructor=t6,t6.prototype.isLineDashedMaterial=!0,t6.prototype.copy=function(f){return tt.prototype.copy.call(this,f),this.scale=f.scale,this.dashSize=f.dashSize,this.gapSize=f.gapSize,this};var t5=/*#__PURE__*/Object.freeze({__proto__:null,ShadowMaterial:tJ,SpriteMaterial:sN,RawShaderMaterial:t$,ShaderMaterial:vN,PointsMaterial:tp,MeshPhysicalMaterial:tK,MeshStandardMaterial:tQ,MeshPhongMaterial:t1,MeshToonMaterial:t2,MeshNormalMaterial:t3,MeshLambertMaterial:t4,MeshDepthMaterial:sg,MeshDistanceMaterial:sy,MeshBasicMaterial:f$,MeshMatcapMaterial:t0,LineDashedMaterial:t6,LineBasicMaterial:tt,Material:fJ});let t7={arraySlice:function(f,v,e){return t7.isTypedArray(f)?new f.constructor(f.subarray(v,void 0!==e?e:f.length)):f.slice(v,e)},convertArray:function(f,v,e){return f&&(e||f.constructor!==v)?"number"==typeof v.BYTES_PER_ELEMENT?new v(f):Array.prototype.slice.call(f):f},isTypedArray:function(f){return ArrayBuffer.isView(f)&&!(f instanceof DataView)},getKeyframeOrder:function(f){let v=f.length,e=Array(v);for(let f=0;f!==v;++f)e[f]=f;return e.sort(function(v,e){return f[v]-f[e]}),e},sortedArray:function(f,v,e){let s=f.length,t=new f.constructor(s);for(let i=0,n=0;n!==s;++i){let s=e[i]*v;for(let e=0;e!==v;++e)t[n++]=f[s+e]}return t},flattenJSON:function(f,v,e,s){let t=1,i=f[0];for(;void 0!==i&&void 0===i[s];)i=f[t++];if(void 0===i)return;let n=i[s];if(void 0!==n){if(Array.isArray(n))do void 0!==(n=i[s])&&(v.push(i.time),e.push.apply(e,n)),i=f[t++];while(void 0!==i)else if(void 0!==n.toArray)do void 0!==(n=i[s])&&(v.push(i.time),n.toArray(e,e.length)),i=f[t++];while(void 0!==i)else do void 0!==(n=i[s])&&(v.push(i.time),e.push(n)),i=f[t++];while(void 0!==i)}},subclip:function(f,v,e,s,t=30){let i=f.clone();i.name=v;let n=[];for(let f=0;f<i.tracks.length;++f){let v=i.tracks[f],r=v.getValueSize(),o=[],a=[];for(let f=0;f<v.times.length;++f){let i=v.times[f]*t;if(!(i<e)&&!(i>=s)){o.push(v.times[f]);for(let e=0;e<r;++e)a.push(v.values[f*r+e])}}0!==o.length&&(v.times=t7.convertArray(o,v.times.constructor),v.values=t7.convertArray(a,v.values.constructor),n.push(v))}i.tracks=n;let r=1/0;for(let f=0;f<i.tracks.length;++f)r>i.tracks[f].times[0]&&(r=i.tracks[f].times[0]);for(let f=0;f<i.tracks.length;++f)i.tracks[f].shift(-1*r);return i.resetDuration(),i},makeClipAdditive:function(f,v=0,e=f,s=30){s<=0&&(s=30);let t=e.tracks.length,i=v/s;for(let v=0;v<t;++v){let s;let t=e.tracks[v],n=t.ValueTypeName;if("bool"===n||"string"===n)continue;let r=f.tracks.find(function(f){return f.name===t.name&&f.ValueTypeName===n});if(void 0===r)continue;let o=0,a=t.getValueSize();t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=a/3);let l=0,c=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=c/3);let h=t.times.length-1;if(i<=t.times[0]){let f=o,v=a-o;s=t7.arraySlice(t.values,f,v)}else if(i>=t.times[h]){let f=h*a+o,v=f+a-o;s=t7.arraySlice(t.values,f,v)}else{let f=t.createInterpolant(),v=o,e=a-o;f.evaluate(i),s=t7.arraySlice(f.resultBuffer,v,e)}"quaternion"===n&&new E().fromArray(s).normalize().conjugate().toArray(s);let u=r.times.length;for(let f=0;f<u;++f){let v=f*c+l;if("quaternion"===n)E.multiplyQuaternionsFlat(r.values,v,s,0,r.values,v);else{let f=c-2*l;for(let e=0;e<f;++e)r.values[v+e]-=s[e]}}}return f.blendMode=2501,f}};function t8(f,v,e,s){this.parameterPositions=f,this._cachedIndex=0,this.resultBuffer=void 0!==s?s:new v.constructor(e),this.sampleValues=v,this.valueSize=e}function t9(f,v,e,s){t8.call(this,f,v,e,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function iv(f,v,e,s){t8.call(this,f,v,e,s)}function ie(f,v,e,s){t8.call(this,f,v,e,s)}function is(f,v,e,s){if(void 0===f)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===v||0===v.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+f);this.name=f,this.times=t7.convertArray(v,this.TimeBufferType),this.values=t7.convertArray(e,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}function it(f,v,e){is.call(this,f,v,e)}function ii(f,v,e,s){is.call(this,f,v,e,s)}function ir(f,v,e,s){is.call(this,f,v,e,s)}function io(f,v,e,s){t8.call(this,f,v,e,s)}function ia(f,v,e,s){is.call(this,f,v,e,s)}function il(f,v,e,s){is.call(this,f,v,e,s)}function ic(f,v,e,s){is.call(this,f,v,e,s)}function ih(f,v=-1,e,s=2500){this.name=f,this.tracks=e,this.duration=v,this.blendMode=s,this.uuid=m.generateUUID(),this.duration<0&&this.resetDuration()}Object.assign(t8.prototype,{evaluate:function(f){let v=this.parameterPositions,e=this._cachedIndex,s=v[e],t=v[e-1];f:{v:{let i;e:{s:if(!(f<s)){for(let i=e+2;;){if(void 0===s){if(f<t)break s;return e=v.length,this._cachedIndex=e,this.afterEnd_(e-1,f,t)}if(e===i)break;if(t=s,f<(s=v[++e]))break v}i=v.length;break e}if(!(f>=t)){let n=v[1];f<n&&(e=2,t=n);for(let i=e-2;;){if(void 0===t)return this._cachedIndex=0,this.beforeStart_(0,f,s);if(e===i)break;if(s=t,f>=(t=v[--e-1]))break v}i=e,e=0;break e}break f}for(;e<i;){let s=e+i>>>1;f<v[s]?i=s:e=s+1}if(s=v[e],void 0===(t=v[e-1]))return this._cachedIndex=0,this.beforeStart_(0,f,s);if(void 0===s)return e=v.length,this._cachedIndex=e,this.afterEnd_(e-1,t,f)}this._cachedIndex=e,this.intervalChanged_(e,t,s)}return this.interpolate_(e,t,f,s)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(f){let v=this.resultBuffer,e=this.sampleValues,s=this.valueSize,t=f*s;for(let f=0;f!==s;++f)v[f]=e[t+f];return v},interpolate_:function(){throw Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(t8.prototype,{beforeStart_:t8.prototype.copySampleValue_,afterEnd_:t8.prototype.copySampleValue_}),t9.prototype=Object.assign(Object.create(t8.prototype),{constructor:t9,DefaultSettings_:{endingStart:2400,endingEnd:2400},intervalChanged_:function(f,v,e){let s=this.parameterPositions,t=f-2,i=f+1,n=s[t],r=s[i];if(void 0===n)switch(this.getSettings_().endingStart){case 2401:t=f,n=2*v-e;break;case 2402:t=s.length-2,n=v+s[t]-s[t+1];break;default:t=f,n=e}if(void 0===r)switch(this.getSettings_().endingEnd){case 2401:i=f,r=2*e-v;break;case 2402:i=1,r=e+s[1]-s[0];break;default:i=f-1,r=v}let o=(e-v)*.5,a=this.valueSize;this._weightPrev=o/(v-n),this._weightNext=o/(r-e),this._offsetPrev=t*a,this._offsetNext=i*a},interpolate_:function(f,v,e,s){let t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=f*n,o=r-n,a=this._offsetPrev,l=this._offsetNext,c=this._weightPrev,h=this._weightNext,u=(e-v)/(s-v),d=u*u,p=d*u,m=-c*p+2*c*d-c*u,g=(1+c)*p+(-1.5-2*c)*d+(-.5+c)*u+1,y=(-1-h)*p+(1.5+h)*d+.5*u,x=h*p-h*d;for(let f=0;f!==n;++f)t[f]=m*i[a+f]+g*i[o+f]+y*i[r+f]+x*i[l+f];return t}}),iv.prototype=Object.assign(Object.create(t8.prototype),{constructor:iv,interpolate_:function(f,v,e,s){let t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=f*n,o=r-n,a=(e-v)/(s-v),l=1-a;for(let f=0;f!==n;++f)t[f]=i[o+f]*l+i[r+f]*a;return t}}),ie.prototype=Object.assign(Object.create(t8.prototype),{constructor:ie,interpolate_:function(f){return this.copySampleValue_(f-1)}}),Object.assign(is,{toJSON:function(f){let v;let e=f.constructor;if(void 0!==e.toJSON)v=e.toJSON(f);else{v={name:f.name,times:t7.convertArray(f.times,Array),values:t7.convertArray(f.values,Array)};let e=f.getInterpolation();e!==f.DefaultInterpolation&&(v.interpolation=e)}return v.type=f.ValueTypeName,v}}),Object.assign(is.prototype,{constructor:is,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:2301,InterpolantFactoryMethodDiscrete:function(f){return new ie(this.times,this.values,this.getValueSize(),f)},InterpolantFactoryMethodLinear:function(f){return new iv(this.times,this.values,this.getValueSize(),f)},InterpolantFactoryMethodSmooth:function(f){return new t9(this.times,this.values,this.getValueSize(),f)},setInterpolation:function(f){let v;switch(f){case 2300:v=this.InterpolantFactoryMethodDiscrete;break;case 2301:v=this.InterpolantFactoryMethodLinear;break;case 2302:v=this.InterpolantFactoryMethodSmooth}if(void 0===v){let v="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(f!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(v)}return console.warn("THREE.KeyframeTrack:",v),this}return this.createInterpolant=v,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/this.times.length},shift:function(f){if(0!==f){let v=this.times;for(let e=0,s=v.length;e!==s;++e)v[e]+=f}return this},scale:function(f){if(1!==f){let v=this.times;for(let e=0,s=v.length;e!==s;++e)v[e]*=f}return this},trim:function(f,v){let e=this.times,s=e.length,t=0,i=s-1;for(;t!==s&&e[t]<f;)++t;for(;-1!==i&&e[i]>v;)--i;if(++i,0!==t||i!==s){t>=i&&(t=(i=Math.max(i,1))-1);let f=this.getValueSize();this.times=t7.arraySlice(e,t,i),this.values=t7.arraySlice(this.values,t*f,i*f)}return this},validate:function(){let f=!0,v=this.getValueSize();v-Math.floor(v)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),f=!1);let e=this.times,s=this.values,t=e.length;0===t&&(console.error("THREE.KeyframeTrack: Track is empty.",this),f=!1);let i=null;for(let v=0;v!==t;v++){let s=e[v];if("number"==typeof s&&isNaN(s)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,v,s),f=!1;break}if(null!==i&&i>s){console.error("THREE.KeyframeTrack: Out of order keys.",this,v,s,i),f=!1;break}i=s}if(void 0!==s&&t7.isTypedArray(s))for(let v=0,e=s.length;v!==e;++v){let e=s[v];if(isNaN(e)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,v,e),f=!1;break}}return f},optimize:function(){let f=t7.arraySlice(this.times),v=t7.arraySlice(this.values),e=this.getValueSize(),s=2302===this.getInterpolation(),t=f.length-1,i=1;for(let n=1;n<t;++n){let t=!1,r=f[n];if(r!==f[n+1]&&(1!==n||r!==f[0])){if(s)t=!0;else{let f=n*e,s=f-e,i=f+e;for(let n=0;n!==e;++n){let e=v[f+n];if(e!==v[s+n]||e!==v[i+n]){t=!0;break}}}}if(t){if(n!==i){f[i]=f[n];let s=n*e,t=i*e;for(let f=0;f!==e;++f)v[t+f]=v[s+f]}++i}}if(t>0){f[i]=f[t];for(let f=t*e,s=i*e,n=0;n!==e;++n)v[s+n]=v[f+n];++i}return i!==f.length?(this.times=t7.arraySlice(f,0,i),this.values=t7.arraySlice(v,0,i*e)):(this.times=f,this.values=v),this},clone:function(){let f=t7.arraySlice(this.times,0),v=t7.arraySlice(this.values,0),e=new this.constructor(this.name,f,v);return e.createInterpolant=this.createInterpolant,e}}),it.prototype=Object.assign(Object.create(is.prototype),{constructor:it,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),ii.prototype=Object.assign(Object.create(is.prototype),{constructor:ii,ValueTypeName:"color"}),ir.prototype=Object.assign(Object.create(is.prototype),{constructor:ir,ValueTypeName:"number"}),io.prototype=Object.assign(Object.create(t8.prototype),{constructor:io,interpolate_:function(f,v,e,s){let t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=(e-v)/(s-v),o=f*n;for(let f=o+n;o!==f;o+=4)E.slerpFlat(t,0,i,o-n,i,o,r);return t}}),ia.prototype=Object.assign(Object.create(is.prototype),{constructor:ia,ValueTypeName:"quaternion",DefaultInterpolation:2301,InterpolantFactoryMethodLinear:function(f){return new io(this.times,this.values,this.getValueSize(),f)},InterpolantFactoryMethodSmooth:void 0}),il.prototype=Object.assign(Object.create(is.prototype),{constructor:il,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),ic.prototype=Object.assign(Object.create(is.prototype),{constructor:ic,ValueTypeName:"vector"}),Object.assign(ih,{parse:function(f){let v=[],e=f.tracks,s=1/(f.fps||1);for(let f=0,t=e.length;f!==t;++f)v.push((function(f){if(void 0===f.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");let v=function(f){switch(f.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ir;case"vector":case"vector2":case"vector3":case"vector4":return ic;case"color":return ii;case"quaternion":return ia;case"bool":case"boolean":return it;case"string":return il}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+f)}(f.type);if(void 0===f.times){let v=[],e=[];t7.flattenJSON(f.keys,v,e,"value"),f.times=v,f.values=e}return void 0!==v.parse?v.parse(f):new v(f.name,f.times,f.values,f.interpolation)})(e[f]).scale(s));let t=new ih(f.name,f.duration,v,f.blendMode);return t.uuid=f.uuid,t},toJSON:function(f){let v=[],e=f.tracks,s={name:f.name,duration:f.duration,tracks:v,uuid:f.uuid,blendMode:f.blendMode};for(let f=0,s=e.length;f!==s;++f)v.push(is.toJSON(e[f]));return s},CreateFromMorphTargetSequence:function(f,v,e,s){let t=v.length,i=[];for(let f=0;f<t;f++){let n=[],r=[];n.push((f+t-1)%t,f,(f+1)%t),r.push(0,1,0);let o=t7.getKeyframeOrder(n);n=t7.sortedArray(n,1,o),r=t7.sortedArray(r,1,o),s||0!==n[0]||(n.push(t),r.push(r[0])),i.push(new ir(".morphTargetInfluences["+v[f].name+"]",n,r).scale(1/e))}return new ih(f,-1,i)},findByName:function(f,v){let e=f;Array.isArray(f)||(e=f.geometry&&f.geometry.animations||f.animations);for(let f=0;f<e.length;f++)if(e[f].name===v)return e[f];return null},CreateClipsFromMorphTargetSequences:function(f,v,e){let s={},t=/^([\w-]*?)([\d]+)$/;for(let v=0,e=f.length;v<e;v++){let e=f[v],i=e.name.match(t);if(i&&i.length>1){let f=i[1],v=s[f];v||(s[f]=v=[]),v.push(e)}}let i=[];for(let f in s)i.push(ih.CreateFromMorphTargetSequence(f,s[f],v,e));return i},parseAnimation:function(f,v){if(!f)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;let e=function(f,v,e,s,t){if(0!==e.length){let i=[],n=[];t7.flattenJSON(e,i,n,s),0!==i.length&&t.push(new f(v,i,n))}},s=[],t=f.name||"default",i=f.fps||30,n=f.blendMode,r=f.length||-1,o=f.hierarchy||[];for(let f=0;f<o.length;f++){let t=o[f].keys;if(t&&0!==t.length){if(t[0].morphTargets){let f;let v={};for(f=0;f<t.length;f++)if(t[f].morphTargets)for(let e=0;e<t[f].morphTargets.length;e++)v[t[f].morphTargets[e]]=-1;for(let e in v){let v=[],i=[];for(let s=0;s!==t[f].morphTargets.length;++s){let s=t[f];v.push(s.time),i.push(s.morphTarget===e?1:0)}s.push(new ir(".morphTargetInfluence["+e+"]",v,i))}r=v.length*(i||1)}else{let i=".bones["+v[f].name+"]";e(ic,i+".position",t,"pos",s),e(ia,i+".quaternion",t,"rot",s),e(ic,i+".scale",t,"scl",s)}}}return 0===s.length?null:new ih(t,r,s,n)}}),Object.assign(ih.prototype,{resetDuration:function(){let f=this.tracks,v=0;for(let e=0,s=f.length;e!==s;++e){let f=this.tracks[e];v=Math.max(v,f.times[f.times.length-1])}return this.duration=v,this},trim:function(){for(let f=0;f<this.tracks.length;f++)this.tracks[f].trim(0,this.duration);return this},validate:function(){let f=!0;for(let v=0;v<this.tracks.length;v++)f=f&&this.tracks[v].validate();return f},optimize:function(){for(let f=0;f<this.tracks.length;f++)this.tracks[f].optimize();return this},clone:function(){let f=[];for(let v=0;v<this.tracks.length;v++)f.push(this.tracks[v].clone());return new ih(this.name,this.duration,f,this.blendMode)},toJSON:function(){return ih.toJSON(this)}});let iu={enabled:!1,files:{},add:function(f,v){!1!==this.enabled&&(this.files[f]=v)},get:function(f){if(!1!==this.enabled)return this.files[f]},remove:function(f){delete this.files[f]},clear:function(){this.files={}}},id=new function(f,v,e){let s;let t=this,i=!1,n=0,r=0,o=[];this.onStart=void 0,this.onLoad=f,this.onProgress=v,this.onError=e,this.itemStart=function(f){r++,!1===i&&void 0!==t.onStart&&t.onStart(f,n,r),i=!0},this.itemEnd=function(f){n++,void 0!==t.onProgress&&t.onProgress(f,n,r),n===r&&(i=!1,void 0!==t.onLoad&&t.onLoad())},this.itemError=function(f){void 0!==t.onError&&t.onError(f)},this.resolveURL=function(f){return s?s(f):f},this.setURLModifier=function(f){return s=f,this},this.addHandler=function(f,v){return o.push(f,v),this},this.removeHandler=function(f){let v=o.indexOf(f);return -1!==v&&o.splice(v,2),this},this.getHandler=function(f){for(let v=0,e=o.length;v<e;v+=2){let e=o[v],s=o[v+1];if(e.global&&(e.lastIndex=0),e.test(f))return s}return null}};function ip(f){this.manager=void 0!==f?f:id,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(ip.prototype,{load:function(){},loadAsync:function(f,v){let e=this;return new Promise(function(s,t){e.load(f,s,v,t)})},parse:function(){},setCrossOrigin:function(f){return this.crossOrigin=f,this},setWithCredentials:function(f){return this.withCredentials=f,this},setPath:function(f){return this.path=f,this},setResourcePath:function(f){return this.resourcePath=f,this},setRequestHeader:function(f){return this.requestHeader=f,this}});let im={};function ig(f){ip.call(this,f)}function iy(f){ip.call(this,f)}function ix(f){ip.call(this,f)}function ib(f){ip.call(this,f)}function i_(f){ip.call(this,f)}function iw(f){ip.call(this,f)}function iM(f){ip.call(this,f)}function iS(){this.type="Curve",this.arcLengthDivisions=200}function iE(f,v,e,s,t,i,n,r){iS.call(this),this.type="EllipseCurve",this.aX=f||0,this.aY=v||0,this.xRadius=e||1,this.yRadius=s||1,this.aStartAngle=t||0,this.aEndAngle=i||2*Math.PI,this.aClockwise=n||!1,this.aRotation=r||0}function iT(f,v,e,s,t,i){iE.call(this,f,v,e,e,s,t,i),this.type="ArcCurve"}function iL(){let f=0,v=0,e=0,s=0;function t(t,i,n,r){f=t,v=n,e=-3*t+3*i-2*n-r,s=2*t-2*i+n+r}return{initCatmullRom:function(f,v,e,s,i){t(v,e,i*(e-f),i*(s-v))},initNonuniformCatmullRom:function(f,v,e,s,i,n,r){let o=(v-f)/i-(e-f)/(i+n)+(e-v)/n,a=(e-v)/n-(s-v)/(n+r)+(s-e)/r;t(v,e,o*=n,a*=n)},calc:function(t){let i=t*t;return f+v*t+e*i+i*t*s}}}ig.prototype=Object.assign(Object.create(ip.prototype),{constructor:ig,load:function(f,v,e,s){let t;void 0===f&&(f=""),void 0!==this.path&&(f=this.path+f),f=this.manager.resolveURL(f);let i=this,n=iu.get(f);if(void 0!==n)return i.manager.itemStart(f),setTimeout(function(){v&&v(n),i.manager.itemEnd(f)},0),n;if(void 0!==im[f]){im[f].push({onLoad:v,onProgress:e,onError:s});return}let r=f.match(/^data:(.*?)(;base64)?,(.*)$/);if(r){let e=r[1],t=!!r[2],n=r[3];n=decodeURIComponent(n),t&&(n=atob(n));try{let s;let t=(this.responseType||"").toLowerCase();switch(t){case"arraybuffer":case"blob":let r=new Uint8Array(n.length);for(let f=0;f<n.length;f++)r[f]=n.charCodeAt(f);s="blob"===t?new Blob([r.buffer],{type:e}):r.buffer;break;case"document":s=new DOMParser().parseFromString(n,e);break;case"json":s=JSON.parse(n);break;default:s=n}setTimeout(function(){v&&v(s),i.manager.itemEnd(f)},0)}catch(v){setTimeout(function(){s&&s(v),i.manager.itemError(f),i.manager.itemEnd(f)},0)}}else{for(let n in im[f]=[],im[f].push({onLoad:v,onProgress:e,onError:s}),(t=new XMLHttpRequest).open("GET",f,!0),t.addEventListener("load",function(v){let e=this.response,s=im[f];if(delete im[f],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),iu.add(f,e);for(let f=0,v=s.length;f<v;f++){let v=s[f];v.onLoad&&v.onLoad(e)}i.manager.itemEnd(f)}else{for(let f=0,e=s.length;f<e;f++){let e=s[f];e.onError&&e.onError(v)}i.manager.itemError(f),i.manager.itemEnd(f)}},!1),t.addEventListener("progress",function(v){let e=im[f];for(let f=0,s=e.length;f<s;f++){let s=e[f];s.onProgress&&s.onProgress(v)}},!1),t.addEventListener("error",function(v){let e=im[f];delete im[f];for(let f=0,s=e.length;f<s;f++){let s=e[f];s.onError&&s.onError(v)}i.manager.itemError(f),i.manager.itemEnd(f)},!1),t.addEventListener("abort",function(v){let e=im[f];delete im[f];for(let f=0,s=e.length;f<s;f++){let s=e[f];s.onError&&s.onError(v)}i.manager.itemError(f),i.manager.itemEnd(f)},!1),void 0!==this.responseType&&(t.responseType=this.responseType),void 0!==this.withCredentials&&(t.withCredentials=this.withCredentials),t.overrideMimeType&&t.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain"),this.requestHeader)t.setRequestHeader(n,this.requestHeader[n]);t.send(null)}return i.manager.itemStart(f),t},setResponseType:function(f){return this.responseType=f,this},setMimeType:function(f){return this.mimeType=f,this}}),iy.prototype=Object.assign(Object.create(ip.prototype),{constructor:iy,load:function(f,v,e,s){let t=this,i=new ig(t.manager);i.setPath(t.path),i.setRequestHeader(t.requestHeader),i.setWithCredentials(t.withCredentials),i.load(f,function(e){try{v(t.parse(JSON.parse(e)))}catch(v){s?s(v):console.error(v),t.manager.itemError(f)}},e,s)},parse:function(f){let v=[];for(let e=0;e<f.length;e++){let s=ih.parse(f[e]);v.push(s)}return v}}),ix.prototype=Object.assign(Object.create(ip.prototype),{constructor:ix,load:function(f,v,e,s){let t=this,i=[],n=new tM,r=new ig(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(t.withCredentials);let o=0;if(Array.isArray(f))for(let a=0,l=f.length;a<l;++a)!function(a){r.load(f[a],function(f){let e=t.parse(f,!0);i[a]={width:e.width,height:e.height,format:e.format,mipmaps:e.mipmaps},6===(o+=1)&&(1===e.mipmapCount&&(n.minFilter=1006),n.image=i,n.format=e.format,n.needsUpdate=!0,v&&v(n))},e,s)}(a);else r.load(f,function(f){let e=t.parse(f,!0);if(e.isCubemap){let f=e.mipmaps.length/e.mipmapCount;for(let v=0;v<f;v++){i[v]={mipmaps:[]};for(let f=0;f<e.mipmapCount;f++)i[v].mipmaps.push(e.mipmaps[v*e.mipmapCount+f]),i[v].format=e.format,i[v].width=e.width,i[v].height=e.height}n.image=i}else n.image.width=e.width,n.image.height=e.height,n.mipmaps=e.mipmaps;1===e.mipmapCount&&(n.minFilter=1006),n.format=e.format,n.needsUpdate=!0,v&&v(n)},e,s);return n}}),ib.prototype=Object.assign(Object.create(ip.prototype),{constructor:ib,load:function(f,v,e,s){void 0!==this.path&&(f=this.path+f),f=this.manager.resolveURL(f);let t=this,i=iu.get(f);if(void 0!==i)return t.manager.itemStart(f),setTimeout(function(){v&&v(i),t.manager.itemEnd(f)},0),i;let n=document.createElementNS("http://www.w3.org/1999/xhtml","img");function r(){n.removeEventListener("load",r,!1),n.removeEventListener("error",o,!1),iu.add(f,this),v&&v(this),t.manager.itemEnd(f)}function o(v){n.removeEventListener("load",r,!1),n.removeEventListener("error",o,!1),s&&s(v),t.manager.itemError(f),t.manager.itemEnd(f)}return n.addEventListener("load",r,!1),n.addEventListener("error",o,!1),"data:"!==f.substr(0,5)&&void 0!==this.crossOrigin&&(n.crossOrigin=this.crossOrigin),t.manager.itemStart(f),n.src=f,n}}),i_.prototype=Object.assign(Object.create(ip.prototype),{constructor:i_,load:function(f,v,e,s){let t=new vB,i=new ib(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let n=0;for(let e=0;e<f.length;++e)!function(e){i.load(f[e],function(f){t.images[e]=f,6==++n&&(t.needsUpdate=!0,v&&v(t))},void 0,s)}(e);return t}}),iw.prototype=Object.assign(Object.create(ip.prototype),{constructor:iw,load:function(f,v,e,s){let t=this,i=new vk,n=new ig(this.manager);return n.setResponseType("arraybuffer"),n.setRequestHeader(this.requestHeader),n.setPath(this.path),n.setWithCredentials(t.withCredentials),n.load(f,function(f){let e=t.parse(f);e&&(void 0!==e.image?i.image=e.image:void 0!==e.data&&(i.image.width=e.width,i.image.height=e.height,i.image.data=e.data),i.wrapS=void 0!==e.wrapS?e.wrapS:1001,i.wrapT=void 0!==e.wrapT?e.wrapT:1001,i.magFilter=void 0!==e.magFilter?e.magFilter:1006,i.minFilter=void 0!==e.minFilter?e.minFilter:1006,i.anisotropy=void 0!==e.anisotropy?e.anisotropy:1,void 0!==e.encoding&&(i.encoding=e.encoding),void 0!==e.flipY&&(i.flipY=e.flipY),void 0!==e.format&&(i.format=e.format),void 0!==e.type&&(i.type=e.type),void 0!==e.mipmaps&&(i.mipmaps=e.mipmaps,i.minFilter=1008),1===e.mipmapCount&&(i.minFilter=1006),i.needsUpdate=!0,v&&v(i,e))},e,s),i}}),iM.prototype=Object.assign(Object.create(ip.prototype),{constructor:iM,load:function(f,v,e,s){let t=new _,i=new ib(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(f,function(e){t.image=e;let s=f.search(/\.jpe?g($|\?)/i)>0||0===f.search(/^data\:image\/jpeg/);t.format=s?1022:1023,t.needsUpdate=!0,void 0!==v&&v(t)},e,s),t}}),Object.assign(iS.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(f,v){let e=this.getUtoTmapping(f);return this.getPoint(e,v)},getPoints:function(f=5){let v=[];for(let e=0;e<=f;e++)v.push(this.getPoint(e/f));return v},getSpacedPoints:function(f=5){let v=[];for(let e=0;e<=f;e++)v.push(this.getPointAt(e/f));return v},getLength:function(){let f=this.getLengths();return f[f.length-1]},getLengths:function(f){if(void 0===f&&(f=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===f+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let v=[],e,s=this.getPoint(0),t=0;v.push(0);for(let i=1;i<=f;i++)v.push(t+=(e=this.getPoint(i/f)).distanceTo(s)),s=e;return this.cacheArcLengths=v,v},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(f,v){let e;let s=this.getLengths(),t=0,i=s.length;e=v||f*s[i-1];let n=0,r=i-1,o;for(;n<=r;)if((o=s[t=Math.floor(n+(r-n)/2)]-e)<0)n=t+1;else if(o>0)r=t-1;else{r=t;break}if(s[t=r]===e)return t/(i-1);let a=s[t],l=s[t+1];return(t+(e-a)/(l-a))/(i-1)},getTangent:function(f,v){let e=f-1e-4,s=f+1e-4;e<0&&(e=0),s>1&&(s=1);let t=this.getPoint(e),i=this.getPoint(s),n=v||(t.isVector2?new g:new T);return n.copy(i).sub(t).normalize(),n},getTangentAt:function(f,v){let e=this.getUtoTmapping(f);return this.getTangent(e,v)},computeFrenetFrames:function(f,v){let e=new T,s=[],t=[],i=[],n=new T,r=new ff;for(let v=0;v<=f;v++){let e=v/f;s[v]=this.getTangentAt(e,new T),s[v].normalize()}t[0]=new T,i[0]=new T;let o=Number.MAX_VALUE,a=Math.abs(s[0].x),l=Math.abs(s[0].y),c=Math.abs(s[0].z);a<=o&&(o=a,e.set(1,0,0)),l<=o&&(o=l,e.set(0,1,0)),c<=o&&e.set(0,0,1),n.crossVectors(s[0],e).normalize(),t[0].crossVectors(s[0],n),i[0].crossVectors(s[0],t[0]);for(let v=1;v<=f;v++){if(t[v]=t[v-1].clone(),i[v]=i[v-1].clone(),n.crossVectors(s[v-1],s[v]),n.length()>Number.EPSILON){n.normalize();let f=Math.acos(m.clamp(s[v-1].dot(s[v]),-1,1));t[v].applyMatrix4(r.makeRotationAxis(n,f))}i[v].crossVectors(s[v],t[v])}if(!0===v){let v=Math.acos(m.clamp(t[0].dot(t[f]),-1,1));v/=f,s[0].dot(n.crossVectors(t[0],t[f]))>0&&(v=-v);for(let e=1;e<=f;e++)t[e].applyMatrix4(r.makeRotationAxis(s[e],v*e)),i[e].crossVectors(s[e],t[e])}return{tangents:s,normals:t,binormals:i}},clone:function(){return new this.constructor().copy(this)},copy:function(f){return this.arcLengthDivisions=f.arcLengthDivisions,this},toJSON:function(){let f={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return f.arcLengthDivisions=this.arcLengthDivisions,f.type=this.type,f},fromJSON:function(f){return this.arcLengthDivisions=f.arcLengthDivisions,this}}),iE.prototype=Object.create(iS.prototype),iE.prototype.constructor=iE,iE.prototype.isEllipseCurve=!0,iE.prototype.getPoint=function(f,v){let e=v||new g,s=2*Math.PI,t=this.aEndAngle-this.aStartAngle,i=Math.abs(t)<Number.EPSILON;for(;t<0;)t+=s;for(;t>s;)t-=s;t<Number.EPSILON&&(t=i?0:s),!0!==this.aClockwise||i||(t===s?t=-s:t-=s);let n=this.aStartAngle+f*t,r=this.aX+this.xRadius*Math.cos(n),o=this.aY+this.yRadius*Math.sin(n);if(0!==this.aRotation){let f=Math.cos(this.aRotation),v=Math.sin(this.aRotation),e=r-this.aX,s=o-this.aY;r=e*f-s*v+this.aX,o=e*v+s*f+this.aY}return e.set(r,o)},iE.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.aX=f.aX,this.aY=f.aY,this.xRadius=f.xRadius,this.yRadius=f.yRadius,this.aStartAngle=f.aStartAngle,this.aEndAngle=f.aEndAngle,this.aClockwise=f.aClockwise,this.aRotation=f.aRotation,this},iE.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.aX=this.aX,f.aY=this.aY,f.xRadius=this.xRadius,f.yRadius=this.yRadius,f.aStartAngle=this.aStartAngle,f.aEndAngle=this.aEndAngle,f.aClockwise=this.aClockwise,f.aRotation=this.aRotation,f},iE.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.aX=f.aX,this.aY=f.aY,this.xRadius=f.xRadius,this.yRadius=f.yRadius,this.aStartAngle=f.aStartAngle,this.aEndAngle=f.aEndAngle,this.aClockwise=f.aClockwise,this.aRotation=f.aRotation,this},iT.prototype=Object.create(iE.prototype),iT.prototype.constructor=iT,iT.prototype.isArcCurve=!0;let iA=new T,iR=new iL,iC=new iL,iP=new iL;function iO(f=[],v=!1,e="centripetal",s=.5){iS.call(this),this.type="CatmullRomCurve3",this.points=f,this.closed=v,this.curveType=e,this.tension=s}function iD(f,v,e,s,t){let i=(s-v)*.5,n=(t-e)*.5,r=f*f;return f*r*(2*e-2*s+i+n)+(-3*e+3*s-2*i-n)*r+i*f+e}function iI(f,v,e,s){return function(f,v){let e=1-f;return e*e*v}(f,v)+2*(1-f)*f*e+f*f*s}function iN(f,v,e,s,t){return function(f,v){let e=1-f;return e*e*e*v}(f,v)+function(f,v){let e=1-f;return 3*e*e*f*v}(f,e)+3*(1-f)*f*f*s+f*f*f*t}function iz(f=new g,v=new g,e=new g,s=new g){iS.call(this),this.type="CubicBezierCurve",this.v0=f,this.v1=v,this.v2=e,this.v3=s}function iH(f=new T,v=new T,e=new T,s=new T){iS.call(this),this.type="CubicBezierCurve3",this.v0=f,this.v1=v,this.v2=e,this.v3=s}function iF(f=new g,v=new g){iS.call(this),this.type="LineCurve",this.v1=f,this.v2=v}function iB(f=new T,v=new T){iS.call(this),this.type="LineCurve3",this.v1=f,this.v2=v}function iU(f=new g,v=new g,e=new g){iS.call(this),this.type="QuadraticBezierCurve",this.v0=f,this.v1=v,this.v2=e}function ik(f=new T,v=new T,e=new T){iS.call(this),this.type="QuadraticBezierCurve3",this.v0=f,this.v1=v,this.v2=e}function iG(f=[]){iS.call(this),this.type="SplineCurve",this.points=f}iO.prototype=Object.create(iS.prototype),iO.prototype.constructor=iO,iO.prototype.isCatmullRomCurve3=!0,iO.prototype.getPoint=function(f,v=new T){let e,s;let t=this.points,i=t.length,n=(i-(this.closed?0:1))*f,r=Math.floor(n),o=n-r;this.closed?r+=r>0?0:(Math.floor(Math.abs(r)/i)+1)*i:0===o&&r===i-1&&(r=i-2,o=1),this.closed||r>0?e=t[(r-1)%i]:(iA.subVectors(t[0],t[1]).add(t[0]),e=iA);let a=t[r%i],l=t[(r+1)%i];if(this.closed||r+2<i?s=t[(r+2)%i]:(iA.subVectors(t[i-1],t[i-2]).add(t[i-1]),s=iA),"centripetal"===this.curveType||"chordal"===this.curveType){let f="chordal"===this.curveType?.5:.25,v=Math.pow(e.distanceToSquared(a),f),t=Math.pow(a.distanceToSquared(l),f),i=Math.pow(l.distanceToSquared(s),f);t<1e-4&&(t=1),v<1e-4&&(v=t),i<1e-4&&(i=t),iR.initNonuniformCatmullRom(e.x,a.x,l.x,s.x,v,t,i),iC.initNonuniformCatmullRom(e.y,a.y,l.y,s.y,v,t,i),iP.initNonuniformCatmullRom(e.z,a.z,l.z,s.z,v,t,i)}else"catmullrom"===this.curveType&&(iR.initCatmullRom(e.x,a.x,l.x,s.x,this.tension),iC.initCatmullRom(e.y,a.y,l.y,s.y,this.tension),iP.initCatmullRom(e.z,a.z,l.z,s.z,this.tension));return v.set(iR.calc(o),iC.calc(o),iP.calc(o)),v},iO.prototype.copy=function(f){iS.prototype.copy.call(this,f),this.points=[];for(let v=0,e=f.points.length;v<e;v++){let e=f.points[v];this.points.push(e.clone())}return this.closed=f.closed,this.curveType=f.curveType,this.tension=f.tension,this},iO.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);f.points=[];for(let v=0,e=this.points.length;v<e;v++){let e=this.points[v];f.points.push(e.toArray())}return f.closed=this.closed,f.curveType=this.curveType,f.tension=this.tension,f},iO.prototype.fromJSON=function(f){iS.prototype.fromJSON.call(this,f),this.points=[];for(let v=0,e=f.points.length;v<e;v++){let e=f.points[v];this.points.push(new T().fromArray(e))}return this.closed=f.closed,this.curveType=f.curveType,this.tension=f.tension,this},iz.prototype=Object.create(iS.prototype),iz.prototype.constructor=iz,iz.prototype.isCubicBezierCurve=!0,iz.prototype.getPoint=function(f,v=new g){let e=this.v0,s=this.v1,t=this.v2,i=this.v3;return v.set(iN(f,e.x,s.x,t.x,i.x),iN(f,e.y,s.y,t.y,i.y)),v},iz.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v0.copy(f.v0),this.v1.copy(f.v1),this.v2.copy(f.v2),this.v3.copy(f.v3),this},iz.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v0=this.v0.toArray(),f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f.v3=this.v3.toArray(),f},iz.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v0.fromArray(f.v0),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this.v3.fromArray(f.v3),this},iH.prototype=Object.create(iS.prototype),iH.prototype.constructor=iH,iH.prototype.isCubicBezierCurve3=!0,iH.prototype.getPoint=function(f,v=new T){let e=this.v0,s=this.v1,t=this.v2,i=this.v3;return v.set(iN(f,e.x,s.x,t.x,i.x),iN(f,e.y,s.y,t.y,i.y),iN(f,e.z,s.z,t.z,i.z)),v},iH.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v0.copy(f.v0),this.v1.copy(f.v1),this.v2.copy(f.v2),this.v3.copy(f.v3),this},iH.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v0=this.v0.toArray(),f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f.v3=this.v3.toArray(),f},iH.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v0.fromArray(f.v0),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this.v3.fromArray(f.v3),this},iF.prototype=Object.create(iS.prototype),iF.prototype.constructor=iF,iF.prototype.isLineCurve=!0,iF.prototype.getPoint=function(f,v=new g){return 1===f?v.copy(this.v2):(v.copy(this.v2).sub(this.v1),v.multiplyScalar(f).add(this.v1)),v},iF.prototype.getPointAt=function(f,v){return this.getPoint(f,v)},iF.prototype.getTangent=function(f,v){let e=v||new g;return e.copy(this.v2).sub(this.v1).normalize(),e},iF.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v1.copy(f.v1),this.v2.copy(f.v2),this},iF.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f},iF.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this},iB.prototype=Object.create(iS.prototype),iB.prototype.constructor=iB,iB.prototype.isLineCurve3=!0,iB.prototype.getPoint=function(f,v=new T){return 1===f?v.copy(this.v2):(v.copy(this.v2).sub(this.v1),v.multiplyScalar(f).add(this.v1)),v},iB.prototype.getPointAt=function(f,v){return this.getPoint(f,v)},iB.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v1.copy(f.v1),this.v2.copy(f.v2),this},iB.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f},iB.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this},iU.prototype=Object.create(iS.prototype),iU.prototype.constructor=iU,iU.prototype.isQuadraticBezierCurve=!0,iU.prototype.getPoint=function(f,v=new g){let e=this.v0,s=this.v1,t=this.v2;return v.set(iI(f,e.x,s.x,t.x),iI(f,e.y,s.y,t.y)),v},iU.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v0.copy(f.v0),this.v1.copy(f.v1),this.v2.copy(f.v2),this},iU.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v0=this.v0.toArray(),f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f},iU.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v0.fromArray(f.v0),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this},ik.prototype=Object.create(iS.prototype),ik.prototype.constructor=ik,ik.prototype.isQuadraticBezierCurve3=!0,ik.prototype.getPoint=function(f,v=new T){let e=this.v0,s=this.v1,t=this.v2;return v.set(iI(f,e.x,s.x,t.x),iI(f,e.y,s.y,t.y),iI(f,e.z,s.z,t.z)),v},ik.prototype.copy=function(f){return iS.prototype.copy.call(this,f),this.v0.copy(f.v0),this.v1.copy(f.v1),this.v2.copy(f.v2),this},ik.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);return f.v0=this.v0.toArray(),f.v1=this.v1.toArray(),f.v2=this.v2.toArray(),f},ik.prototype.fromJSON=function(f){return iS.prototype.fromJSON.call(this,f),this.v0.fromArray(f.v0),this.v1.fromArray(f.v1),this.v2.fromArray(f.v2),this},iG.prototype=Object.create(iS.prototype),iG.prototype.constructor=iG,iG.prototype.isSplineCurve=!0,iG.prototype.getPoint=function(f,v=new g){let e=this.points,s=(e.length-1)*f,t=Math.floor(s),i=s-t,n=e[0===t?t:t-1],r=e[t],o=e[t>e.length-2?e.length-1:t+1],a=e[t>e.length-3?e.length-1:t+2];return v.set(iD(i,n.x,r.x,o.x,a.x),iD(i,n.y,r.y,o.y,a.y)),v},iG.prototype.copy=function(f){iS.prototype.copy.call(this,f),this.points=[];for(let v=0,e=f.points.length;v<e;v++){let e=f.points[v];this.points.push(e.clone())}return this},iG.prototype.toJSON=function(){let f=iS.prototype.toJSON.call(this);f.points=[];for(let v=0,e=this.points.length;v<e;v++){let e=this.points[v];f.points.push(e.toArray())}return f},iG.prototype.fromJSON=function(f){iS.prototype.fromJSON.call(this,f),this.points=[];for(let v=0,e=f.points.length;v<e;v++){let e=f.points[v];this.points.push(new g().fromArray(e))}return this};var ij=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:iT,CatmullRomCurve3:iO,CubicBezierCurve:iz,CubicBezierCurve3:iH,EllipseCurve:iE,LineCurve:iF,LineCurve3:iB,QuadraticBezierCurve:iU,QuadraticBezierCurve3:ik,SplineCurve:iG});function iV(){iS.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function iW(f){iV.call(this),this.type="Path",this.currentPoint=new g,f&&this.setFromPoints(f)}function iq(f){iW.call(this,f),this.uuid=m.generateUUID(),this.type="Shape",this.holes=[]}function iX(f,v=1){fE.call(this),this.type="Light",this.color=new fX(f),this.intensity=v}function iY(f,v,e){iX.call(this,f,e),this.type="HemisphereLight",this.position.copy(fE.DefaultUp),this.updateMatrix(),this.groundColor=new fX(v)}function iZ(f){this.camera=f,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new g(512,512),this.map=null,this.mapPass=null,this.matrix=new ff,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new vV,this._frameExtents=new g(1,1),this._viewportCount=1,this._viewports=[new M(0,0,1,1)]}function iJ(){iZ.call(this,new vH(50,1,.5,500)),this.focus=1}function i$(f,v,e,s,t,i){iX.call(this,f,v),this.type="SpotLight",this.position.copy(fE.DefaultUp),this.updateMatrix(),this.target=new fE,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(f){this.intensity=f/Math.PI}}),this.distance=void 0!==e?e:0,this.angle=void 0!==s?s:Math.PI/3,this.penumbra=void 0!==t?t:0,this.decay=void 0!==i?i:1,this.shadow=new iJ}function iQ(){iZ.call(this,new vH(90,1,.5,500)),this._frameExtents=new g(4,2),this._viewportCount=6,this._viewports=[new M(2,1,1,1),new M(0,1,1,1),new M(3,1,1,1),new M(1,1,1,1),new M(3,0,1,1),new M(1,0,1,1)],this._cubeDirections=[new T(1,0,0),new T(-1,0,0),new T(0,0,1),new T(0,0,-1),new T(0,1,0),new T(0,-1,0)],this._cubeUps=[new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,1,0),new T(0,0,1),new T(0,0,-1)]}function iK(f,v,e,s){iX.call(this,f,v),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(f){this.intensity=f/(4*Math.PI)}}),this.distance=void 0!==e?e:0,this.decay=void 0!==s?s:1,this.shadow=new iQ}function i1(f=-1,v=1,e=1,s=-1,t=.1,i=2e3){vz.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=f,this.right=v,this.top=e,this.bottom=s,this.near=t,this.far=i,this.updateProjectionMatrix()}function i2(){iZ.call(this,new i1(-5,5,5,-5,.5,500))}function i3(f,v){iX.call(this,f,v),this.type="DirectionalLight",this.position.copy(fE.DefaultUp),this.updateMatrix(),this.target=new fE,this.shadow=new i2}function i4(f,v){iX.call(this,f,v),this.type="AmbientLight"}function i0(f,v,e,s){iX.call(this,f,v),this.type="RectAreaLight",this.width=void 0!==e?e:10,this.height=void 0!==s?s:10}iV.prototype=Object.assign(Object.create(iS.prototype),{constructor:iV,add:function(f){this.curves.push(f)},closePath:function(){let f=this.curves[0].getPoint(0),v=this.curves[this.curves.length-1].getPoint(1);f.equals(v)||this.curves.push(new iF(v,f))},getPoint:function(f){let v=f*this.getLength(),e=this.getCurveLengths(),s=0;for(;s<e.length;){if(e[s]>=v){let f=e[s]-v,t=this.curves[s],i=t.getLength(),n=0===i?0:1-f/i;return t.getPointAt(n)}s++}return null},getLength:function(){let f=this.getCurveLengths();return f[f.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;let f=[],v=0;for(let e=0,s=this.curves.length;e<s;e++)f.push(v+=this.curves[e].getLength());return this.cacheLengths=f,f},getSpacedPoints:function(f=40){let v=[];for(let e=0;e<=f;e++)v.push(this.getPoint(e/f));return this.autoClose&&v.push(v[0]),v},getPoints:function(f=12){let v;let e=[];for(let s=0,t=this.curves;s<t.length;s++){let i=t[s],n=i&&i.isEllipseCurve?2*f:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?f*i.points.length:f,r=i.getPoints(n);for(let f=0;f<r.length;f++){let s=r[f];v&&v.equals(s)||(e.push(s),v=s)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(f){iS.prototype.copy.call(this,f),this.curves=[];for(let v=0,e=f.curves.length;v<e;v++){let e=f.curves[v];this.curves.push(e.clone())}return this.autoClose=f.autoClose,this},toJSON:function(){let f=iS.prototype.toJSON.call(this);f.autoClose=this.autoClose,f.curves=[];for(let v=0,e=this.curves.length;v<e;v++){let e=this.curves[v];f.curves.push(e.toJSON())}return f},fromJSON:function(f){iS.prototype.fromJSON.call(this,f),this.autoClose=f.autoClose,this.curves=[];for(let v=0,e=f.curves.length;v<e;v++){let e=f.curves[v];this.curves.push(new ij[e.type]().fromJSON(e))}return this}}),iW.prototype=Object.assign(Object.create(iV.prototype),{constructor:iW,setFromPoints:function(f){this.moveTo(f[0].x,f[0].y);for(let v=1,e=f.length;v<e;v++)this.lineTo(f[v].x,f[v].y);return this},moveTo:function(f,v){return this.currentPoint.set(f,v),this},lineTo:function(f,v){let e=new iF(this.currentPoint.clone(),new g(f,v));return this.curves.push(e),this.currentPoint.set(f,v),this},quadraticCurveTo:function(f,v,e,s){let t=new iU(this.currentPoint.clone(),new g(f,v),new g(e,s));return this.curves.push(t),this.currentPoint.set(e,s),this},bezierCurveTo:function(f,v,e,s,t,i){let n=new iz(this.currentPoint.clone(),new g(f,v),new g(e,s),new g(t,i));return this.curves.push(n),this.currentPoint.set(t,i),this},splineThru:function(f){let v=new iG([this.currentPoint.clone()].concat(f));return this.curves.push(v),this.currentPoint.copy(f[f.length-1]),this},arc:function(f,v,e,s,t,i){let n=this.currentPoint.x,r=this.currentPoint.y;return this.absarc(f+n,v+r,e,s,t,i),this},absarc:function(f,v,e,s,t,i){return this.absellipse(f,v,e,e,s,t,i),this},ellipse:function(f,v,e,s,t,i,n,r){let o=this.currentPoint.x,a=this.currentPoint.y;return this.absellipse(f+o,v+a,e,s,t,i,n,r),this},absellipse:function(f,v,e,s,t,i,n,r){let o=new iE(f,v,e,s,t,i,n,r);if(this.curves.length>0){let f=o.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(o);let a=o.getPoint(1);return this.currentPoint.copy(a),this},copy:function(f){return iV.prototype.copy.call(this,f),this.currentPoint.copy(f.currentPoint),this},toJSON:function(){let f=iV.prototype.toJSON.call(this);return f.currentPoint=this.currentPoint.toArray(),f},fromJSON:function(f){return iV.prototype.fromJSON.call(this,f),this.currentPoint.fromArray(f.currentPoint),this}}),iq.prototype=Object.assign(Object.create(iW.prototype),{constructor:iq,getPointsHoles:function(f){let v=[];for(let e=0,s=this.holes.length;e<s;e++)v[e]=this.holes[e].getPoints(f);return v},extractPoints:function(f){return{shape:this.getPoints(f),holes:this.getPointsHoles(f)}},copy:function(f){iW.prototype.copy.call(this,f),this.holes=[];for(let v=0,e=f.holes.length;v<e;v++){let e=f.holes[v];this.holes.push(e.clone())}return this},toJSON:function(){let f=iW.prototype.toJSON.call(this);f.uuid=this.uuid,f.holes=[];for(let v=0,e=this.holes.length;v<e;v++){let e=this.holes[v];f.holes.push(e.toJSON())}return f},fromJSON:function(f){iW.prototype.fromJSON.call(this,f),this.uuid=f.uuid,this.holes=[];for(let v=0,e=f.holes.length;v<e;v++){let e=f.holes[v];this.holes.push(new iW().fromJSON(e))}return this}}),iX.prototype=Object.assign(Object.create(fE.prototype),{constructor:iX,isLight:!0,copy:function(f){return fE.prototype.copy.call(this,f),this.color.copy(f.color),this.intensity=f.intensity,this},toJSON:function(f){let v=fE.prototype.toJSON.call(this,f);return v.object.color=this.color.getHex(),v.object.intensity=this.intensity,void 0!==this.groundColor&&(v.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(v.object.distance=this.distance),void 0!==this.angle&&(v.object.angle=this.angle),void 0!==this.decay&&(v.object.decay=this.decay),void 0!==this.penumbra&&(v.object.penumbra=this.penumbra),void 0!==this.shadow&&(v.object.shadow=this.shadow.toJSON()),v}}),iY.prototype=Object.assign(Object.create(iX.prototype),{constructor:iY,isHemisphereLight:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.groundColor.copy(f.groundColor),this}}),Object.assign(iZ.prototype,{_projScreenMatrix:new ff,_lightPositionWorld:new T,_lookTarget:new T,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(f){let v=this.camera,e=this.matrix,s=this._projScreenMatrix,t=this._lookTarget,i=this._lightPositionWorld;i.setFromMatrixPosition(f.matrixWorld),v.position.copy(i),t.setFromMatrixPosition(f.target.matrixWorld),v.lookAt(t),v.updateMatrixWorld(),s.multiplyMatrices(v.projectionMatrix,v.matrixWorldInverse),this._frustum.setFromProjectionMatrix(s),e.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),e.multiply(v.projectionMatrix),e.multiply(v.matrixWorldInverse)},getViewport:function(f){return this._viewports[f]},getFrameExtents:function(){return this._frameExtents},copy:function(f){return this.camera=f.camera.clone(),this.bias=f.bias,this.radius=f.radius,this.mapSize.copy(f.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){let f={};return 0!==this.bias&&(f.bias=this.bias),0!==this.normalBias&&(f.normalBias=this.normalBias),1!==this.radius&&(f.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(f.mapSize=this.mapSize.toArray()),f.camera=this.camera.toJSON(!1).object,delete f.camera.matrix,f}}),iJ.prototype=Object.assign(Object.create(iZ.prototype),{constructor:iJ,isSpotLightShadow:!0,updateMatrices:function(f){let v=this.camera,e=2*m.RAD2DEG*f.angle*this.focus,s=this.mapSize.width/this.mapSize.height,t=f.distance||v.far;(e!==v.fov||s!==v.aspect||t!==v.far)&&(v.fov=e,v.aspect=s,v.far=t,v.updateProjectionMatrix()),iZ.prototype.updateMatrices.call(this,f)}}),i$.prototype=Object.assign(Object.create(iX.prototype),{constructor:i$,isSpotLight:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.distance=f.distance,this.angle=f.angle,this.penumbra=f.penumbra,this.decay=f.decay,this.target=f.target.clone(),this.shadow=f.shadow.clone(),this}}),iQ.prototype=Object.assign(Object.create(iZ.prototype),{constructor:iQ,isPointLightShadow:!0,updateMatrices:function(f,v=0){let e=this.camera,s=this.matrix,t=this._lightPositionWorld,i=this._lookTarget,n=this._projScreenMatrix;t.setFromMatrixPosition(f.matrixWorld),e.position.copy(t),i.copy(e.position),i.add(this._cubeDirections[v]),e.up.copy(this._cubeUps[v]),e.lookAt(i),e.updateMatrixWorld(),s.makeTranslation(-t.x,-t.y,-t.z),n.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(n)}}),iK.prototype=Object.assign(Object.create(iX.prototype),{constructor:iK,isPointLight:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.distance=f.distance,this.decay=f.decay,this.shadow=f.shadow.clone(),this}}),i1.prototype=Object.assign(Object.create(vz.prototype),{constructor:i1,isOrthographicCamera:!0,copy:function(f,v){return vz.prototype.copy.call(this,f,v),this.left=f.left,this.right=f.right,this.top=f.top,this.bottom=f.bottom,this.near=f.near,this.far=f.far,this.zoom=f.zoom,this.view=null===f.view?null:Object.assign({},f.view),this},setViewOffset:function(f,v,e,s,t,i){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=f,this.view.fullHeight=v,this.view.offsetX=e,this.view.offsetY=s,this.view.width=t,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){let f=(this.right-this.left)/(2*this.zoom),v=(this.top-this.bottom)/(2*this.zoom),e=(this.right+this.left)/2,s=(this.top+this.bottom)/2,t=e-f,i=e+f,n=s+v,r=s-v;if(null!==this.view&&this.view.enabled){let f=(this.right-this.left)/this.view.fullWidth/this.zoom,v=(this.top-this.bottom)/this.view.fullHeight/this.zoom;t+=f*this.view.offsetX,i=t+f*this.view.width,n-=v*this.view.offsetY,r=n-v*this.view.height}this.projectionMatrix.makeOrthographic(t,i,n,r,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(f){let v=fE.prototype.toJSON.call(this,f);return v.object.zoom=this.zoom,v.object.left=this.left,v.object.right=this.right,v.object.top=this.top,v.object.bottom=this.bottom,v.object.near=this.near,v.object.far=this.far,null!==this.view&&(v.object.view=Object.assign({},this.view)),v}}),i2.prototype=Object.assign(Object.create(iZ.prototype),{constructor:i2,isDirectionalLightShadow:!0,updateMatrices:function(f){iZ.prototype.updateMatrices.call(this,f)}}),i3.prototype=Object.assign(Object.create(iX.prototype),{constructor:i3,isDirectionalLight:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.target=f.target.clone(),this.shadow=f.shadow.clone(),this}}),i4.prototype=Object.assign(Object.create(iX.prototype),{constructor:i4,isAmbientLight:!0}),i0.prototype=Object.assign(Object.create(iX.prototype),{constructor:i0,isRectAreaLight:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.width=f.width,this.height=f.height,this},toJSON:function(f){let v=iX.prototype.toJSON.call(this,f);return v.object.width=this.width,v.object.height=this.height,v}});class i6{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let f=0;f<9;f++)this.coefficients.push(new T)}set(f){for(let v=0;v<9;v++)this.coefficients[v].copy(f[v]);return this}zero(){for(let f=0;f<9;f++)this.coefficients[f].set(0,0,0);return this}getAt(f,v){let e=f.x,s=f.y,t=f.z,i=this.coefficients;return v.copy(i[0]).multiplyScalar(.282095),v.addScaledVector(i[1],.488603*s),v.addScaledVector(i[2],.488603*t),v.addScaledVector(i[3],.488603*e),v.addScaledVector(i[4],e*s*1.092548),v.addScaledVector(i[5],s*t*1.092548),v.addScaledVector(i[6],.315392*(3*t*t-1)),v.addScaledVector(i[7],e*t*1.092548),v.addScaledVector(i[8],.546274*(e*e-s*s)),v}getIrradianceAt(f,v){let e=f.x,s=f.y,t=f.z,i=this.coefficients;return v.copy(i[0]).multiplyScalar(.886227),v.addScaledVector(i[1],1.023328*s),v.addScaledVector(i[2],1.023328*t),v.addScaledVector(i[3],1.023328*e),v.addScaledVector(i[4],.858086*e*s),v.addScaledVector(i[5],.858086*s*t),v.addScaledVector(i[6],.743125*t*t-.247708),v.addScaledVector(i[7],.858086*e*t),v.addScaledVector(i[8],.429043*(e*e-s*s)),v}add(f){for(let v=0;v<9;v++)this.coefficients[v].add(f.coefficients[v]);return this}addScaledSH(f,v){for(let e=0;e<9;e++)this.coefficients[e].addScaledVector(f.coefficients[e],v);return this}scale(f){for(let v=0;v<9;v++)this.coefficients[v].multiplyScalar(f);return this}lerp(f,v){for(let e=0;e<9;e++)this.coefficients[e].lerp(f.coefficients[e],v);return this}equals(f){for(let v=0;v<9;v++)if(!this.coefficients[v].equals(f.coefficients[v]))return!1;return!0}copy(f){return this.set(f.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(f,v=0){let e=this.coefficients;for(let s=0;s<9;s++)e[s].fromArray(f,v+3*s);return this}toArray(f=[],v=0){let e=this.coefficients;for(let s=0;s<9;s++)e[s].toArray(f,v+3*s);return f}static getBasisAt(f,v){let e=f.x,s=f.y,t=f.z;v[0]=.282095,v[1]=.488603*s,v[2]=.488603*t,v[3]=.488603*e,v[4]=1.092548*e*s,v[5]=1.092548*s*t,v[6]=.315392*(3*t*t-1),v[7]=1.092548*e*t,v[8]=.546274*(e*e-s*s)}}function i5(f,v){iX.call(this,void 0,v),this.type="LightProbe",this.sh=void 0!==f?f:new i6}function i7(f){ip.call(this,f),this.textures={}}i5.prototype=Object.assign(Object.create(iX.prototype),{constructor:i5,isLightProbe:!0,copy:function(f){return iX.prototype.copy.call(this,f),this.sh.copy(f.sh),this},fromJSON:function(f){return this.intensity=f.intensity,this.sh.fromArray(f.sh),this},toJSON:function(f){let v=iX.prototype.toJSON.call(this,f);return v.object.sh=this.sh.toArray(),v}}),i7.prototype=Object.assign(Object.create(ip.prototype),{constructor:i7,load:function(f,v,e,s){let t=this,i=new ig(t.manager);i.setPath(t.path),i.setRequestHeader(t.requestHeader),i.setWithCredentials(t.withCredentials),i.load(f,function(e){try{v(t.parse(JSON.parse(e)))}catch(v){s?s(v):console.error(v),t.manager.itemError(f)}},e,s)},parse:function(f){let v=this.textures;function e(f){return void 0===v[f]&&console.warn("THREE.MaterialLoader: Undefined texture",f),v[f]}let s=new t5[f.type];if(void 0!==f.uuid&&(s.uuid=f.uuid),void 0!==f.name&&(s.name=f.name),void 0!==f.color&&void 0!==s.color&&s.color.setHex(f.color),void 0!==f.roughness&&(s.roughness=f.roughness),void 0!==f.metalness&&(s.metalness=f.metalness),void 0!==f.sheen&&(s.sheen=new fX().setHex(f.sheen)),void 0!==f.emissive&&void 0!==s.emissive&&s.emissive.setHex(f.emissive),void 0!==f.specular&&void 0!==s.specular&&s.specular.setHex(f.specular),void 0!==f.shininess&&(s.shininess=f.shininess),void 0!==f.clearcoat&&(s.clearcoat=f.clearcoat),void 0!==f.clearcoatRoughness&&(s.clearcoatRoughness=f.clearcoatRoughness),void 0!==f.fog&&(s.fog=f.fog),void 0!==f.flatShading&&(s.flatShading=f.flatShading),void 0!==f.blending&&(s.blending=f.blending),void 0!==f.combine&&(s.combine=f.combine),void 0!==f.side&&(s.side=f.side),void 0!==f.opacity&&(s.opacity=f.opacity),void 0!==f.transparent&&(s.transparent=f.transparent),void 0!==f.alphaTest&&(s.alphaTest=f.alphaTest),void 0!==f.depthTest&&(s.depthTest=f.depthTest),void 0!==f.depthWrite&&(s.depthWrite=f.depthWrite),void 0!==f.colorWrite&&(s.colorWrite=f.colorWrite),void 0!==f.stencilWrite&&(s.stencilWrite=f.stencilWrite),void 0!==f.stencilWriteMask&&(s.stencilWriteMask=f.stencilWriteMask),void 0!==f.stencilFunc&&(s.stencilFunc=f.stencilFunc),void 0!==f.stencilRef&&(s.stencilRef=f.stencilRef),void 0!==f.stencilFuncMask&&(s.stencilFuncMask=f.stencilFuncMask),void 0!==f.stencilFail&&(s.stencilFail=f.stencilFail),void 0!==f.stencilZFail&&(s.stencilZFail=f.stencilZFail),void 0!==f.stencilZPass&&(s.stencilZPass=f.stencilZPass),void 0!==f.wireframe&&(s.wireframe=f.wireframe),void 0!==f.wireframeLinewidth&&(s.wireframeLinewidth=f.wireframeLinewidth),void 0!==f.wireframeLinecap&&(s.wireframeLinecap=f.wireframeLinecap),void 0!==f.wireframeLinejoin&&(s.wireframeLinejoin=f.wireframeLinejoin),void 0!==f.rotation&&(s.rotation=f.rotation),1!==f.linewidth&&(s.linewidth=f.linewidth),void 0!==f.dashSize&&(s.dashSize=f.dashSize),void 0!==f.gapSize&&(s.gapSize=f.gapSize),void 0!==f.scale&&(s.scale=f.scale),void 0!==f.polygonOffset&&(s.polygonOffset=f.polygonOffset),void 0!==f.polygonOffsetFactor&&(s.polygonOffsetFactor=f.polygonOffsetFactor),void 0!==f.polygonOffsetUnits&&(s.polygonOffsetUnits=f.polygonOffsetUnits),void 0!==f.skinning&&(s.skinning=f.skinning),void 0!==f.morphTargets&&(s.morphTargets=f.morphTargets),void 0!==f.morphNormals&&(s.morphNormals=f.morphNormals),void 0!==f.dithering&&(s.dithering=f.dithering),void 0!==f.vertexTangents&&(s.vertexTangents=f.vertexTangents),void 0!==f.visible&&(s.visible=f.visible),void 0!==f.toneMapped&&(s.toneMapped=f.toneMapped),void 0!==f.userData&&(s.userData=f.userData),void 0!==f.vertexColors&&("number"==typeof f.vertexColors?s.vertexColors=f.vertexColors>0:s.vertexColors=f.vertexColors),void 0!==f.uniforms)for(let v in f.uniforms){let t=f.uniforms[v];switch(s.uniforms[v]={},t.type){case"t":s.uniforms[v].value=e(t.value);break;case"c":s.uniforms[v].value=new fX().setHex(t.value);break;case"v2":s.uniforms[v].value=new g().fromArray(t.value);break;case"v3":s.uniforms[v].value=new T().fromArray(t.value);break;case"v4":s.uniforms[v].value=new M().fromArray(t.value);break;case"m3":s.uniforms[v].value=new y().fromArray(t.value);break;case"m4":s.uniforms[v].value=new ff().fromArray(t.value);break;default:s.uniforms[v].value=t.value}}if(void 0!==f.defines&&(s.defines=f.defines),void 0!==f.vertexShader&&(s.vertexShader=f.vertexShader),void 0!==f.fragmentShader&&(s.fragmentShader=f.fragmentShader),void 0!==f.extensions)for(let v in f.extensions)s.extensions[v]=f.extensions[v];if(void 0!==f.shading&&(s.flatShading=1===f.shading),void 0!==f.size&&(s.size=f.size),void 0!==f.sizeAttenuation&&(s.sizeAttenuation=f.sizeAttenuation),void 0!==f.map&&(s.map=e(f.map)),void 0!==f.matcap&&(s.matcap=e(f.matcap)),void 0!==f.alphaMap&&(s.alphaMap=e(f.alphaMap)),void 0!==f.bumpMap&&(s.bumpMap=e(f.bumpMap)),void 0!==f.bumpScale&&(s.bumpScale=f.bumpScale),void 0!==f.normalMap&&(s.normalMap=e(f.normalMap)),void 0!==f.normalMapType&&(s.normalMapType=f.normalMapType),void 0!==f.normalScale){let v=f.normalScale;!1===Array.isArray(v)&&(v=[v,v]),s.normalScale=new g().fromArray(v)}return void 0!==f.displacementMap&&(s.displacementMap=e(f.displacementMap)),void 0!==f.displacementScale&&(s.displacementScale=f.displacementScale),void 0!==f.displacementBias&&(s.displacementBias=f.displacementBias),void 0!==f.roughnessMap&&(s.roughnessMap=e(f.roughnessMap)),void 0!==f.metalnessMap&&(s.metalnessMap=e(f.metalnessMap)),void 0!==f.emissiveMap&&(s.emissiveMap=e(f.emissiveMap)),void 0!==f.emissiveIntensity&&(s.emissiveIntensity=f.emissiveIntensity),void 0!==f.specularMap&&(s.specularMap=e(f.specularMap)),void 0!==f.envMap&&(s.envMap=e(f.envMap)),void 0!==f.envMapIntensity&&(s.envMapIntensity=f.envMapIntensity),void 0!==f.reflectivity&&(s.reflectivity=f.reflectivity),void 0!==f.refractionRatio&&(s.refractionRatio=f.refractionRatio),void 0!==f.lightMap&&(s.lightMap=e(f.lightMap)),void 0!==f.lightMapIntensity&&(s.lightMapIntensity=f.lightMapIntensity),void 0!==f.aoMap&&(s.aoMap=e(f.aoMap)),void 0!==f.aoMapIntensity&&(s.aoMapIntensity=f.aoMapIntensity),void 0!==f.gradientMap&&(s.gradientMap=e(f.gradientMap)),void 0!==f.clearcoatMap&&(s.clearcoatMap=e(f.clearcoatMap)),void 0!==f.clearcoatRoughnessMap&&(s.clearcoatRoughnessMap=e(f.clearcoatRoughnessMap)),void 0!==f.clearcoatNormalMap&&(s.clearcoatNormalMap=e(f.clearcoatNormalMap)),void 0!==f.clearcoatNormalScale&&(s.clearcoatNormalScale=new g().fromArray(f.clearcoatNormalScale)),void 0!==f.transmission&&(s.transmission=f.transmission),void 0!==f.transmissionMap&&(s.transmissionMap=e(f.transmissionMap)),s},setTextures:function(f){return this.textures=f,this}});let i8={decodeText:function(f){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(f);let v="";for(let e=0,s=f.length;e<s;e++)v+=String.fromCharCode(f[e]);try{return decodeURIComponent(escape(v))}catch(f){return v}},extractUrlBase:function(f){let v=f.lastIndexOf("/");return -1===v?"./":f.substr(0,v+1)}};function i9(){vc.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function nf(f,v,e,s){"number"==typeof e&&(s=e,e=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),f1.call(this,f,v,e),this.meshPerAttribute=s||1}function nv(f){ip.call(this,f)}function ne(f){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),ip.call(this,f),this.options={premultiplyAlpha:"none"}}function ns(){this.type="ShapePath",this.color=new fX,this.subPaths=[],this.currentPath=null}i9.prototype=Object.assign(Object.create(vc.prototype),{constructor:i9,isInstancedBufferGeometry:!0,copy:function(f){return vc.prototype.copy.call(this,f),this.instanceCount=f.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){let f=vc.prototype.toJSON.call(this);return f.instanceCount=this.instanceCount,f.isInstancedBufferGeometry=!0,f}}),nf.prototype=Object.assign(Object.create(f1.prototype),{constructor:nf,isInstancedBufferAttribute:!0,copy:function(f){return f1.prototype.copy.call(this,f),this.meshPerAttribute=f.meshPerAttribute,this},toJSON:function(){let f=f1.prototype.toJSON.call(this);return f.meshPerAttribute=this.meshPerAttribute,f.isInstancedBufferAttribute=!0,f}}),nv.prototype=Object.assign(Object.create(ip.prototype),{constructor:nv,load:function(f,v,e,s){let t=this,i=new ig(t.manager);i.setPath(t.path),i.setRequestHeader(t.requestHeader),i.setWithCredentials(t.withCredentials),i.load(f,function(e){try{v(t.parse(JSON.parse(e)))}catch(v){s?s(v):console.error(v),t.manager.itemError(f)}},e,s)},parse:function(f){let v={},e={};function s(f,s){if(void 0!==v[s])return v[s];let t=f.interleavedBuffers[s],i=function(f,v){if(void 0!==e[v])return e[v];let s=new Uint32Array(f.arrayBuffers[v]).buffer;return e[v]=s,s}(f,t.buffer),n=new sO(vs(t.type,i),t.stride);return n.uuid=t.uuid,v[s]=n,n}let t=f.isInstancedBufferGeometry?new i9:new vc,i=f.data.index;if(void 0!==i){let f=vs(i.type,i.array);t.setIndex(new f1(f,1))}let n=f.data.attributes;for(let v in n){let e;let i=n[v];if(i.isInterleavedBufferAttribute)e=new sI(s(f.data,i.data),i.itemSize,i.offset,i.normalized);else{let f=vs(i.type,i.array);e=new(i.isInstancedBufferAttribute?nf:f1)(f,i.itemSize,i.normalized)}void 0!==i.name&&(e.name=i.name),t.setAttribute(v,e)}let r=f.data.morphAttributes;if(r)for(let v in r){let e=r[v],i=[];for(let v=0,t=e.length;v<t;v++){let t;let n=e[v];t=n.isInterleavedBufferAttribute?new sI(s(f.data,n.data),n.itemSize,n.offset,n.normalized):new f1(vs(n.type,n.array),n.itemSize,n.normalized),void 0!==n.name&&(t.name=n.name),i.push(t)}t.morphAttributes[v]=i}f.data.morphTargetsRelative&&(t.morphTargetsRelative=!0);let o=f.data.groups||f.data.drawcalls||f.data.offsets;if(void 0!==o)for(let f=0,v=o.length;f!==v;++f){let v=o[f];t.addGroup(v.start,v.count,v.materialIndex)}let a=f.data.boundingSphere;if(void 0!==a){let f=new T;void 0!==a.center&&f.fromArray(a.center),t.boundingSphere=new W(f,a.radius)}return f.name&&(t.name=f.name),f.userData&&(t.userData=f.userData),t}}),ne.prototype=Object.assign(Object.create(ip.prototype),{constructor:ne,isImageBitmapLoader:!0,setOptions:function(f){return this.options=f,this},load:function(f,v,e,s){void 0===f&&(f=""),void 0!==this.path&&(f=this.path+f),f=this.manager.resolveURL(f);let t=this,i=iu.get(f);if(void 0!==i)return t.manager.itemStart(f),setTimeout(function(){v&&v(i),t.manager.itemEnd(f)},0),i;let n={};n.credentials="anonymous"===this.crossOrigin?"same-origin":"include",fetch(f,n).then(function(f){return f.blob()}).then(function(f){return createImageBitmap(f,t.options)}).then(function(e){iu.add(f,e),v&&v(e),t.manager.itemEnd(f)}).catch(function(v){s&&s(v),t.manager.itemError(f),t.manager.itemEnd(f)}),t.manager.itemStart(f)}}),Object.assign(ns.prototype,{moveTo:function(f,v){return this.currentPath=new iW,this.subPaths.push(this.currentPath),this.currentPath.moveTo(f,v),this},lineTo:function(f,v){return this.currentPath.lineTo(f,v),this},quadraticCurveTo:function(f,v,e,s){return this.currentPath.quadraticCurveTo(f,v,e,s),this},bezierCurveTo:function(f,v,e,s,t,i){return this.currentPath.bezierCurveTo(f,v,e,s,t,i),this},splineThru:function(f){return this.currentPath.splineThru(f),this},toShapes:function(f,v){let e,s,t,i,n;function r(f){let v=[];for(let e=0,s=f.length;e<s;e++){let s=f[e],t=new iq;t.curves=s.curves,v.push(t)}return v}let o=tG.isClockWise,a=this.subPaths;if(0===a.length)return[];if(!0===v)return r(a);let l=[];if(1===a.length)return s=a[0],(t=new iq).curves=s.curves,l.push(t),l;let c=!o(a[0].getPoints());c=f?!c:c;let h=[],u=[],d=[],p=0;u[0]=void 0,d[p]=[];for(let v=0,t=a.length;v<t;v++)e=o(i=(s=a[v]).getPoints()),(e=f?!e:e)?(!c&&u[p]&&p++,u[p]={s:new iq,p:i},u[p].s.curves=s.curves,c&&p++,d[p]=[]):d[p].push({h:s,p:i[0]});if(!u[0])return r(a);if(u.length>1){let f=!1,v=[];for(let f=0,v=u.length;f<v;f++)h[f]=[];for(let e=0,s=u.length;e<s;e++){let s=d[e];for(let t=0;t<s.length;t++){let i=s[t],n=!0;for(let s=0;s<u.length;s++)(function(f,v){let e=v.length,s=!1;for(let t=e-1,i=0;i<e;t=i++){let e=v[t],n=v[i],r=n.x-e.x,o=n.y-e.y;if(Math.abs(o)>Number.EPSILON){if(o<0&&(e=v[i],r=-r,n=v[t],o=-o),f.y<e.y||f.y>n.y)continue;if(f.y===e.y){if(f.x===e.x)return!0}else{let v=o*(f.x-e.x)-r*(f.y-e.y);if(0===v)return!0;if(v<0)continue;s=!s}}else{if(f.y!==e.y)continue;if(n.x<=f.x&&f.x<=e.x||e.x<=f.x&&f.x<=n.x)return!0}}return s})(i.p,u[s].p)&&(e!==s&&v.push({froms:e,tos:s,hole:t}),n?(n=!1,h[s].push(i)):f=!0);n&&h[e].push(i)}}v.length>0&&!f&&(d=h)}for(let f=0,v=u.length;f<v;f++){t=u[f].s,l.push(t),n=d[f];for(let f=0,v=n.length;f<v;f++)t.holes.push(n[f].h)}return l}});class nt{constructor(f){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=f}generateShapes(f,v=100){let e=[],s=function(f,v,e){let s=Array.from?Array.from(f):String(f).split(""),t=v/e.resolution,i=(e.boundingBox.yMax-e.boundingBox.yMin+e.underlineThickness)*t,n=[],r=0,o=0;for(let f=0;f<s.length;f++){let v=s[f];if("\n"===v)r=0,o-=i;else{let f=function(f,v,e,s,t){let i,n,r,o,a,l,c,h;let u=t.glyphs[f]||t.glyphs["?"];if(!u){console.error('THREE.Font: character "'+f+'" does not exists in font family '+t.familyName+".");return}let d=new ns;if(u.o){let f=u._cachedOutline||(u._cachedOutline=u.o.split(" "));for(let t=0,u=f.length;t<u;)switch(f[t++]){case"m":i=f[t++]*v+e,n=f[t++]*v+s,d.moveTo(i,n);break;case"l":i=f[t++]*v+e,n=f[t++]*v+s,d.lineTo(i,n);break;case"q":r=f[t++]*v+e,o=f[t++]*v+s,a=f[t++]*v+e,l=f[t++]*v+s,d.quadraticCurveTo(a,l,r,o);break;case"b":r=f[t++]*v+e,o=f[t++]*v+s,a=f[t++]*v+e,l=f[t++]*v+s,c=f[t++]*v+e,h=f[t++]*v+s,d.bezierCurveTo(a,l,c,h,r,o)}}return{offsetX:u.ha*v,path:d}}(v,t,r,o,e);r+=f.offsetX,n.push(f.path)}}return n}(f,v,this.data);for(let f=0,v=s.length;f<v;f++)Array.prototype.push.apply(e,s[f].toShapes());return e}}function ni(f){ip.call(this,f)}ni.prototype=Object.assign(Object.create(ip.prototype),{constructor:ni,load:function(f,v,e,s){let t=this,i=new ig(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(t.withCredentials),i.load(f,function(f){let e;try{e=JSON.parse(f)}catch(v){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),e=JSON.parse(f.substring(65,f.length-2))}let s=t.parse(e);v&&v(s)},e,s)},parse:function(f){return new nt(f)}});let nn={getContext:function(){return void 0===i&&(i=new(window.AudioContext||window.webkitAudioContext)),i}};function nr(f){ip.call(this,f)}function no(f,v,e){i5.call(this,void 0,e);let s=new fX().set(f),t=new fX().set(v),i=new T(s.r,s.g,s.b),n=new T(t.r,t.g,t.b),r=Math.sqrt(Math.PI),o=r*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(n).multiplyScalar(r),this.sh.coefficients[1].copy(i).sub(n).multiplyScalar(o)}function na(f,v){i5.call(this,void 0,v);let e=new fX().set(f);this.sh.coefficients[0].set(e.r,e.g,e.b).multiplyScalar(2*Math.sqrt(Math.PI))}nr.prototype=Object.assign(Object.create(ip.prototype),{constructor:nr,load:function(f,v,e,s){let t=this,i=new ig(t.manager);i.setResponseType("arraybuffer"),i.setPath(t.path),i.setRequestHeader(t.requestHeader),i.setWithCredentials(t.withCredentials),i.load(f,function(e){try{let f=e.slice(0);nn.getContext().decodeAudioData(f,function(f){v(f)})}catch(v){s?s(v):console.error(v),t.manager.itemError(f)}},e,s)}}),no.prototype=Object.assign(Object.create(i5.prototype),{constructor:no,isHemisphereLightProbe:!0,copy:function(f){return i5.prototype.copy.call(this,f),this},toJSON:function(f){return i5.prototype.toJSON.call(this,f)}}),na.prototype=Object.assign(Object.create(i5.prototype),{constructor:na,isAmbientLightProbe:!0,copy:function(f){return i5.prototype.copy.call(this,f),this},toJSON:function(f){return i5.prototype.toJSON.call(this,f)}});let nl=new ff,nc=new ff;function nh(f,v,e){let s,t,i;switch(this.binding=f,this.valueSize=e,v){case"quaternion":s=this._slerp,t=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*e),this._workIndex=5;break;case"string":case"bool":s=this._select,t=this._select,i=this._setAdditiveIdentityOther,this.buffer=Array(5*e);break;default:s=this._lerp,t=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*e)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=t,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign((function(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new vH,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new vH,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}).prototype,{update:function(f){let v=this._cache;if(v.focus!==f.focus||v.fov!==f.fov||v.aspect!==f.aspect*this.aspect||v.near!==f.near||v.far!==f.far||v.zoom!==f.zoom||v.eyeSep!==this.eyeSep){let e,s;v.focus=f.focus,v.fov=f.fov,v.aspect=f.aspect*this.aspect,v.near=f.near,v.far=f.far,v.zoom=f.zoom,v.eyeSep=this.eyeSep;let t=f.projectionMatrix.clone(),i=v.eyeSep/2,n=i*v.near/v.focus,r=v.near*Math.tan(m.DEG2RAD*v.fov*.5)/v.zoom;nc.elements[12]=-i,nl.elements[12]=i,e=-r*v.aspect+n,s=r*v.aspect+n,t.elements[0]=2*v.near/(s-e),t.elements[8]=(s+e)/(s-e),this.cameraL.projectionMatrix.copy(t),e=-r*v.aspect-n,s=r*v.aspect-n,t.elements[0]=2*v.near/(s-e),t.elements[8]=(s+e)/(s-e),this.cameraR.projectionMatrix.copy(t)}this.cameraL.matrixWorld.copy(f.matrixWorld).multiply(nc),this.cameraR.matrixWorld.copy(f.matrixWorld).multiply(nl)}}),Object.assign(nh.prototype,{accumulate:function(f,v){let e=this.buffer,s=this.valueSize,t=f*s+s,i=this.cumulativeWeight;if(0===i){for(let f=0;f!==s;++f)e[t+f]=e[f];i=v}else{i+=v;let f=v/i;this._mixBufferRegion(e,t,0,f,s)}this.cumulativeWeight=i},accumulateAdditive:function(f){let v=this.buffer,e=this.valueSize,s=e*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(v,s,0,f,e),this.cumulativeWeightAdditive+=f},apply:function(f){let v=this.valueSize,e=this.buffer,s=f*v+v,t=this.cumulativeWeight,i=this.cumulativeWeightAdditive,n=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,t<1){let f=v*this._origIndex;this._mixBufferRegion(e,s,f,1-t,v)}i>0&&this._mixBufferRegionAdditive(e,s,this._addIndex*v,1,v);for(let f=v,t=v+v;f!==t;++f)if(e[f]!==e[f+v]){n.setValue(e,s);break}},saveOriginalState:function(){let f=this.binding,v=this.buffer,e=this.valueSize,s=e*this._origIndex;f.getValue(v,s);for(let f=e;f!==s;++f)v[f]=v[s+f%e];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){let f=3*this.valueSize;this.binding.setValue(this.buffer,f)},_setAdditiveIdentityNumeric:function(){let f=this._addIndex*this.valueSize,v=f+this.valueSize;for(let e=f;e<v;e++)this.buffer[e]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){let f=this._origIndex*this.valueSize,v=this._addIndex*this.valueSize;for(let e=0;e<this.valueSize;e++)this.buffer[v+e]=this.buffer[f+e]},_select:function(f,v,e,s,t){if(s>=.5)for(let s=0;s!==t;++s)f[v+s]=f[e+s]},_slerp:function(f,v,e,s){E.slerpFlat(f,v,f,v,f,e,s)},_slerpAdditive:function(f,v,e,s,t){let i=this._workIndex*t;E.multiplyQuaternionsFlat(f,i,f,v,f,e),E.slerpFlat(f,v,f,v,f,i,s)},_lerp:function(f,v,e,s,t){let i=1-s;for(let n=0;n!==t;++n){let t=v+n;f[t]=f[t]*i+f[e+n]*s}},_lerpAdditive:function(f,v,e,s,t){for(let i=0;i!==t;++i){let t=v+i;f[t]=f[t]+f[e+i]*s}}});let nu="\\[\\]\\.:\\/",nd=RegExp("["+nu+"]","g"),np="[^"+nu+"]",nm="[^"+nu.replace("\\.","")+"]",ng=/((?:WC+[\/:])*)/.source.replace("WC",np),ny=RegExp("^"+ng+/(WCOD+)?/.source.replace("WCOD",nm)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",np)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",np)+"$"),nx=["material","materials","bones"];function nb(f,v,e){let s=e||n_.parseTrackName(v);this._targetGroup=f,this._bindings=f.subscribe_(v,s)}function n_(f,v,e){this.path=v,this.parsedPath=e||n_.parseTrackName(v),this.node=n_.findNode(f,this.parsedPath.nodeName)||f,this.rootNode=f}Object.assign(nb.prototype,{getValue:function(f,v){this.bind();let e=this._targetGroup.nCachedObjects_,s=this._bindings[e];void 0!==s&&s.getValue(f,v)},setValue:function(f,v){let e=this._bindings;for(let s=this._targetGroup.nCachedObjects_,t=e.length;s!==t;++s)e[s].setValue(f,v)},bind:function(){let f=this._bindings;for(let v=this._targetGroup.nCachedObjects_,e=f.length;v!==e;++v)f[v].bind()},unbind:function(){let f=this._bindings;for(let v=this._targetGroup.nCachedObjects_,e=f.length;v!==e;++v)f[v].unbind()}}),Object.assign(n_,{Composite:nb,create:function(f,v,e){return f&&f.isAnimationObjectGroup?new n_.Composite(f,v,e):new n_(f,v,e)},sanitizeNodeName:function(f){return f.replace(/\s/g,"_").replace(nd,"")},parseTrackName:function(f){let v=ny.exec(f);if(!v)throw Error("PropertyBinding: Cannot parse trackName: "+f);let e={nodeName:v[2],objectName:v[3],objectIndex:v[4],propertyName:v[5],propertyIndex:v[6]},s=e.nodeName&&e.nodeName.lastIndexOf(".");if(void 0!==s&&-1!==s){let f=e.nodeName.substring(s+1);-1!==nx.indexOf(f)&&(e.nodeName=e.nodeName.substring(0,s),e.objectName=f)}if(null===e.propertyName||0===e.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+f);return e},findNode:function(f,v){if(!v||""===v||"."===v||-1===v||v===f.name||v===f.uuid)return f;if(f.skeleton){let e=f.skeleton.getBoneByName(v);if(void 0!==e)return e}if(f.children){let e=function(f){for(let s=0;s<f.length;s++){let t=f[s];if(t.name===v||t.uuid===v)return t;let i=e(t.children);if(i)return i}return null},s=e(f.children);if(s)return s}return null}}),Object.assign(n_.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(f,v){f[v]=this.node[this.propertyName]},function(f,v){let e=this.resolvedProperty;for(let s=0,t=e.length;s!==t;++s)f[v++]=e[s]},function(f,v){f[v]=this.resolvedProperty[this.propertyIndex]},function(f,v){this.resolvedProperty.toArray(f,v)}],SetterByBindingTypeAndVersioning:[[function(f,v){this.targetObject[this.propertyName]=f[v]},function(f,v){this.targetObject[this.propertyName]=f[v],this.targetObject.needsUpdate=!0},function(f,v){this.targetObject[this.propertyName]=f[v],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(f,v){let e=this.resolvedProperty;for(let s=0,t=e.length;s!==t;++s)e[s]=f[v++]},function(f,v){let e=this.resolvedProperty;for(let s=0,t=e.length;s!==t;++s)e[s]=f[v++];this.targetObject.needsUpdate=!0},function(f,v){let e=this.resolvedProperty;for(let s=0,t=e.length;s!==t;++s)e[s]=f[v++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(f,v){this.resolvedProperty[this.propertyIndex]=f[v]},function(f,v){this.resolvedProperty[this.propertyIndex]=f[v],this.targetObject.needsUpdate=!0},function(f,v){this.resolvedProperty[this.propertyIndex]=f[v],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(f,v){this.resolvedProperty.fromArray(f,v)},function(f,v){this.resolvedProperty.fromArray(f,v),this.targetObject.needsUpdate=!0},function(f,v){this.resolvedProperty.fromArray(f,v),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(f,v){this.bind(),this.getValue(f,v)},setValue:function(f,v){this.bind(),this.setValue(f,v)},bind:function(){let f=this.node,v=this.parsedPath,e=v.objectName,s=v.propertyName,t=v.propertyIndex;if(f||(f=n_.findNode(this.rootNode,v.nodeName)||this.rootNode,this.node=f),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!f){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(e){let s=v.objectIndex;switch(e){case"materials":if(!f.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!f.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}f=f.material.materials;break;case"bones":if(!f.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}f=f.skeleton.bones;for(let v=0;v<f.length;v++)if(f[v].name===s){s=v;break}break;default:if(void 0===f[e]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}f=f[e]}if(void 0!==s){if(void 0===f[s]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,f);return}f=f[s]}}let i=f[s];if(void 0===i){console.error("THREE.PropertyBinding: Trying to update property for track: "+v.nodeName+"."+s+" but it wasn't found.",f);return}let n=this.Versioning.None;this.targetObject=f,void 0!==f.needsUpdate?n=this.Versioning.NeedsUpdate:void 0!==f.matrixWorldNeedsUpdate&&(n=this.Versioning.MatrixWorldNeedsUpdate);let r=this.BindingType.Direct;if(void 0!==t){if("morphTargetInfluences"===s){if(!f.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(f.geometry.isBufferGeometry){if(!f.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==f.morphTargetDictionary[t]&&(t=f.morphTargetDictionary[t])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}r=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=t}else void 0!==i.fromArray&&void 0!==i.toArray?(r=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(r=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=s;this.getValue=this.GetterByBindingType[r],this.setValue=this.SetterByBindingTypeAndVersioning[r][n]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(n_.prototype,{_getValue_unbound:n_.prototype.getValue,_setValue_unbound:n_.prototype.setValue}),Object.assign((function(){this.uuid=m.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;let f={};this._indicesByUUID=f;for(let v=0,e=arguments.length;v!==e;++v)f[arguments[v].uuid]=v;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};let v=this;this.stats={objects:{get total(){return v._objects.length},get inUse(){return this.total-v.nCachedObjects_}},get bindingsPerObject(){return v._bindings.length}}}).prototype,{isAnimationObjectGroup:!0,add:function(){let f=this._objects,v=this._indicesByUUID,e=this._paths,s=this._parsedPaths,t=this._bindings,i=t.length,n,r=f.length,o=this.nCachedObjects_;for(let a=0,l=arguments.length;a!==l;++a){let l=arguments[a],c=l.uuid,h=v[c];if(void 0===h){h=r++,v[c]=h,f.push(l);for(let f=0;f!==i;++f)t[f].push(new n_(l,e[f],s[f]))}else if(h<o){n=f[h];let r=--o,a=f[r];v[a.uuid]=h,f[h]=a,v[c]=r,f[r]=l;for(let f=0;f!==i;++f){let v=t[f],i=v[r],n=v[h];v[h]=i,void 0===n&&(n=new n_(l,e[f],s[f])),v[r]=n}}else f[h]!==n&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=o},remove:function(){let f=this._objects,v=this._indicesByUUID,e=this._bindings,s=e.length,t=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){let n=arguments[i],r=n.uuid,o=v[r];if(void 0!==o&&o>=t){let i=t++,a=f[i];v[a.uuid]=o,f[o]=a,v[r]=i,f[i]=n;for(let f=0;f!==s;++f){let v=e[f],s=v[i],t=v[o];v[o]=s,v[i]=t}}}this.nCachedObjects_=t},uncache:function(){let f=this._objects,v=this._indicesByUUID,e=this._bindings,s=e.length,t=this.nCachedObjects_,i=f.length;for(let n=0,r=arguments.length;n!==r;++n){let r=arguments[n],o=r.uuid,a=v[o];if(void 0!==a){if(delete v[o],a<t){let n=--t,r=f[n],o=--i,l=f[o];v[r.uuid]=a,f[a]=r,v[l.uuid]=n,f[n]=l,f.pop();for(let f=0;f!==s;++f){let v=e[f],s=v[n],t=v[o];v[a]=s,v[n]=t,v.pop()}}else{let t=--i,n=f[t];t>0&&(v[n.uuid]=a),f[a]=n,f.pop();for(let f=0;f!==s;++f){let v=e[f];v[a]=v[t],v.pop()}}}}this.nCachedObjects_=t},subscribe_:function(f,v){let e=this._bindingsIndicesByPath,s=e[f],t=this._bindings;if(void 0!==s)return t[s];let i=this._paths,n=this._parsedPaths,r=this._objects,o=r.length,a=this.nCachedObjects_,l=Array(o);s=t.length,e[f]=s,i.push(f),n.push(v),t.push(l);for(let e=a,s=r.length;e!==s;++e){let s=r[e];l[e]=new n_(s,f,v)}return l},unsubscribe_:function(f){let v=this._bindingsIndicesByPath,e=v[f];if(void 0!==e){let s=this._paths,t=this._parsedPaths,i=this._bindings,n=i.length-1,r=i[n];v[f[n]]=e,i[e]=r,i.pop(),t[e]=t[n],t.pop(),s[e]=s[n],s.pop()}}});class nw{constructor(f,v,e=null,s=v.blendMode){this._mixer=f,this._clip=v,this._localRoot=e,this.blendMode=s;let t=v.tracks,i=t.length,n=Array(i),r={endingStart:2400,endingEnd:2400};for(let f=0;f!==i;++f){let v=t[f].createInterpolant(null);n[f]=v,v.settings=r}this._interpolantSettings=r,this._interpolants=n,this._propertyBindings=Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(f){return this._startTime=f,this}setLoop(f,v){return this.loop=f,this.repetitions=v,this}setEffectiveWeight(f){return this.weight=f,this._effectiveWeight=this.enabled?f:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(f){return this._scheduleFading(f,0,1)}fadeOut(f){return this._scheduleFading(f,1,0)}crossFadeFrom(f,v,e){if(f.fadeOut(v),this.fadeIn(v),e){let e=this._clip.duration,s=f._clip.duration;f.warp(1,s/e,v),this.warp(e/s,1,v)}return this}crossFadeTo(f,v,e){return f.crossFadeFrom(this,v,e)}stopFading(){let f=this._weightInterpolant;return null!==f&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(f)),this}setEffectiveTimeScale(f){return this.timeScale=f,this._effectiveTimeScale=this.paused?0:f,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(f){return this.timeScale=this._clip.duration/f,this.stopWarping()}syncWith(f){return this.time=f.time,this.timeScale=f.timeScale,this.stopWarping()}halt(f){return this.warp(this._effectiveTimeScale,0,f)}warp(f,v,e){let s=this._mixer,t=s.time,i=this.timeScale,n=this._timeScaleInterpolant;null===n&&(n=s._lendControlInterpolant(),this._timeScaleInterpolant=n);let r=n.parameterPositions,o=n.sampleValues;return r[0]=t,r[1]=t+e,o[0]=f/i,o[1]=v/i,this}stopWarping(){let f=this._timeScaleInterpolant;return null!==f&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(f)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(f,v,e,s){if(!this.enabled){this._updateWeight(f);return}let t=this._startTime;if(null!==t){let s=(f-t)*e;if(s<0||0===e)return;this._startTime=null,v=e*s}v*=this._updateTimeScale(f);let i=this._updateTime(v),n=this._updateWeight(f);if(n>0){let f=this._interpolants,v=this._propertyBindings;if(2501===this.blendMode)for(let e=0,s=f.length;e!==s;++e)f[e].evaluate(i),v[e].accumulateAdditive(n);else for(let e=0,t=f.length;e!==t;++e)f[e].evaluate(i),v[e].accumulate(s,n)}}_updateWeight(f){let v=0;if(this.enabled){v=this.weight;let e=this._weightInterpolant;if(null!==e){let s=e.evaluate(f)[0];v*=s,f>e.parameterPositions[1]&&(this.stopFading(),0===s&&(this.enabled=!1))}}return this._effectiveWeight=v,v}_updateTimeScale(f){let v=0;if(!this.paused){v=this.timeScale;let e=this._timeScaleInterpolant;null!==e&&(v*=e.evaluate(f)[0],f>e.parameterPositions[1]&&(this.stopWarping(),0===v?this.paused=!0:this.timeScale=v))}return this._effectiveTimeScale=v,v}_updateTime(f){let v=this._clip.duration,e=this.loop,s=this.time+f,t=this._loopCount,i=2202===e;if(0===f)return -1===t?s:i&&(1&t)==1?v-s:s;if(2200===e){-1===t&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(s>=v)s=v;else if(s<0)s=0;else{this.time=s;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:f<0?-1:1})}}else{if(-1===t&&(f>=0?(t=0,this._setEndings(!0,0===this.repetitions,i)):this._setEndings(0===this.repetitions,!0,i)),s>=v||s<0){let e=Math.floor(s/v);s-=v*e,t+=Math.abs(e);let n=this.repetitions-t;if(n<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=f>0?v:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:f>0?1:-1});else{if(1===n){let v=f<0;this._setEndings(v,!v,i)}else this._setEndings(!1,!1,i);this._loopCount=t,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:e})}}else this.time=s;if(i&&(1&t)==1)return v-s}return s}_setEndings(f,v,e){let s=this._interpolantSettings;e?(s.endingStart=2401,s.endingEnd=2401):(f?s.endingStart=this.zeroSlopeAtStart?2401:2400:s.endingStart=2402,v?s.endingEnd=this.zeroSlopeAtEnd?2401:2400:s.endingEnd=2402)}_scheduleFading(f,v,e){let s=this._mixer,t=s.time,i=this._weightInterpolant;null===i&&(i=s._lendControlInterpolant(),this._weightInterpolant=i);let n=i.parameterPositions,r=i.sampleValues;return n[0]=t,r[0]=v,n[1]=t+f,r[1]=e,this}}function nM(f){this._root=f,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}nM.prototype=Object.assign(Object.create(u.prototype),{constructor:nM,_bindAction:function(f,v){let e=f._localRoot||this._root,s=f._clip.tracks,t=s.length,i=f._propertyBindings,n=f._interpolants,r=e.uuid,o=this._bindingsByRootAndName,a=o[r];void 0===a&&(a={},o[r]=a);for(let f=0;f!==t;++f){let t=s[f],o=t.name,l=a[o];if(void 0!==l)i[f]=l;else{if(void 0!==(l=i[f])){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,r,o));continue}let s=v&&v._propertyBindings[f].binding.parsedPath;l=new nh(n_.create(e,o,s),t.ValueTypeName,t.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,r,o),i[f]=l}n[f].resultBuffer=l.buffer}},_activateAction:function(f){if(!this._isActiveAction(f)){if(null===f._cacheIndex){let v=(f._localRoot||this._root).uuid,e=f._clip.uuid,s=this._actionsByClip[e];this._bindAction(f,s&&s.knownActions[0]),this._addInactiveAction(f,e,v)}let v=f._propertyBindings;for(let f=0,e=v.length;f!==e;++f){let e=v[f];0==e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(f)}},_deactivateAction:function(f){if(this._isActiveAction(f)){let v=f._propertyBindings;for(let f=0,e=v.length;f!==e;++f){let e=v[f];0==--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(f)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;let f=this;this.stats={actions:{get total(){return f._actions.length},get inUse(){return f._nActiveActions}},bindings:{get total(){return f._bindings.length},get inUse(){return f._nActiveBindings}},controlInterpolants:{get total(){return f._controlInterpolants.length},get inUse(){return f._nActiveControlInterpolants}}}},_isActiveAction:function(f){let v=f._cacheIndex;return null!==v&&v<this._nActiveActions},_addInactiveAction:function(f,v,e){let s=this._actions,t=this._actionsByClip,i=t[v];if(void 0===i)i={knownActions:[f],actionByRoot:{}},f._byClipCacheIndex=0,t[v]=i;else{let v=i.knownActions;f._byClipCacheIndex=v.length,v.push(f)}f._cacheIndex=s.length,s.push(f),i.actionByRoot[e]=f},_removeInactiveAction:function(f){let v=this._actions,e=v[v.length-1],s=f._cacheIndex;e._cacheIndex=s,v[s]=e,v.pop(),f._cacheIndex=null;let t=f._clip.uuid,i=this._actionsByClip,n=i[t],r=n.knownActions,o=r[r.length-1],a=f._byClipCacheIndex;o._byClipCacheIndex=a,r[a]=o,r.pop(),f._byClipCacheIndex=null;let l=n.actionByRoot,c=(f._localRoot||this._root).uuid;delete l[c],0===r.length&&delete i[t],this._removeInactiveBindingsForAction(f)},_removeInactiveBindingsForAction:function(f){let v=f._propertyBindings;for(let f=0,e=v.length;f!==e;++f){let e=v[f];0==--e.referenceCount&&this._removeInactiveBinding(e)}},_lendAction:function(f){let v=this._actions,e=f._cacheIndex,s=this._nActiveActions++,t=v[s];f._cacheIndex=s,v[s]=f,t._cacheIndex=e,v[e]=t},_takeBackAction:function(f){let v=this._actions,e=f._cacheIndex,s=--this._nActiveActions,t=v[s];f._cacheIndex=s,v[s]=f,t._cacheIndex=e,v[e]=t},_addInactiveBinding:function(f,v,e){let s=this._bindingsByRootAndName,t=this._bindings,i=s[v];void 0===i&&(i={},s[v]=i),i[e]=f,f._cacheIndex=t.length,t.push(f)},_removeInactiveBinding:function(f){let v=this._bindings,e=f.binding,s=e.rootNode.uuid,t=e.path,i=this._bindingsByRootAndName,n=i[s],r=v[v.length-1],o=f._cacheIndex;r._cacheIndex=o,v[o]=r,v.pop(),delete n[t],0===Object.keys(n).length&&delete i[s]},_lendBinding:function(f){let v=this._bindings,e=f._cacheIndex,s=this._nActiveBindings++,t=v[s];f._cacheIndex=s,v[s]=f,t._cacheIndex=e,v[e]=t},_takeBackBinding:function(f){let v=this._bindings,e=f._cacheIndex,s=--this._nActiveBindings,t=v[s];f._cacheIndex=s,v[s]=f,t._cacheIndex=e,v[e]=t},_lendControlInterpolant:function(){let f=this._controlInterpolants,v=this._nActiveControlInterpolants++,e=f[v];return void 0===e&&((e=new iv(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=v,f[v]=e),e},_takeBackControlInterpolant:function(f){let v=this._controlInterpolants,e=f.__cacheIndex,s=--this._nActiveControlInterpolants,t=v[s];f.__cacheIndex=s,v[s]=f,t.__cacheIndex=e,v[e]=t},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(f,v,e){let s=v||this._root,t=s.uuid,i="string"==typeof f?ih.findByName(s,f):f,n=null!==i?i.uuid:f,r=this._actionsByClip[n],o=null;if(void 0===e&&(e=null!==i?i.blendMode:2500),void 0!==r){let f=r.actionByRoot[t];if(void 0!==f&&f.blendMode===e)return f;o=r.knownActions[0],null===i&&(i=o._clip)}if(null===i)return null;let a=new nw(this,i,v,e);return this._bindAction(a,o),this._addInactiveAction(a,n,t),a},existingAction:function(f,v){let e=v||this._root,s=e.uuid,t="string"==typeof f?ih.findByName(e,f):f,i=t?t.uuid:f,n=this._actionsByClip[i];return void 0!==n&&n.actionByRoot[s]||null},stopAllAction:function(){let f=this._actions,v=this._nActiveActions;for(let e=v-1;e>=0;--e)f[e].stop();return this},update:function(f){f*=this.timeScale;let v=this._actions,e=this._nActiveActions,s=this.time+=f,t=Math.sign(f),i=this._accuIndex^=1;for(let n=0;n!==e;++n)v[n]._update(s,f,t,i);let n=this._bindings,r=this._nActiveBindings;for(let f=0;f!==r;++f)n[f].apply(i);return this},setTime:function(f){this.time=0;for(let f=0;f<this._actions.length;f++)this._actions[f].time=0;return this.update(f)},getRoot:function(){return this._root},uncacheClip:function(f){let v=this._actions,e=f.uuid,s=this._actionsByClip,t=s[e];if(void 0!==t){let f=t.knownActions;for(let e=0,s=f.length;e!==s;++e){let s=f[e];this._deactivateAction(s);let t=s._cacheIndex,i=v[v.length-1];s._cacheIndex=null,s._byClipCacheIndex=null,i._cacheIndex=t,v[t]=i,v.pop(),this._removeInactiveBindingsForAction(s)}delete s[e]}},uncacheRoot:function(f){let v=f.uuid,e=this._actionsByClip;for(let f in e){let s=e[f].actionByRoot[v];void 0!==s&&(this._deactivateAction(s),this._removeInactiveAction(s))}let s=this._bindingsByRootAndName[v];if(void 0!==s)for(let f in s){let v=s[f];v.restoreOriginalState(),this._removeInactiveBinding(v)}},uncacheAction:function(f,v){let e=this.existingAction(f,v);null!==e&&(this._deactivateAction(e),this._removeInactiveAction(e))}});class nS{constructor(f){"string"==typeof f&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),f=arguments[1]),this.value=f}clone(){return new nS(void 0===this.value.clone?this.value:this.value.clone())}}function nE(f,v,e){sO.call(this,f,v),this.meshPerAttribute=e||1}function nT(f,v,e,s,t){this.buffer=f,this.type=v,this.itemSize=e,this.elementSize=s,this.count=t,this.version=0}function nL(f,v,e,s){this.ray=new K(f,v),this.near=e||0,this.far=s||1/0,this.camera=null,this.layers=new fc,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function nA(f,v){return f.distance-v.distance}function nR(f,v,e,s){if(f.layers.test(v.layers)&&f.raycast(v,e),!0===s){let s=f.children;for(let f=0,t=s.length;f<t;f++)nR(s[f],v,e,!0)}}nE.prototype=Object.assign(Object.create(sO.prototype),{constructor:nE,isInstancedInterleavedBuffer:!0,copy:function(f){return sO.prototype.copy.call(this,f),this.meshPerAttribute=f.meshPerAttribute,this},clone:function(f){let v=sO.prototype.clone.call(this,f);return v.meshPerAttribute=this.meshPerAttribute,v},toJSON:function(f){let v=sO.prototype.toJSON.call(this,f);return v.isInstancedInterleavedBuffer=!0,v.meshPerAttribute=this.meshPerAttribute,v}}),Object.defineProperty(nT.prototype,"needsUpdate",{set:function(f){!0===f&&this.version++}}),Object.assign(nT.prototype,{isGLBufferAttribute:!0,setBuffer:function(f){return this.buffer=f,this},setType:function(f,v){return this.type=f,this.elementSize=v,this},setItemSize:function(f){return this.itemSize=f,this},setCount:function(f){return this.count=f,this}}),Object.assign(nL.prototype,{set:function(f,v){this.ray.set(f,v)},setFromCamera:function(f,v){v&&v.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(v.matrixWorld),this.ray.direction.set(f.x,f.y,.5).unproject(v).sub(this.ray.origin).normalize(),this.camera=v):v&&v.isOrthographicCamera?(this.ray.origin.set(f.x,f.y,(v.near+v.far)/(v.near-v.far)).unproject(v),this.ray.direction.set(0,0,-1).transformDirection(v.matrixWorld),this.camera=v):console.error("THREE.Raycaster: Unsupported camera type: "+v.type)},intersectObject:function(f,v,e){let s=e||[];return nR(f,this,s,v),s.sort(nA),s},intersectObjects:function(f,v,e){let s=e||[];if(!1===Array.isArray(f))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),s;for(let e=0,t=f.length;e<t;e++)nR(f[e],this,s,v);return s.sort(nA),s}});class nC{constructor(f=1,v=0,e=0){return this.radius=f,this.phi=v,this.theta=e,this}set(f,v,e){return this.radius=f,this.phi=v,this.theta=e,this}clone(){return new this.constructor().copy(this)}copy(f){return this.radius=f.radius,this.phi=f.phi,this.theta=f.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(f){return this.setFromCartesianCoords(f.x,f.y,f.z)}setFromCartesianCoords(f,v,e){return this.radius=Math.sqrt(f*f+v*v+e*e),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(f,e),this.phi=Math.acos(m.clamp(v/this.radius,-1,1))),this}}let nP=/*@__PURE__*/new g,nO=/*@__PURE__*/new T,nD=/*@__PURE__*/new T;function nI(f){fE.call(this),this.material=f,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}nI.prototype=Object.create(fE.prototype),nI.prototype.constructor=nI,nI.prototype.isImmediateRenderObject=!0;let nN=/*@__PURE__*/new T,nz=/*@__PURE__*/new ff,nH=/*@__PURE__*/new ff;new Int32Array(new Float32Array(1).buffer);let nF=[.125,.215,.35,.446,.526,.582],nB=5+nF.length,nU={3e3:0,[c]:1,3002:2,3004:3,3005:4,3006:5,3007:6},nk=new f$({side:1,depthWrite:!1,depthTest:!1}),nG=new vR(new vP,nk),nj=/*@__PURE__*/new i1,{_lodPlanes:nV,_sizeLods:nW,_sigmas:nq}=/*@__PURE__*/function(){let f=[],v=[],e=[],s=8;for(let t=0;t<nB;t++){let i=Math.pow(2,s);v.push(i);let n=1/i;t>4?n=nF[t-8+4-1]:0==t&&(n=0),e.push(n);let r=1/(i-1),o=-r/2,a=1+r/2,l=[o,o,a,o,a,a,o,o,a,a,o,a],c=new Float32Array(108),h=new Float32Array(72),u=new Float32Array(36);for(let f=0;f<6;f++){let v=f%3*2/3-1,e=f>2?0:-1,s=[v,e,0,v+2/3,e,0,v+2/3,e+1,0,v,e,0,v+2/3,e+1,0,v,e+1,0];c.set(s,18*f),h.set(l,12*f);let t=[f,f,f,f,f,f];u.set(t,6*f)}let d=new vc;d.setAttribute("position",new f1(c,3)),d.setAttribute("uv",new f1(h,2)),d.setAttribute("faceIndex",new f1(u,1)),f.push(d),s>4&&s--}return{_lodPlanes:f,_sizeLods:v,_sigmas:e}}(),nX=/*@__PURE__*/new fX,nY=null,nZ=(1+Math.sqrt(5))/2,nJ=1/nZ,n$=[/*@__PURE__*/new T(1,1,1),/*@__PURE__*/new T(-1,1,1),/*@__PURE__*/new T(1,1,-1),/*@__PURE__*/new T(-1,1,-1),/*@__PURE__*/new T(0,nZ,nJ),/*@__PURE__*/new T(0,nZ,-nJ),/*@__PURE__*/new T(nJ,0,nZ),/*@__PURE__*/new T(-nJ,0,nZ),/*@__PURE__*/new T(nZ,nJ,0),/*@__PURE__*/new T(-nZ,nJ,0)];function nQ(f){let v=Math.min(Math.max(Math.ceil(Math.log2(Math.max(f.r,f.g,f.b))),-128),127);return f.multiplyScalar(Math.pow(2,-v)),(v+128)/255}class nK{constructor(f){var v;this._renderer=f,this._pingPongRenderTarget=null,this._blurMaterial=(v=20,new t$({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:new Float32Array(20)},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:new T(0,1,0)},inputEncoding:{value:nU[3e3]},outputEncoding:{value:nU[3e3]}},vertexShader:n0(),fragmentShader:`
//         <img src=${/*@__PURE__*/v(a)} />
//         <img src=${/*@__PURE__*/v(l)} />
//           <img src=${/*@__PURE__*/v(n)} alt=${e} class="chat" />
//         <img src=${/*@__PURE__*/v(c)} class="ellipsis" />
// <img src=${/*@__PURE__*/v(t)} alt="CLEO" class="cleo-image-popup can-show">
//     <img src=${/*@__PURE__*/v(t)} alt="CLEO" class="cleo-image">
//         <img src=${/*@__PURE__*/v(o)} />
//     <img src=${/*@__PURE__*/v(t)} alt="CLEO" class="cleo-image">
//           <img src=${/*@__PURE__*/v(o)} />
//         <img src=${/*@__PURE__*/v(n)}></img>
//           <img src=${/*@__PURE__*/v(r)}></img>
//     `,this.chatbotCta=(0,h.$)("lsg-chatbot-cta"),this.cleoBoxContainer=(0,h._)(".cleo"),this.cleoImagePopup=(0,h._)(".cleo-image-popup"),this.getStartedBtn=(0,h.$)("get-started-btn"),this.backBtns=(0,h.__)(".back-btn"),this.menuLeftChatWithCleo=(0,h._)(".menu-left"),this.backBtns?.length&&this.backBtns.forEach(f=>{f.addEventListener("click",()=>{console.log("back btn clicked"),this.handleBackBtn()})}),this.menuLeftChatWithCleo.addEventListener("click",()=>{this.handleStageSwitch()}),this.chatbotCta.addEventListener("click",()=>{this.openChatDialog(),this.handleStageSwitch()}),this.getStartedBtn.addEventListener("click",()=>{this.openChatDialog(),this.handleStageSwitch()}),(0,h.$)("onboarding-form").addEventListener("submit",f=>{this.onboardUser(f)})}isStageShown=f=>(0,h.$)(`cleo-stage-${f}`)?(0,h.$)(`cleo-stage-${f}`).classList.contains("show"):null;getStageShown=()=>{for(let f=0;f<4;f++)if(this.isStageShown(f))return f;return -1};hideStage=f=>{let v=(0,h.$)(`cleo-stage-${f}`);this.isStageShown(f)&&v&&v.classList.remove("show")};showStage=f=>{let v=(0,h.$)(`cleo-stage-${f}`);!this.isStageShown(f)&&v&&v.classList.add("show")};hideInitialCTA=()=>{let f=(0,h.$)("lsg-chatbot-cta"),v=(0,h._)(".outer-circle"),e=(0,h.$)("bottom-shade");f.classList.add("hide"),v.classList.add("hide"),this.cleoImagePopup.classList.add("hide"),e.classList.add("show")};handleStageSwitch=()=>{console.log("whooo");let f=this.getStageShown();console.log({currentStage:f}),0===f&&this.hideInitialCTA(),this.hideStage(f),this.showStage(f+1)};handleBackBtn=()=>{let f=this.getStageShown();-1!==f&&(this.hideStage(f),this.showStage(f-1))};openChatDialog=()=>{this.cleoImagePopup.classList.remove("can-show"),this.cleoBoxContainer.classList.add("show")};onboardUser=f=>{console.log("adeeee"),f.preventDefault();let v=(0,h.$)("cleo-username-input").value,e=(0,h.$)("username");console.log({nameInputValue:v}),v&&(e.innerHTML=`, ${v}`),this.handleStageSwitch()}}}),n("bzToD",function(f,v){f.exports=new URL("cleo.9f8eca84.png",import.meta.url).toString()}),n("1ezLh",function(f,v){f.exports=new URL("chat.443f629a.png",import.meta.url).toString()}),n("7vpZd",function(f,v){f.exports=new URL("gamePad.7bfb72c6.png",import.meta.url).toString()}),n("lUtxv",function(f,v){f.exports=new URL("arrowHead.fff4b696.svg",import.meta.url).toString()}),n("2MGD4",function(f,v){f.exports=new URL("back.e4343001.svg",import.meta.url).toString()}),n("gsD94",function(f,v){f.exports=new URL("expand.a2021519.svg",import.meta.url).toString()}),n("1GnCN",function(f,v){f.exports=new URL("ellipsis.eb8fa9dd.svg",import.meta.url).toString()}),n("89oV3",function(v,e){f(v.exports,"$",()=>s),f(v.exports,"_",()=>t),f(v.exports,"__",()=>i);let s=f=>document.getElementById(f),t=f=>document.querySelector(f),i=f=>document.querySelectorAll(f)}),n("foJoU",function(e,s){f(e.exports,"default",()=>n);var t=i("7WnuI"),n={init:()=>{/*@__PURE__*/v(t).init()}}}),n("7WnuI",function(f,v){var s;f.exports,s=function(){var f="undefined"!=typeof window?window:void 0!==e?e:"undefined"!=typeof self?self:{},v="Expected a function",s=NaN,t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,n=/^0b[01]+$/i,r=/^0o[0-7]+$/i,o=parseInt,a="object"==typeof f&&f&&f.Object===Object&&f,l="object"==typeof self&&self&&self.Object===Object&&self,c=a||l||Function("return this")(),h=Object.prototype.toString,u=Math.max,d=Math.min,p=function(){return c.Date.now()};function m(f){var v=typeof f;return!!f&&("object"==v||"function"==v)}function g(f){if("number"==typeof f)return f;if("symbol"==typeof(v=f)||v&&"object"==typeof v&&"[object Symbol]"==h.call(v))return s;if(m(f)){var v,e="function"==typeof f.valueOf?f.valueOf():f;f=m(e)?e+"":e}if("string"!=typeof f)return 0===f?f:+f;f=f.replace(t,"");var a=n.test(f);return a||r.test(f)?o(f.slice(2),a?2:8):i.test(f)?s:+f}var y=function(f,e,s){var t=!0,i=!0;if("function"!=typeof f)throw TypeError(v);return m(s)&&(t="leading"in s?!!s.leading:t,i="trailing"in s?!!s.trailing:i),function(f,e,s){var t,i,n,r,o,a,l=0,c=!1,h=!1,y=!0;if("function"!=typeof f)throw TypeError(v);function x(v){var e=t,s=i;return t=i=void 0,l=v,r=f.apply(s,e)}function b(f){var v=f-a;return void 0===a||v>=e||v<0||h&&f-l>=n}function _(){var f,v=p();if(b(v))return w(v);o=setTimeout(_,(f=e-(v-a),h?d(f,n-(v-l)):f))}function w(f){return o=void 0,y&&t?x(f):(t=i=void 0,r)}function M(){var f,v=p(),s=b(v);if(t=arguments,i=this,a=v,s){if(void 0===o)return l=f=a,o=setTimeout(_,e),c?x(f):r;if(h)return o=setTimeout(_,e),x(a)}return void 0===o&&(o=setTimeout(_,e)),r}return e=g(e)||0,m(s)&&(c=!!s.leading,n=(h="maxWait"in s)?u(g(s.maxWait)||0,e):n,y="trailing"in s?!!s.trailing:y),M.cancel=function(){void 0!==o&&clearTimeout(o),l=0,t=a=i=o=void 0},M.flush=function(){return void 0===o?r:w(p())},M}(f,e,{leading:t,maxWait:e,trailing:i})},x=NaN,b=/^\s+|\s+$/g,_=/^[-+]0x[0-9a-f]+$/i,w=/^0b[01]+$/i,M=/^0o[0-7]+$/i,S=parseInt,E="object"==typeof f&&f&&f.Object===Object&&f,T="object"==typeof self&&self&&self.Object===Object&&self,L=E||T||Function("return this")(),A=Object.prototype.toString,R=Math.max,C=Math.min,P=function(){return L.Date.now()};function O(f){var v=typeof f;return!!f&&("object"==v||"function"==v)}function D(f){if("number"==typeof f)return f;if("symbol"==typeof(v=f)||v&&"object"==typeof v&&"[object Symbol]"==A.call(v))return x;if(O(f)){var v,e="function"==typeof f.valueOf?f.valueOf():f;f=O(e)?e+"":e}if("string"!=typeof f)return 0===f?f:+f;f=f.replace(b,"");var s=w.test(f);return s||M.test(f)?S(f.slice(2),s?2:8):_.test(f)?x:+f}var I=function(f,v,e){var s,t,i,n,r,o,a=0,l=!1,c=!1,h=!0;if("function"!=typeof f)throw TypeError("Expected a function");function u(v){var e=s,i=t;return s=t=void 0,a=v,n=f.apply(i,e)}function d(f){var e=f-o;return void 0===o||e>=v||e<0||c&&f-a>=i}function p(){var f,e=P();if(d(e))return m(e);r=setTimeout(p,(f=v-(e-o),c?C(f,i-(e-a)):f))}function m(f){return r=void 0,h&&s?u(f):(s=t=void 0,n)}function g(){var f,e=P(),i=d(e);if(s=arguments,t=this,o=e,i){if(void 0===r)return a=f=o,r=setTimeout(p,v),l?u(f):n;if(c)return r=setTimeout(p,v),u(o)}return void 0===r&&(r=setTimeout(p,v)),n}return v=D(v)||0,O(e)&&(l=!!e.leading,i=(c="maxWait"in e)?R(D(e.maxWait)||0,v):i,h="trailing"in e?!!e.trailing:h),g.cancel=function(){void 0!==r&&clearTimeout(r),a=0,s=o=t=r=void 0},g.flush=function(){return void 0===r?n:m(P())},g},N=function(){};function z(f){f&&f.forEach(function(f){var v=Array.prototype.slice.call(f.addedNodes),e=Array.prototype.slice.call(f.removedNodes);if(function f(v){var e=void 0,s=void 0;for(e=0;e<v.length;e+=1)if((s=v[e]).dataset&&s.dataset.aos||s.children&&f(s.children))return!0;return!1}(v.concat(e)))return N()})}function H(){return window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver}var F={isSupported:function(){return!!H()},ready:function(f,v){var e=window.document,s=new(H())(z);N=v,s.observe(e.documentElement,{childList:!0,subtree:!0,removedNodes:!0})}},B=function(f,v){if(!(f instanceof v))throw TypeError("Cannot call a class as a function")},U=function(){function f(f,v){for(var e=0;e<v.length;e++){var s=v[e];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(f,s.key,s)}}return function(v,e,s){return e&&f(v.prototype,e),s&&f(v,s),v}}(),k=Object.assign||function(f){for(var v=1;v<arguments.length;v++){var e=arguments[v];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(f[s]=e[s])}return f},G=/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,j=/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,V=/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,W=/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;function q(){return navigator.userAgent||navigator.vendor||window.opera||""}var X=new(function(){function f(){B(this,f)}return U(f,[{key:"phone",value:function(){var f=q();return!(!G.test(f)&&!j.test(f.substr(0,4)))}},{key:"mobile",value:function(){var f=q();return!(!V.test(f)&&!W.test(f.substr(0,4)))}},{key:"tablet",value:function(){return this.mobile()&&!this.phone()}},{key:"ie11",value:function(){return"-ms-scroll-limit"in document.documentElement.style&&"-ms-ime-align"in document.documentElement.style}}]),f}()),Y=function(f,v){var e=void 0;return X.ie11()?(e=document.createEvent("CustomEvent")).initCustomEvent(f,!0,!0,{detail:v}):e=new CustomEvent(f,{detail:v}),document.dispatchEvent(e)},Z=function(f){return f.forEach(function(f,v){var e,s,t,i,n,r;return e=window.pageYOffset,s=f.options,t=f.position,i=f.node,f.data,n=function(){var v;f.animated&&((v=s.animatedClassNames)&&v.forEach(function(f){return i.classList.remove(f)}),Y("aos:out",i),f.options.id&&Y("aos:in:"+f.options.id,i),f.animated=!1)},void(s.mirror&&e>=t.out&&!s.once?n():e>=t.in?f.animated||((r=s.animatedClassNames)&&r.forEach(function(f){return i.classList.add(f)}),Y("aos:in",i),f.options.id&&Y("aos:in:"+f.options.id,i),f.animated=!0):f.animated&&!s.once&&n())})},J=function(f){for(var v=0,e=0;f&&!isNaN(f.offsetLeft)&&!isNaN(f.offsetTop);)v+=f.offsetLeft-("BODY"!=f.tagName?f.scrollLeft:0),e+=f.offsetTop-("BODY"!=f.tagName?f.scrollTop:0),f=f.offsetParent;return{top:e,left:v}},$=function(f,v,e){var s=f.getAttribute("data-aos-"+v);if(void 0!==s){if("true"===s)return!0;if("false"===s)return!1}return s||e},Q=function(){var f=document.querySelectorAll("[data-aos]");return Array.prototype.map.call(f,function(f){return{node:f}})},K=[],ff=!1,fv={offset:120,delay:0,easing:"ease",duration:400,disable:!1,once:!1,mirror:!1,anchorPlacement:"top-bottom",startEvent:"DOMContentLoaded",animatedClassName:"aos-animate",initClassName:"aos-init",useClassNames:!1,disableMutationObserver:!1,throttleDelay:99,debounceDelay:50},fe=function(){return document.all&&!window.atob},fs=function(){var f,v;arguments.length>0&&void 0!==arguments[0]&&arguments[0]&&(ff=!0),ff&&(f=K,v=fv,f.forEach(function(f,e){var s,t,i,n,r,o=$(f.node,"mirror",v.mirror),a=$(f.node,"once",v.once),l=$(f.node,"id"),c=v.useClassNames&&f.node.getAttribute("data-aos"),h=[v.animatedClassName].concat(c?c.split(" "):[]).filter(function(f){return"string"==typeof f});v.initClassName&&f.node.classList.add(v.initClassName),f.position={in:function(f,v,e){var s=window.innerHeight,t=$(f,"anchor"),i=$(f,"anchor-placement"),n=Number($(f,"offset",i?0:v)),r=f;t&&document.querySelectorAll(t)&&(r=document.querySelectorAll(t)[0]);var o=J(r).top-s;switch(i||e){case"top-bottom":break;case"center-bottom":o+=r.offsetHeight/2;break;case"bottom-bottom":o+=r.offsetHeight;break;case"top-center":o+=s/2;break;case"center-center":o+=s/2+r.offsetHeight/2;break;case"bottom-center":o+=s/2+r.offsetHeight;break;case"top-top":o+=s;break;case"bottom-top":o+=s+r.offsetHeight;break;case"center-top":o+=s+r.offsetHeight/2}return o+n}(f.node,v.offset,v.anchorPlacement),out:o&&(s=f.node,t=v.offset,window.innerHeight,i=$(s,"anchor"),n=$(s,"offset",t),r=s,i&&document.querySelectorAll(i)&&(r=document.querySelectorAll(i)[0]),J(r).top+r.offsetHeight-n)},f.options={once:a,mirror:o,animatedClassNames:h,id:l}}),Z(K=f),window.addEventListener("scroll",y(function(){Z(K,fv.once)},fv.throttleDelay)))},ft=function(){if(K=Q(),fn(fv.disable)||fe())return fi();fs()},fi=function(){K.forEach(function(f,v){f.node.removeAttribute("data-aos"),f.node.removeAttribute("data-aos-easing"),f.node.removeAttribute("data-aos-duration"),f.node.removeAttribute("data-aos-delay"),fv.initClassName&&f.node.classList.remove(fv.initClassName),fv.animatedClassName&&f.node.classList.remove(fv.animatedClassName)})},fn=function(f){return!0===f||"mobile"===f&&X.mobile()||"phone"===f&&X.phone()||"tablet"===f&&X.tablet()||"function"==typeof f&&!0===f()};return{init:function(f){return fv=k(fv,f),K=Q(),fv.disableMutationObserver||F.isSupported()||(console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '),fv.disableMutationObserver=!0),fv.disableMutationObserver||F.ready("[data-aos]",ft),fn(fv.disable)||fe()?fi():(document.querySelector("body").setAttribute("data-aos-easing",fv.easing),document.querySelector("body").setAttribute("data-aos-duration",fv.duration),document.querySelector("body").setAttribute("data-aos-delay",fv.delay),-1===["DOMContentLoaded","load"].indexOf(fv.startEvent)?document.addEventListener(fv.startEvent,function(){fs(!0)}):window.addEventListener("load",function(){fs(!0)}),"DOMContentLoaded"===fv.startEvent&&["complete","interactive"].indexOf(document.readyState)>-1&&fs(!0),window.addEventListener("resize",I(fs,fv.debounceDelay,!0)),window.addEventListener("orientationchange",I(fs,fv.debounceDelay,!0)),K)},refresh:fs,refreshHard:ft}},f.exports=s()}),i("27Lyk").register(new URL("",import.meta.url).toString(),JSON.parse('["28p1h","index.fd552786.js","gpJGQ","cleo.9f8eca84.png","4L4zo","chat.443f629a.png","fs0kq","gamePad.7bfb72c6.png","3b5Qv","arrowHead.fff4b696.svg","foz2q","back.e4343001.svg","bG3G5","expand.a2021519.svg","6EIG4","ellipsis.eb8fa9dd.svg","curgY","index.74d6b53b.css"]')),i("n9UMu");

//# sourceMappingURL=under-construction.26623f86.js.map
